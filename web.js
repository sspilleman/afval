const map = {
    "BRANCHES": "Takken",
    "GREEN": "GFT en Etensresten",
    "GREY": "Restafval",
    "PACKAGES": "Plastic verpakkingen, Blik en Drinkpakken",
    "TEXTILE": "Kleding en Textiel",
    "TREE": "TREE"
};
const url = "https://wasteapi2.ximmio.com/api/GetCalendar";
const body = {
    "companyCode": "800bf8d7-6dd1-4490-ba9d-b419d6dc8a45",
    "startDate": "2022-12-21",
    "endDate": "2026-01-09",
    "community": "Haarlemmermeer",
    "uniqueAddressID": "1000045916"
};
const getCalendar = async ()=>{
    const r = await fetch(url, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
            "Content-Type": "application/json;charset=UTF-8"
        }
    });
    if (r.ok) {
        const json = await r.json();
        return json;
    }
};
const zones = {
    "Africa/Abidjan": "Africa/Abidjan.ics",
    "Africa/Accra": "Africa/Accra.ics",
    "Africa/Addis_Ababa": "Africa/Addis_Ababa.ics",
    "Africa/Addis Ababa": "Africa/Addis_Ababa.ics",
    "Africa/Algiers": "Africa/Algiers.ics",
    "Africa/Asmara": "Africa/Asmara.ics",
    "Africa/Bamako": "Africa/Bamako.ics",
    "Africa/Bangui": "Africa/Bangui.ics",
    "Africa/Banjul": "Africa/Banjul.ics",
    "Africa/Bissau": "Africa/Bissau.ics",
    "Africa/Blantyre": "Africa/Blantyre.ics",
    "Africa/Brazzaville": "Africa/Brazzaville.ics",
    "Africa/Bujumbura": "Africa/Bujumbura.ics",
    "Africa/Cairo": "Africa/Cairo.ics",
    "Africa/Casablanca": "Africa/Casablanca.ics",
    "Africa/Ceuta": "Africa/Ceuta.ics",
    "Africa/Conakry": "Africa/Conakry.ics",
    "Africa/Dakar": "Africa/Dakar.ics",
    "Africa/Dar_es_Salaam": "Africa/Dar_es_Salaam.ics",
    "Africa/Dar es_Salaam": "Africa/Dar_es_Salaam.ics",
    "Africa/Djibouti": "Africa/Djibouti.ics",
    "Africa/Douala": "Africa/Douala.ics",
    "Africa/El_Aaiun": "Africa/El_Aaiun.ics",
    "Africa/El Aaiun": "Africa/El_Aaiun.ics",
    "Africa/Freetown": "Africa/Freetown.ics",
    "Africa/Gaborone": "Africa/Gaborone.ics",
    "Africa/Harare": "Africa/Harare.ics",
    "Africa/Johannesburg": "Africa/Johannesburg.ics",
    "Africa/Juba": "Africa/Juba.ics",
    "Africa/Kampala": "Africa/Kampala.ics",
    "Africa/Khartoum": "Africa/Khartoum.ics",
    "Africa/Kigali": "Africa/Kigali.ics",
    "Africa/Kinshasa": "Africa/Kinshasa.ics",
    "Africa/Lagos": "Africa/Lagos.ics",
    "Africa/Libreville": "Africa/Libreville.ics",
    "Africa/Lome": "Africa/Lome.ics",
    "Africa/Luanda": "Africa/Luanda.ics",
    "Africa/Lubumbashi": "Africa/Lubumbashi.ics",
    "Africa/Lusaka": "Africa/Lusaka.ics",
    "Africa/Malabo": "Africa/Malabo.ics",
    "Africa/Maputo": "Africa/Maputo.ics",
    "Africa/Maseru": "Africa/Maseru.ics",
    "Africa/Mbabane": "Africa/Mbabane.ics",
    "Africa/Mogadishu": "Africa/Mogadishu.ics",
    "Africa/Monrovia": "Africa/Monrovia.ics",
    "Africa/Nairobi": "Africa/Nairobi.ics",
    "Africa/Ndjamena": "Africa/Ndjamena.ics",
    "Africa/Niamey": "Africa/Niamey.ics",
    "Africa/Nouakchott": "Africa/Nouakchott.ics",
    "Africa/Ouagadougou": "Africa/Ouagadougou.ics",
    "Africa/Porto-Novo": "Africa/Porto-Novo.ics",
    "Africa/Sao_Tome": "Africa/Sao_Tome.ics",
    "Africa/Sao Tome": "Africa/Sao_Tome.ics",
    "Africa/Tripoli": "Africa/Tripoli.ics",
    "Africa/Tunis": "Africa/Tunis.ics",
    "Africa/Windhoek": "Africa/Windhoek.ics",
    "America/Adak": "America/Adak.ics",
    "America/Anchorage": "America/Anchorage.ics",
    "America/Anguilla": "America/Anguilla.ics",
    "America/Antigua": "America/Antigua.ics",
    "America/Araguaina": "America/Araguaina.ics",
    "America/Argentina/Buenos_Aires": "America/Argentina/Buenos_Aires.ics",
    "America/Argentina/Buenos Aires": "America/Argentina/Buenos_Aires.ics",
    "America/Argentina/Catamarca": "America/Argentina/Catamarca.ics",
    "America/Argentina/Cordoba": "America/Argentina/Cordoba.ics",
    "America/Argentina/Jujuy": "America/Argentina/Jujuy.ics",
    "America/Argentina/La_Rioja": "America/Argentina/La_Rioja.ics",
    "America/Argentina/La Rioja": "America/Argentina/La_Rioja.ics",
    "America/Argentina/Mendoza": "America/Argentina/Mendoza.ics",
    "America/Argentina/Rio_Gallegos": "America/Argentina/Rio_Gallegos.ics",
    "America/Argentina/Rio Gallegos": "America/Argentina/Rio_Gallegos.ics",
    "America/Argentina/Salta": "America/Argentina/Salta.ics",
    "America/Argentina/San_Juan": "America/Argentina/San_Juan.ics",
    "America/Argentina/San Juan": "America/Argentina/San_Juan.ics",
    "America/Argentina/San_Luis": "America/Argentina/San_Luis.ics",
    "America/Argentina/San Luis": "America/Argentina/San_Luis.ics",
    "America/Argentina/Tucuman": "America/Argentina/Tucuman.ics",
    "America/Argentina/Ushuaia": "America/Argentina/Ushuaia.ics",
    "America/Aruba": "America/Aruba.ics",
    "America/Asuncion": "America/Asuncion.ics",
    "America/Atikokan": "America/Atikokan.ics",
    "America/Bahia_Banderas": "America/Bahia_Banderas.ics",
    "America/Bahia Banderas": "America/Bahia_Banderas.ics",
    "America/Bahia": "America/Bahia.ics",
    "America/Barbados": "America/Barbados.ics",
    "America/Belem": "America/Belem.ics",
    "America/Belize": "America/Belize.ics",
    "America/Blanc-Sablon": "America/Blanc-Sablon.ics",
    "America/Boa_Vista": "America/Boa_Vista.ics",
    "America/Boa Vista": "America/Boa_Vista.ics",
    "America/Bogota": "America/Bogota.ics",
    "America/Boise": "America/Boise.ics",
    "America/Cambridge_Bay": "America/Cambridge_Bay.ics",
    "America/Cambridge Bay": "America/Cambridge_Bay.ics",
    "America/Campo_Grande": "America/Campo_Grande.ics",
    "America/Campo Grande": "America/Campo_Grande.ics",
    "America/Cancun": "America/Cancun.ics",
    "America/Caracas": "America/Caracas.ics",
    "America/Cayenne": "America/Cayenne.ics",
    "America/Cayman": "America/Cayman.ics",
    "America/Chicago": "America/Chicago.ics",
    "America/Chihuahua": "America/Chihuahua.ics",
    "America/Costa_Rica": "America/Costa_Rica.ics",
    "America/Costa Rica": "America/Costa_Rica.ics",
    "America/Creston": "America/Creston.ics",
    "America/Cuiaba": "America/Cuiaba.ics",
    "America/Curacao": "America/Curacao.ics",
    "America/Danmarkshavn": "America/Danmarkshavn.ics",
    "America/Dawson_Creek": "America/Dawson_Creek.ics",
    "America/Dawson Creek": "America/Dawson_Creek.ics",
    "America/Dawson": "America/Dawson.ics",
    "America/Denver": "America/Denver.ics",
    "America/Detroit": "America/Detroit.ics",
    "America/Dominica": "America/Dominica.ics",
    "America/Edmonton": "America/Edmonton.ics",
    "America/Eirunepe": "America/Eirunepe.ics",
    "America/El_Salvador": "America/El_Salvador.ics",
    "America/El Salvador": "America/El_Salvador.ics",
    "America/Fort_Nelson": "America/Fort_Nelson.ics",
    "America/Fort Nelson": "America/Fort_Nelson.ics",
    "America/Fortaleza": "America/Fortaleza.ics",
    "America/Glace_Bay": "America/Glace_Bay.ics",
    "America/Glace Bay": "America/Glace_Bay.ics",
    "America/Godthab": "America/Godthab.ics",
    "America/Goose_Bay": "America/Goose_Bay.ics",
    "America/Goose Bay": "America/Goose_Bay.ics",
    "America/Grand_Turk": "America/Grand_Turk.ics",
    "America/Grand Turk": "America/Grand_Turk.ics",
    "America/Grenada": "America/Grenada.ics",
    "America/Guadeloupe": "America/Guadeloupe.ics",
    "America/Guatemala": "America/Guatemala.ics",
    "America/Guayaquil": "America/Guayaquil.ics",
    "America/Guyana": "America/Guyana.ics",
    "America/Halifax": "America/Halifax.ics",
    "America/Havana": "America/Havana.ics",
    "America/Hermosillo": "America/Hermosillo.ics",
    "America/Indiana/Indianapolis": "America/Indiana/Indianapolis.ics",
    "America/Indiana/Knox": "America/Indiana/Knox.ics",
    "America/Indiana/Marengo": "America/Indiana/Marengo.ics",
    "America/Indiana/Petersburg": "America/Indiana/Petersburg.ics",
    "America/Indiana/Tell_City": "America/Indiana/Tell_City.ics",
    "America/Indiana/Tell City": "America/Indiana/Tell_City.ics",
    "America/Indiana/Vevay": "America/Indiana/Vevay.ics",
    "America/Indiana/Vincennes": "America/Indiana/Vincennes.ics",
    "America/Indiana/Winamac": "America/Indiana/Winamac.ics",
    "America/Inuvik": "America/Inuvik.ics",
    "America/Iqaluit": "America/Iqaluit.ics",
    "America/Jamaica": "America/Jamaica.ics",
    "America/Juneau": "America/Juneau.ics",
    "America/Kentucky/Louisville": "America/Kentucky/Louisville.ics",
    "America/Kentucky/Monticello": "America/Kentucky/Monticello.ics",
    "America/Kralendijk": "America/Kralendijk.ics",
    "America/La_Paz": "America/La_Paz.ics",
    "America/La Paz": "America/La_Paz.ics",
    "America/Lima": "America/Lima.ics",
    "America/Los_Angeles": "America/Los_Angeles.ics",
    "America/Los Angeles": "America/Los_Angeles.ics",
    "America/Lower_Princes": "America/Lower_Princes.ics",
    "America/Lower Princes": "America/Lower_Princes.ics",
    "America/Maceio": "America/Maceio.ics",
    "America/Managua": "America/Managua.ics",
    "America/Manaus": "America/Manaus.ics",
    "America/Marigot": "America/Marigot.ics",
    "America/Martinique": "America/Martinique.ics",
    "America/Matamoros": "America/Matamoros.ics",
    "America/Mazatlan": "America/Mazatlan.ics",
    "America/Menominee": "America/Menominee.ics",
    "America/Merida": "America/Merida.ics",
    "America/Metlakatla": "America/Metlakatla.ics",
    "America/Mexico_City": "America/Mexico_City.ics",
    "America/Mexico City": "America/Mexico_City.ics",
    "America/Miquelon": "America/Miquelon.ics",
    "America/Moncton": "America/Moncton.ics",
    "America/Monterrey": "America/Monterrey.ics",
    "America/Montevideo": "America/Montevideo.ics",
    "America/Montserrat": "America/Montserrat.ics",
    "America/Nassau": "America/Nassau.ics",
    "America/New_York": "America/New_York.ics",
    "America/New York": "America/New_York.ics",
    "America/Nipigon": "America/Nipigon.ics",
    "America/Nome": "America/Nome.ics",
    "America/Noronha": "America/Noronha.ics",
    "America/North_Dakota/Beulah": "America/North_Dakota/Beulah.ics",
    "America/North Dakota/Beulah": "America/North_Dakota/Beulah.ics",
    "America/North_Dakota/Center": "America/North_Dakota/Center.ics",
    "America/North Dakota/Center": "America/North_Dakota/Center.ics",
    "America/North_Dakota/New_Salem": "America/North_Dakota/New_Salem.ics",
    "America/North Dakota/New_Salem": "America/North_Dakota/New_Salem.ics",
    "America/Ojinaga": "America/Ojinaga.ics",
    "America/Panama": "America/Panama.ics",
    "America/Pangnirtung": "America/Pangnirtung.ics",
    "America/Paramaribo": "America/Paramaribo.ics",
    "America/Phoenix": "America/Phoenix.ics",
    "America/Port_of_Spain": "America/Port_of_Spain.ics",
    "America/Port of_Spain": "America/Port_of_Spain.ics",
    "America/Port-au-Prince": "America/Port-au-Prince.ics",
    "America/Porto_Velho": "America/Porto_Velho.ics",
    "America/Porto Velho": "America/Porto_Velho.ics",
    "America/Puerto_Rico": "America/Puerto_Rico.ics",
    "America/Puerto Rico": "America/Puerto_Rico.ics",
    "America/Punta_Arenas": "America/Punta_Arenas.ics",
    "America/Punta Arenas": "America/Punta_Arenas.ics",
    "America/Rainy_River": "America/Rainy_River.ics",
    "America/Rainy River": "America/Rainy_River.ics",
    "America/Rankin_Inlet": "America/Rankin_Inlet.ics",
    "America/Rankin Inlet": "America/Rankin_Inlet.ics",
    "America/Recife": "America/Recife.ics",
    "America/Regina": "America/Regina.ics",
    "America/Resolute": "America/Resolute.ics",
    "America/Rio_Branco": "America/Rio_Branco.ics",
    "America/Rio Branco": "America/Rio_Branco.ics",
    "America/Santarem": "America/Santarem.ics",
    "America/Santiago": "America/Santiago.ics",
    "America/Santo_Domingo": "America/Santo_Domingo.ics",
    "America/Santo Domingo": "America/Santo_Domingo.ics",
    "America/Sao_Paulo": "America/Sao_Paulo.ics",
    "America/Sao Paulo": "America/Sao_Paulo.ics",
    "America/Scoresbysund": "America/Scoresbysund.ics",
    "America/Sitka": "America/Sitka.ics",
    "America/St_Barthelemy": "America/St_Barthelemy.ics",
    "America/St Barthelemy": "America/St_Barthelemy.ics",
    "America/St_Johns": "America/St_Johns.ics",
    "America/St Johns": "America/St_Johns.ics",
    "America/St_Kitts": "America/St_Kitts.ics",
    "America/St Kitts": "America/St_Kitts.ics",
    "America/St_Lucia": "America/St_Lucia.ics",
    "America/St Lucia": "America/St_Lucia.ics",
    "America/St_Thomas": "America/St_Thomas.ics",
    "America/St Thomas": "America/St_Thomas.ics",
    "America/St_Vincent": "America/St_Vincent.ics",
    "America/St Vincent": "America/St_Vincent.ics",
    "America/Swift_Current": "America/Swift_Current.ics",
    "America/Swift Current": "America/Swift_Current.ics",
    "America/Tegucigalpa": "America/Tegucigalpa.ics",
    "America/Thule": "America/Thule.ics",
    "America/Thunder_Bay": "America/Thunder_Bay.ics",
    "America/Thunder Bay": "America/Thunder_Bay.ics",
    "America/Tijuana": "America/Tijuana.ics",
    "America/Toronto": "America/Toronto.ics",
    "America/Tortola": "America/Tortola.ics",
    "America/Vancouver": "America/Vancouver.ics",
    "America/Whitehorse": "America/Whitehorse.ics",
    "America/Winnipeg": "America/Winnipeg.ics",
    "America/Yakutat": "America/Yakutat.ics",
    "America/Yellowknife": "America/Yellowknife.ics",
    "Antarctica/Casey": "Antarctica/Casey.ics",
    "Antarctica/Davis": "Antarctica/Davis.ics",
    "Antarctica/DumontDUrville": "Antarctica/DumontDUrville.ics",
    "Antarctica/Macquarie": "Antarctica/Macquarie.ics",
    "Antarctica/Mawson": "Antarctica/Mawson.ics",
    "Antarctica/McMurdo": "Antarctica/McMurdo.ics",
    "Antarctica/Palmer": "Antarctica/Palmer.ics",
    "Antarctica/Rothera": "Antarctica/Rothera.ics",
    "Antarctica/Syowa": "Antarctica/Syowa.ics",
    "Antarctica/Troll": "Antarctica/Troll.ics",
    "Antarctica/Vostok": "Antarctica/Vostok.ics",
    "Arctic/Longyearbyen": "Arctic/Longyearbyen.ics",
    "Asia/Aden": "Asia/Aden.ics",
    "Asia/Almaty": "Asia/Almaty.ics",
    "Asia/Amman": "Asia/Amman.ics",
    "Asia/Anadyr": "Asia/Anadyr.ics",
    "Asia/Aqtau": "Asia/Aqtau.ics",
    "Asia/Aqtobe": "Asia/Aqtobe.ics",
    "Asia/Ashgabat": "Asia/Ashgabat.ics",
    "Asia/Atyrau": "Asia/Atyrau.ics",
    "Asia/Baghdad": "Asia/Baghdad.ics",
    "Asia/Bahrain": "Asia/Bahrain.ics",
    "Asia/Baku": "Asia/Baku.ics",
    "Asia/Bangkok": "Asia/Bangkok.ics",
    "Asia/Barnaul": "Asia/Barnaul.ics",
    "Asia/Beirut": "Asia/Beirut.ics",
    "Asia/Bishkek": "Asia/Bishkek.ics",
    "Asia/Brunei": "Asia/Brunei.ics",
    "Asia/Chita": "Asia/Chita.ics",
    "Asia/Choibalsan": "Asia/Choibalsan.ics",
    "Asia/Colombo": "Asia/Colombo.ics",
    "Asia/Damascus": "Asia/Damascus.ics",
    "Asia/Dhaka": "Asia/Dhaka.ics",
    "Asia/Dili": "Asia/Dili.ics",
    "Asia/Dubai": "Asia/Dubai.ics",
    "Asia/Dushanbe": "Asia/Dushanbe.ics",
    "Asia/Famagusta": "Asia/Famagusta.ics",
    "Asia/Gaza": "Asia/Gaza.ics",
    "Asia/Hebron": "Asia/Hebron.ics",
    "Asia/Ho_Chi_Minh": "Asia/Ho_Chi_Minh.ics",
    "Asia/Ho Chi_Minh": "Asia/Ho_Chi_Minh.ics",
    "Asia/Hong_Kong": "Asia/Hong_Kong.ics",
    "Asia/Hong Kong": "Asia/Hong_Kong.ics",
    "Asia/Hovd": "Asia/Hovd.ics",
    "Asia/Irkutsk": "Asia/Irkutsk.ics",
    "Asia/Istanbul": "Asia/Istanbul.ics",
    "Asia/Jakarta": "Asia/Jakarta.ics",
    "Asia/Jayapura": "Asia/Jayapura.ics",
    "Asia/Jerusalem": "Asia/Jerusalem.ics",
    "Asia/Kabul": "Asia/Kabul.ics",
    "Asia/Kamchatka": "Asia/Kamchatka.ics",
    "Asia/Karachi": "Asia/Karachi.ics",
    "Asia/Kathmandu": "Asia/Kathmandu.ics",
    "Asia/Khandyga": "Asia/Khandyga.ics",
    "Asia/Kolkata": "Asia/Kolkata.ics",
    "Asia/Krasnoyarsk": "Asia/Krasnoyarsk.ics",
    "Asia/Kuala_Lumpur": "Asia/Kuala_Lumpur.ics",
    "Asia/Kuala Lumpur": "Asia/Kuala_Lumpur.ics",
    "Asia/Kuching": "Asia/Kuching.ics",
    "Asia/Kuwait": "Asia/Kuwait.ics",
    "Asia/Macau": "Asia/Macau.ics",
    "Asia/Magadan": "Asia/Magadan.ics",
    "Asia/Makassar": "Asia/Makassar.ics",
    "Asia/Manila": "Asia/Manila.ics",
    "Asia/Muscat": "Asia/Muscat.ics",
    "Asia/Nicosia": "Asia/Nicosia.ics",
    "Asia/Novokuznetsk": "Asia/Novokuznetsk.ics",
    "Asia/Novosibirsk": "Asia/Novosibirsk.ics",
    "Asia/Omsk": "Asia/Omsk.ics",
    "Asia/Oral": "Asia/Oral.ics",
    "Asia/Phnom_Penh": "Asia/Phnom_Penh.ics",
    "Asia/Phnom Penh": "Asia/Phnom_Penh.ics",
    "Asia/Pontianak": "Asia/Pontianak.ics",
    "Asia/Pyongyang": "Asia/Pyongyang.ics",
    "Asia/Qatar": "Asia/Qatar.ics",
    "Asia/Qyzylorda": "Asia/Qyzylorda.ics",
    "Asia/Riyadh": "Asia/Riyadh.ics",
    "Asia/Sakhalin": "Asia/Sakhalin.ics",
    "Asia/Samarkand": "Asia/Samarkand.ics",
    "Asia/Seoul": "Asia/Seoul.ics",
    "Asia/Shanghai": "Asia/Shanghai.ics",
    "Asia/Singapore": "Asia/Singapore.ics",
    "Asia/Srednekolymsk": "Asia/Srednekolymsk.ics",
    "Asia/Taipei": "Asia/Taipei.ics",
    "Asia/Tashkent": "Asia/Tashkent.ics",
    "Asia/Tbilisi": "Asia/Tbilisi.ics",
    "Asia/Tehran": "Asia/Tehran.ics",
    "Asia/Thimphu": "Asia/Thimphu.ics",
    "Asia/Tokyo": "Asia/Tokyo.ics",
    "Asia/Tomsk": "Asia/Tomsk.ics",
    "Asia/Ulaanbaatar": "Asia/Ulaanbaatar.ics",
    "Asia/Urumqi": "Asia/Urumqi.ics",
    "Asia/Ust-Nera": "Asia/Ust-Nera.ics",
    "Asia/Vientiane": "Asia/Vientiane.ics",
    "Asia/Vladivostok": "Asia/Vladivostok.ics",
    "Asia/Yakutsk": "Asia/Yakutsk.ics",
    "Asia/Yangon": "Asia/Yangon.ics",
    "Asia/Yekaterinburg": "Asia/Yekaterinburg.ics",
    "Asia/Yerevan": "Asia/Yerevan.ics",
    "Atlantic/Azores": "Atlantic/Azores.ics",
    "Atlantic/Bermuda": "Atlantic/Bermuda.ics",
    "Atlantic/Canary": "Atlantic/Canary.ics",
    "Atlantic/Cape_Verde": "Atlantic/Cape_Verde.ics",
    "Atlantic/Cape Verde": "Atlantic/Cape_Verde.ics",
    "Atlantic/Faroe": "Atlantic/Faroe.ics",
    "Atlantic/Madeira": "Atlantic/Madeira.ics",
    "Atlantic/Reykjavik": "Atlantic/Reykjavik.ics",
    "Atlantic/South_Georgia": "Atlantic/South_Georgia.ics",
    "Atlantic/South Georgia": "Atlantic/South_Georgia.ics",
    "Atlantic/St_Helena": "Atlantic/St_Helena.ics",
    "Atlantic/St Helena": "Atlantic/St_Helena.ics",
    "Atlantic/Stanley": "Atlantic/Stanley.ics",
    "Australia/Adelaide": "Australia/Adelaide.ics",
    "Australia/Brisbane": "Australia/Brisbane.ics",
    "Australia/Broken_Hill": "Australia/Broken_Hill.ics",
    "Australia/Broken Hill": "Australia/Broken_Hill.ics",
    "Australia/Currie": "Australia/Currie.ics",
    "Australia/Darwin": "Australia/Darwin.ics",
    "Australia/Eucla": "Australia/Eucla.ics",
    "Australia/Hobart": "Australia/Hobart.ics",
    "Australia/Lindeman": "Australia/Lindeman.ics",
    "Australia/Lord_Howe": "Australia/Lord_Howe.ics",
    "Australia/Lord Howe": "Australia/Lord_Howe.ics",
    "Australia/Melbourne": "Australia/Melbourne.ics",
    "Australia/Perth": "Australia/Perth.ics",
    "Australia/Sydney": "Australia/Sydney.ics",
    "Australian Central Standard Time": "Australian Central Standard Time.ics",
    "Etc/GMT-0": "Etc/GMT-0.ics",
    "GMT-0": "Etc/GMT-0.ics",
    "Etc/GMT-1": "Etc/GMT-1.ics",
    "GMT-1": "Etc/GMT-1.ics",
    "Etc/GMT-10": "Etc/GMT-10.ics",
    "GMT-10": "Etc/GMT-10.ics",
    "Etc/GMT-11": "Etc/GMT-11.ics",
    "GMT-11": "Etc/GMT-11.ics",
    "Etc/GMT-12": "Etc/GMT-12.ics",
    "GMT-12": "Etc/GMT-12.ics",
    "Etc/GMT-2": "Etc/GMT-2.ics",
    "GMT-2": "Etc/GMT-2.ics",
    "Etc/GMT-3": "Etc/GMT-3.ics",
    "GMT-3": "Etc/GMT-3.ics",
    "Etc/GMT-4": "Etc/GMT-4.ics",
    "GMT-4": "Etc/GMT-4.ics",
    "Etc/GMT-5": "Etc/GMT-5.ics",
    "GMT-5": "Etc/GMT-5.ics",
    "Etc/GMT-6": "Etc/GMT-6.ics",
    "GMT-6": "Etc/GMT-6.ics",
    "Etc/GMT-7": "Etc/GMT-7.ics",
    "GMT-7": "Etc/GMT-7.ics",
    "Etc/GMT-8": "Etc/GMT-8.ics",
    "GMT-8": "Etc/GMT-8.ics",
    "Etc/GMT-9": "Etc/GMT-9.ics",
    "GMT-9": "Etc/GMT-9.ics",
    "Etc/GMT": "Etc/GMT.ics",
    "GMT": "Etc/GMT.ics",
    "Etc/GMT+0": "Etc/GMT+0.ics",
    "GMT+0": "Etc/GMT+0.ics",
    "Etc/GMT+1": "Etc/GMT+1.ics",
    "GMT+1": "Etc/GMT+1.ics",
    "Etc/GMT+10": "Etc/GMT+10.ics",
    "GMT+10": "Etc/GMT+10.ics",
    "Etc/GMT+11": "Etc/GMT+11.ics",
    "GMT+11": "Etc/GMT+11.ics",
    "Etc/GMT+12": "Etc/GMT+12.ics",
    "GMT+12": "Etc/GMT+12.ics",
    "Etc/GMT+13": "Etc/GMT+13.ics",
    "GMT+13": "Etc/GMT+13.ics",
    "Etc/GMT+14": "Etc/GMT+14.ics",
    "GMT+14": "Etc/GMT+14.ics",
    "Etc/GMT+2": "Etc/GMT+2.ics",
    "GMT+2": "Etc/GMT+2.ics",
    "Etc/GMT+3": "Etc/GMT+3.ics",
    "GMT+3": "Etc/GMT+3.ics",
    "Etc/GMT+4": "Etc/GMT+4.ics",
    "GMT+4": "Etc/GMT+4.ics",
    "Etc/GMT+5": "Etc/GMT+5.ics",
    "GMT+5": "Etc/GMT+5.ics",
    "Etc/GMT+6": "Etc/GMT+6.ics",
    "GMT+6": "Etc/GMT+6.ics",
    "Etc/GMT+7": "Etc/GMT+7.ics",
    "GMT+7": "Etc/GMT+7.ics",
    "Etc/GMT+8": "Etc/GMT+8.ics",
    "GMT+8": "Etc/GMT+8.ics",
    "Etc/GMT+9": "Etc/GMT+9.ics",
    "GMT+9": "Etc/GMT+9.ics",
    "Etc/GMT0": "Etc/GMT0.ics",
    "GMT0": "Etc/GMT0.ics",
    "Etc/Greenwich": "Etc/Greenwich.ics",
    "Greenwich": "Etc/Greenwich.ics",
    "Etc/UCT": "Etc/UCT.ics",
    "UCT": "Etc/UCT.ics",
    "Etc/Universal": "Etc/Universal.ics",
    "Universal": "Etc/Universal.ics",
    "Etc/UTC": "Etc/UTC.ics",
    "UTC": "Etc/UTC.ics",
    "Etc/Zulu": "Etc/Zulu.ics",
    "Zulu": "Etc/Zulu.ics",
    "Europe/Amsterdam": "Europe/Amsterdam.ics",
    "Europe/Andorra": "Europe/Andorra.ics",
    "Europe/Astrakhan": "Europe/Astrakhan.ics",
    "Europe/Athens": "Europe/Athens.ics",
    "Europe/Belgrade": "Europe/Belgrade.ics",
    "Europe/Berlin": "Europe/Berlin.ics",
    "Europe/Bratislava": "Europe/Bratislava.ics",
    "Europe/Brussels": "Europe/Brussels.ics",
    "Europe/Bucharest": "Europe/Bucharest.ics",
    "Europe/Budapest": "Europe/Budapest.ics",
    "Europe/Busingen": "Europe/Busingen.ics",
    "Europe/Chisinau": "Europe/Chisinau.ics",
    "Europe/Copenhagen": "Europe/Copenhagen.ics",
    "Europe/Dublin": "Europe/Dublin.ics",
    "Europe/Gibraltar": "Europe/Gibraltar.ics",
    "Europe/Guernsey": "Europe/Guernsey.ics",
    "Europe/Helsinki": "Europe/Helsinki.ics",
    "Europe/Isle_of_Man": "Europe/Isle_of_Man.ics",
    "Europe/Isle of_Man": "Europe/Isle_of_Man.ics",
    "Europe/Istanbul": "Europe/Istanbul.ics",
    "Europe/Jersey": "Europe/Jersey.ics",
    "Europe/Kaliningrad": "Europe/Kaliningrad.ics",
    "Europe/Kiev": "Europe/Kiev.ics",
    "Europe/Kirov": "Europe/Kirov.ics",
    "Europe/Lisbon": "Europe/Lisbon.ics",
    "Europe/Ljubljana": "Europe/Ljubljana.ics",
    "Europe/London": "Europe/London.ics",
    "Europe/Luxembourg": "Europe/Luxembourg.ics",
    "Europe/Madrid": "Europe/Madrid.ics",
    "Europe/Malta": "Europe/Malta.ics",
    "Europe/Mariehamn": "Europe/Mariehamn.ics",
    "Europe/Minsk": "Europe/Minsk.ics",
    "Europe/Monaco": "Europe/Monaco.ics",
    "Europe/Moscow": "Europe/Moscow.ics",
    "Europe/Nicosia": "Europe/Nicosia.ics",
    "Europe/Oslo": "Europe/Oslo.ics",
    "Europe/Paris": "Europe/Paris.ics",
    "Europe/Podgorica": "Europe/Podgorica.ics",
    "Europe/Prague": "Europe/Prague.ics",
    "Europe/Riga": "Europe/Riga.ics",
    "Europe/Rome": "Europe/Rome.ics",
    "Europe/Samara": "Europe/Samara.ics",
    "Europe/San_Marino": "Europe/San_Marino.ics",
    "Europe/San Marino": "Europe/San_Marino.ics",
    "Europe/Sarajevo": "Europe/Sarajevo.ics",
    "Europe/Saratov": "Europe/Saratov.ics",
    "Europe/Simferopol": "Europe/Simferopol.ics",
    "Europe/Skopje": "Europe/Skopje.ics",
    "Europe/Sofia": "Europe/Sofia.ics",
    "Europe/Stockholm": "Europe/Stockholm.ics",
    "Europe/Tallinn": "Europe/Tallinn.ics",
    "Europe/Tirane": "Europe/Tirane.ics",
    "Europe/Ulyanovsk": "Europe/Ulyanovsk.ics",
    "Europe/Uzhgorod": "Europe/Uzhgorod.ics",
    "Europe/Vaduz": "Europe/Vaduz.ics",
    "Europe/Vatican": "Europe/Vatican.ics",
    "Europe/Vienna": "Europe/Vienna.ics",
    "Europe/Vilnius": "Europe/Vilnius.ics",
    "Europe/Volgograd": "Europe/Volgograd.ics",
    "Europe/Warsaw": "Europe/Warsaw.ics",
    "Europe/Zagreb": "Europe/Zagreb.ics",
    "Europe/Zaporozhye": "Europe/Zaporozhye.ics",
    "Europe/Zurich": "Europe/Zurich.ics",
    "India Standard Time": "India Standard Time.ics",
    "Indian/Antananarivo": "Indian/Antananarivo.ics",
    "Indian/Chagos": "Indian/Chagos.ics",
    "Indian/Christmas": "Indian/Christmas.ics",
    "Indian/Cocos": "Indian/Cocos.ics",
    "Indian/Comoro": "Indian/Comoro.ics",
    "Indian/Kerguelen": "Indian/Kerguelen.ics",
    "Indian/Mahe": "Indian/Mahe.ics",
    "Indian/Maldives": "Indian/Maldives.ics",
    "Indian/Mauritius": "Indian/Mauritius.ics",
    "Indian/Mayotte": "Indian/Mayotte.ics",
    "Indian/Reunion": "Indian/Reunion.ics",
    "Myanmar Time": "Myanmar Time.ics",
    "Nepal Time": "Nepal Time.ics",
    "Newfoundland Standard Time": "Newfoundland Standard Time.ics",
    "Pacific/Apia": "Pacific/Apia.ics",
    "Pacific/Auckland": "Pacific/Auckland.ics",
    "Pacific/Bougainville": "Pacific/Bougainville.ics",
    "Pacific/Chatham": "Pacific/Chatham.ics",
    "Pacific/Chuuk": "Pacific/Chuuk.ics",
    "Pacific/Easter": "Pacific/Easter.ics",
    "Pacific/Efate": "Pacific/Efate.ics",
    "Pacific/Enderbury": "Pacific/Enderbury.ics",
    "Pacific/Fakaofo": "Pacific/Fakaofo.ics",
    "Pacific/Fiji": "Pacific/Fiji.ics",
    "Pacific/Funafuti": "Pacific/Funafuti.ics",
    "Pacific/Galapagos": "Pacific/Galapagos.ics",
    "Pacific/Gambier": "Pacific/Gambier.ics",
    "Pacific/Guadalcanal": "Pacific/Guadalcanal.ics",
    "Pacific/Guam": "Pacific/Guam.ics",
    "Pacific/Honolulu": "Pacific/Honolulu.ics",
    "Pacific/Kiritimati": "Pacific/Kiritimati.ics",
    "Pacific/Kosrae": "Pacific/Kosrae.ics",
    "Pacific/Kwajalein": "Pacific/Kwajalein.ics",
    "Pacific/Majuro": "Pacific/Majuro.ics",
    "Pacific/Marquesas": "Pacific/Marquesas.ics",
    "Pacific/Midway": "Pacific/Midway.ics",
    "Pacific/Nauru": "Pacific/Nauru.ics",
    "Pacific/Niue": "Pacific/Niue.ics",
    "Pacific/Norfolk": "Pacific/Norfolk.ics",
    "Pacific/Noumea": "Pacific/Noumea.ics",
    "Pacific/Pago_Pago": "Pacific/Pago_Pago.ics",
    "Pacific/Pago Pago": "Pacific/Pago_Pago.ics",
    "Pacific/Palau": "Pacific/Palau.ics",
    "Pacific/Pitcairn": "Pacific/Pitcairn.ics",
    "Pacific/Pohnpei": "Pacific/Pohnpei.ics",
    "Pacific/Port_Moresby": "Pacific/Port_Moresby.ics",
    "Pacific/Port Moresby": "Pacific/Port_Moresby.ics",
    "Pacific/Rarotonga": "Pacific/Rarotonga.ics",
    "Pacific/Saipan": "Pacific/Saipan.ics",
    "Pacific/Tahiti": "Pacific/Tahiti.ics",
    "Pacific/Tarawa": "Pacific/Tarawa.ics",
    "Pacific/Tongatapu": "Pacific/Tongatapu.ics",
    "Pacific/Wake": "Pacific/Wake.ics",
    "Pacific/Wallis": "Pacific/Wallis.ics",
    "Venezuela Standard Time": "Venezuela Standard Time.ics",
    "Dateline Standard Time": "Etc/GMT-12.ics",
    "Samoa Standard Time": "Etc/GMT-11.ics",
    "Hawaiian Standard Time": "Etc/GMT-10.ics",
    "Alaskan Standard Time": "Etc/GMT-9.ics",
    "Pacific Standard Time": "Etc/GMT-8.ics",
    "Mountain Standard Time": "Etc/GMT-7.ics",
    "Mexico Standard Time 2": "Etc/GMT-7.ics",
    "US Mountain Standard Time": "Etc/GMT-7.ics",
    "Central Standard Time": "Etc/GMT-6.ics",
    "Canada Central Standard Time": "Etc/GMT-6.ics",
    "Mexico Standard Time": "Etc/GMT-6.ics",
    "Central America Standard Time": "Etc/GMT-6.ics",
    "Eastern Standard Time": "Etc/GMT-5.ics",
    "US Eastern Standard Time": "Etc/GMT-5.ics",
    "SA Pacific Standard Time": "Etc/GMT-5.ics",
    "Atlantic Standard Time": "Etc/GMT-4.ics",
    "SA Western Standard Time": "Etc/GMT-4.ics",
    "Pacific SA Standard Time": "Etc/GMT-4.ics",
    "E South America Standard Time": "Etc/GMT-3.ics",
    "SA Eastern Standard Time": "Etc/GMT-3.ics",
    "Greenland Standard Time": "Etc/GMT-3.ics",
    "Mid-Atlantic Standard Time": "Etc/GMT-2.ics",
    "Azores Standard Time": "Etc/GMT-1.ics",
    "Cape Verde Standard Time": "Etc/GMT-1.ics",
    "GMT Standard Time": "Etc/GMT.ics",
    "Greenwich Standard Time": "Etc/Greenwich.ics",
    "Central Europe Standard Time": "Etc/GMT+1.ics",
    "Central European Standard Time": "Etc/GMT+1.ics",
    "Romance Standard Time": "Etc/GMT+1.ics",
    "W Europe Standard Time": "Etc/GMT+1.ics",
    "W Central Africa Standard Time": "Etc/GMT+1.ics",
    "E Europe Standard Time": "Etc/GMT+2.ics",
    "Egypt Standard Time": "Etc/GMT+2.ics",
    "FLE Standard Time": "Etc/GMT+2.ics",
    "GTB Standard Time": "Etc/GMT+2.ics",
    "Israel Standard Time": "Etc/GMT+2.ics",
    "South Africa Standard Time": "Etc/GMT+2.ics",
    "Russian Standard Time": "Etc/GMT+3.ics",
    "Arab Standard Time": "Etc/GMT+3.ics",
    "E Africa Standard Time": "Etc/GMT+3.ics",
    "Arabic Standard Time": "Etc/GMT+3.ics",
    "Iran Standard Time": "Etc/GMT+4.ics",
    "Arabian Standard Time": "Etc/GMT+4.ics",
    "Caucasus Standard Time": "Etc/GMT+4.ics",
    "Ekaterinburg Standard Time": "Etc/GMT+5.ics",
    "West Asia Standard Time": "Etc/GMT+5.ics",
    "Central Asia Standard Time": "Etc/GMT+6.ics",
    "Sri Lanka Standard Time": "Etc/GMT+6.ics",
    "N Central Asia Standard Time": "Etc/GMT+6.ics",
    "Myanmar Standard Time": "Myanmar Time.ics",
    "SE Asia Standard Time": "Etc/GMT+7.ics",
    "North Asia Standard Time": "Etc/GMT+7.ics",
    "China Standard Time": "Etc/GMT+8.ics",
    "Singapore Standard Time": "Etc/GMT+8.ics",
    "Taipei Standard Time": "Etc/GMT+8.ics",
    "W Australia Standard Time": "Etc/GMT+8.ics",
    "North Asia East Standard Time": "Etc/GMT+8.ics",
    "Korea Standard Time": "Etc/GMT+9.ics",
    "Tokyo Standard Time": "Etc/GMT+9.ics",
    "Yakutsk Standard Time": "Etc/GMT+9.ics",
    "AUS Central Standard Time": "Australian Central Standard Time.ics",
    "Cen Australia Standard Time": "Australian Central Standard Time.ics",
    "AUS Eastern Standard Time": "Etc/GMT+10.ics",
    "E Australia Standard Time": "Etc/GMT+10.ics",
    "Tasmania Standard Time": "Etc/GMT+10.ics",
    "Vladivostok Standard Time": "Etc/GMT+10.ics",
    "West Pacific Standard Time": "Etc/GMT+10.ics",
    "Central Pacific Standard Time": "Etc/GMT+11.ics",
    "Fiji Islands Standard Time": "Etc/GMT+12.ics",
    "New Zealand Standard Time": "Etc/GMT+12.ics",
    "Tonga Standard Time": "Etc/GMT+13.ics",
    "Asia/Calcutta": "Asia/Kolkata.ics",
    "Asia/Katmandu": "Nepal Time.ics",
    "Asia/Rangoon": "Asia/Yangon.ics",
    "America/Buenos Aires": "America/Argentina/Buenos_Aires.ics",
    "Canada/Atlantic": "America/Aruba.ics",
    "Canada/Newfoundland": "Newfoundland Standard Time.ics",
    "Canada/Saskatchewan": "undefined",
    "US/Eastern": "America/New_York.ics",
    "US/Central": "America/Chicago.ics",
    "US/Mountain": "America/Denver.ics",
    "US/Pacific": "America/Los_Angeles.ics",
    "US/Arizona": "America/Phoenix.ics",
    "US/East-Indiana": "America/Halifax.ics",
    "ET": "America/New_York.ics",
    "CT": "America/Chicago.ics",
    "MT": "America/Denver.ics",
    "PT": "America/Los_Angeles.ics",
    "AK": "America/Anchorage.ics",
    "HAST": "Pacific/Honolulu.ics",
    "MST": "America/Phoenix.ics",
    "AST": "America/Aruba.ics",
    "MOST": "Africa/Casablanca.ics",
    "GST": "Africa/Casablanca.ics",
    "WET": "Europe/Amsterdam.ics",
    "CET": "Europe/Belgrade.ics",
    "RST": "Europe/Copenhagen.ics",
    "CEST": "Europe/Sarajevo.ics",
    "ECT": "Africa/Douala.ics",
    "JST": "Europe/Bucharest.ics",
    "GTBST": "Europe/Bucharest.ics",
    "MEST": "Africa/Cairo.ics",
    "EGST": "Africa/Cairo.ics",
    "SST": "Africa/Cairo.ics",
    "SAST": "Africa/Harare.ics",
    "EET": "Europe/Helsinki.ics",
    "ISST": "Asia/Jerusalem.ics",
    "EEST": "Asia/Jerusalem.ics",
    "NMST": "Asia/Jerusalem.ics",
    "ARST": "Asia/Baghdad.ics",
    "ABST": "Asia/Kuwait.ics",
    "MSK": "Europe/Moscow.ics",
    "EAT": "Asia/Kuwait.ics",
    "IRST": "Asia/Tehran.ics",
    "ARBST": "Asia/Muscat.ics",
    "AZT": "Asia/Baku.ics",
    "MUT": "Asia/Baku.ics",
    "GET": "Asia/Baku.ics",
    "AMT": "Asia/Baku.ics",
    "AFT": "Asia/Baku.ics",
    "YEKT": "Asia/Yekaterinburg.ics",
    "PKT": "Asia/Karachi.ics",
    "WAST": "Asia/Yekaterinburg.ics",
    "IST": "Asia/Kolkata.ics",
    "SLT": "Asia/Kolkata.ics",
    "NPT": "Nepal Time.ics",
    "BTT": "Asia/Dhaka.ics",
    "BST": "Asia/Dhaka.ics",
    "NCAST": "Asia/Dhaka.ics",
    "MYST": "Asia/Yangon.ics",
    "THA": "Asia/Yangon.ics",
    "KRAT": "Asia/Yangon.ics",
    "IRKT": "Asia/Irkutsk.ics",
    "SNST": "Asia/Taipei.ics",
    "AWST": "Australia/Perth.ics",
    "TIST": "Asia/Taipei.ics",
    "UST": "Asia/Taipei.ics",
    "TST": "Asia/Tokyo.ics",
    "KST": "Asia/Seoul.ics",
    "YAKT": "Asia/Yakutsk.ics",
    "CAUST": "Australia/Adelaide.ics",
    "ACST": "Australia/Darwin.ics",
    "EAST": "Australia/Brisbane.ics",
    "AEST": "Australia/Sydney.ics",
    "WPST": "Pacific/Guam.ics",
    "TAST": "Australia/Hobart.ics",
    "VLAT": "Asia/Vladivostok.ics",
    "SBT": "Pacific/Guadalcanal.ics",
    "NZST": "Pacific/Auckland.ics",
    "UTC12": "Etc/GMT-12.ics",
    "FJT": "Pacific/Fiji.ics",
    "PETT": "Etc/GMT+12.ics",
    "PHOT": "Pacific/Tongatapu.ics",
    "AZOST": "Atlantic/Azores.ics",
    "CVT": "Atlantic/Cape_Verde.ics",
    "ESAST": "America/Sao_Paulo.ics",
    "ART": "America/Argentina/Buenos_Aires.ics",
    "SAEST": "Etc/GMT-3.ics",
    "GNST": "America/Godthab.ics",
    "MVST": "America/Montevideo.ics",
    "NST": "Newfoundland Standard Time.ics",
    "PRST": "America/Aruba.ics",
    "CBST": "America/Aruba.ics",
    "SAWST": "America/Santiago.ics",
    "PSAST": "America/Santiago.ics",
    "VST": "America/Caracas.ics",
    "SAPST": "America/Bogota.ics",
    "EST": "America/Halifax.ics",
    "CAST": "America/Mexico_City.ics",
    "CST": "America/Mexico_City.ics",
    "CCST": "undefined",
    "MSTM": "America/Mazatlan.ics",
    "PST": "America/Los_Angeles.ics",
    "SMST": "Pacific/Midway.ics",
    "BIT": "Etc/GMT+12.ics"
};
const osType = (()=>{
    const { Deno: Deno1  } = globalThis;
    if (typeof Deno1?.build?.os === "string") {
        return Deno1.build.os;
    }
    const { navigator  } = globalThis;
    if (navigator?.appVersion?.includes?.("Win")) {
        return "windows";
    }
    return "linux";
})();
const isWindows = osType === "windows";
const CHAR_FORWARD_SLASH = 47;
function assertPath(path) {
    if (typeof path !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
    }
}
function isPosixPathSeparator(code) {
    return code === 47;
}
function isPathSeparator(code) {
    return isPosixPathSeparator(code) || code === 92;
}
function isWindowsDeviceRoot(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i = 0, len = path.length; i <= len; ++i){
        if (i < len) code = path.charCodeAt(i);
        else if (isPathSeparator(code)) break;
        else code = CHAR_FORWARD_SLASH;
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (base === sep) return dir;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
const WHITESPACE_ENCODINGS = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS[c] ?? c;
    });
}
function lastPathSegment(path, isSep, start = 0) {
    let matchedNonSeparator = false;
    let end = path.length;
    for(let i = path.length - 1; i >= start; --i){
        if (isSep(path.charCodeAt(i))) {
            if (matchedNonSeparator) {
                start = i + 1;
                break;
            }
        } else if (!matchedNonSeparator) {
            matchedNonSeparator = true;
            end = i + 1;
        }
    }
    return path.slice(start, end);
}
function stripTrailingSeparators(segment, isSep) {
    if (segment.length <= 1) {
        return segment;
    }
    let end = segment.length;
    for(let i = segment.length - 1; i > 0; i--){
        if (isSep(segment.charCodeAt(i))) {
            end = i;
        } else {
            break;
        }
    }
    return segment.slice(0, end);
}
function stripSuffix(name, suffix) {
    if (suffix.length >= name.length) {
        return name;
    }
    const lenDiff = name.length - suffix.length;
    for(let i = suffix.length - 1; i >= 0; --i){
        if (name.charCodeAt(lenDiff + i) !== suffix.charCodeAt(i)) {
            return name;
        }
    }
    return name.slice(0, -suffix.length);
}
class DenoStdInternalError extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError(msg);
    }
}
const sep = "\\";
const delimiter = ";";
function resolve(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1; i--){
        let path;
        const { Deno: Deno1  } = globalThis;
        if (i >= 0) {
            path = pathSegments[i];
        } else if (!resolvedDevice) {
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno1.cwd();
        } else {
            if (typeof Deno1?.env?.get !== "function" || typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator(code)) {
                isAbsolute = true;
                if (isPathSeparator(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            isAbsolute = true;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator(code)) {
        return true;
    } else if (isWindowsDeviceRoot(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i = 0; i < pathsCount; ++i){
        const path = paths[i];
        assertPath(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert(firstPart != null);
    if (isPathSeparator(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize(joined);
}
function relative(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    const fromOrig = resolve(from);
    const toOrig = resolve(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 92) {
                    return toOrig.slice(toStart + i + 1);
                } else if (i === 2) {
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 92) {
                    lastCommonSep = i;
                } else if (i === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i;
    }
    if (i !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function dirname(path) {
    assertPath(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        return path;
    }
    for(let i = len - 1; i >= offset; --i){
        if (isPathSeparator(path.charCodeAt(i))) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return stripTrailingSeparators(path.slice(0, end), isPosixPathSeparator);
}
function basename(path, suffix = "") {
    assertPath(path);
    if (path.length === 0) return path;
    if (typeof suffix !== "string") {
        throw new TypeError(`Suffix must be a string. Received ${JSON.stringify(suffix)}`);
    }
    let start = 0;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    const lastSegment = lastPathSegment(path, isPathSeparator, start);
    const strippedSegment = stripTrailingSeparators(lastSegment, isPathSeparator);
    return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;
}
function extname(path) {
    assertPath(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i = path.length - 1; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("\\", pathObject);
}
function parse(path) {
    assertPath(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator(code)) {
            rootEnd = 1;
            if (isPathSeparator(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            ret.base = "\\";
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator(code)) {
        ret.root = ret.dir = path;
        ret.base = "\\";
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= rootEnd; --i){
        code = path.charCodeAt(i);
        if (isPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    ret.base = ret.base || "\\";
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
function toFileUrl(path) {
    if (!isAbsolute(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod = {
    sep: sep,
    delimiter: delimiter,
    resolve: resolve,
    normalize: normalize,
    isAbsolute: isAbsolute,
    join: join,
    relative: relative,
    toNamespacedPath: toNamespacedPath,
    dirname: dirname,
    basename: basename,
    extname: extname,
    format: format,
    parse: parse,
    fromFileUrl: fromFileUrl,
    toFileUrl: toFileUrl
};
const sep1 = "/";
const delimiter1 = ":";
function resolve1(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) path = pathSegments[i];
        else {
            const { Deno: Deno1  } = globalThis;
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
        }
        assertPath(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = isPosixPathSeparator(path.charCodeAt(0));
    }
    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize1(path) {
    assertPath(path);
    if (path.length === 0) return ".";
    const isAbsolute = isPosixPathSeparator(path.charCodeAt(0));
    const trailingSeparator = isPosixPathSeparator(path.charCodeAt(path.length - 1));
    path = normalizeString(path, !isAbsolute, "/", isPosixPathSeparator);
    if (path.length === 0 && !isAbsolute) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute) return `/${path}`;
    return path;
}
function isAbsolute1(path) {
    assertPath(path);
    return path.length > 0 && isPosixPathSeparator(path.charCodeAt(0));
}
function join1(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        assertPath(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return normalize1(joined);
}
function relative1(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return "";
    from = resolve1(from);
    to = resolve1(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (!isPosixPathSeparator(from.charCodeAt(fromStart))) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (!isPosixPathSeparator(to.charCodeAt(toStart))) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (isPosixPathSeparator(to.charCodeAt(toStart + i))) {
                    return to.slice(toStart + i + 1);
                } else if (i === 0) {
                    return to.slice(toStart + i);
                }
            } else if (fromLen > length) {
                if (isPosixPathSeparator(from.charCodeAt(fromStart + i))) {
                    lastCommonSep = i;
                } else if (i === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (isPosixPathSeparator(fromCode)) lastCommonSep = i;
    }
    let out = "";
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || isPosixPathSeparator(from.charCodeAt(i))) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (isPosixPathSeparator(to.charCodeAt(toStart))) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath1(path) {
    return path;
}
function dirname1(path) {
    if (path.length === 0) return ".";
    let end = -1;
    let matchedNonSeparator = false;
    for(let i = path.length - 1; i >= 1; --i){
        if (isPosixPathSeparator(path.charCodeAt(i))) {
            if (matchedNonSeparator) {
                end = i;
                break;
            }
        } else {
            matchedNonSeparator = true;
        }
    }
    if (end === -1) {
        return isPosixPathSeparator(path.charCodeAt(0)) ? "/" : ".";
    }
    return stripTrailingSeparators(path.slice(0, end), isPosixPathSeparator);
}
function basename1(path, suffix = "") {
    assertPath(path);
    if (path.length === 0) return path;
    if (typeof suffix !== "string") {
        throw new TypeError(`Suffix must be a string. Received ${JSON.stringify(suffix)}`);
    }
    const lastSegment = lastPathSegment(path, isPosixPathSeparator);
    const strippedSegment = stripTrailingSeparators(lastSegment, isPosixPathSeparator);
    return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;
}
function extname1(path) {
    assertPath(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i = path.length - 1; i >= 0; --i){
        const code = path.charCodeAt(i);
        if (isPosixPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format1(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format("/", pathObject);
}
function parse1(path) {
    assertPath(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute = isPosixPathSeparator(path.charCodeAt(0));
    let start;
    if (isAbsolute) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPosixPathSeparator(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
        ret.base = ret.base || "/";
    } else {
        if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) {
        ret.dir = stripTrailingSeparators(path.slice(0, startPart - 1), isPosixPathSeparator);
    } else if (isAbsolute) ret.dir = "/";
    return ret;
}
function fromFileUrl1(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl1(path) {
    if (!isAbsolute1(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod1 = {
    sep: sep1,
    delimiter: delimiter1,
    resolve: resolve1,
    normalize: normalize1,
    isAbsolute: isAbsolute1,
    join: join1,
    relative: relative1,
    toNamespacedPath: toNamespacedPath1,
    dirname: dirname1,
    basename: basename1,
    extname: extname1,
    format: format1,
    parse: parse1,
    fromFileUrl: fromFileUrl1,
    toFileUrl: toFileUrl1
};
const path = isWindows ? mod : mod1;
const { join: join2 , normalize: normalize2  } = path;
const path1 = isWindows ? mod : mod1;
const { basename: basename2 , delimiter: delimiter2 , dirname: dirname2 , extname: extname2 , format: format2 , fromFileUrl: fromFileUrl2 , isAbsolute: isAbsolute2 , join: join3 , normalize: normalize3 , parse: parse2 , relative: relative2 , resolve: resolve2 , toFileUrl: toFileUrl2 , toNamespacedPath: toNamespacedPath2  } = path1;
path1.sep;
const importMeta = {
    url: "file:///Volumes/Data/Nextcloud/Development/Deno/npm/ical-timezones/index.ts",
    main: false
};
new URL("", importMeta.url).pathname;
const __dirname = new URL(".", importMeta.url).pathname;
function getVtimezone(timezone) {
    const zoneFile = zones[timezone];
    if (zoneFile) {
        const tzPath = join3(__dirname, "zones", zoneFile);
        try {
            return Deno.readTextFileSync(tzPath);
        } catch (_e) {
            undefined;
        }
    }
    return null;
}
function extractVTZ(content) {
    return content.slice(content.indexOf("BEGIN:VTIMEZONE"), content.indexOf("END:VCALENDAR"));
}
function getVtimezoneComponent(timezone) {
    const ics = getVtimezone(timezone);
    return ics && extractVTZ(ics);
}
let DenoCore;
const { Deno: Deno1  } = globalThis;
if (Deno1?.[Deno1.internal]?.core) {
    DenoCore = Deno1[Deno1.internal].core;
} else if (Deno1?.core) {
    DenoCore = Deno1.core;
} else {
    DenoCore = {};
}
const core = {
    runMicrotasks: DenoCore.runMicrotasks ?? function() {
        throw new Error("Deno.core.runMicrotasks() is not supported in this environment");
    },
    setHasTickScheduled: DenoCore.setHasTickScheduled ?? function() {
        throw new Error("Deno.core.setHasTickScheduled() is not supported in this environment");
    },
    hasTickScheduled: DenoCore.hasTickScheduled ?? function() {
        throw new Error("Deno.core.hasTickScheduled() is not supported in this environment");
    },
    setNextTickCallback: DenoCore.setNextTickCallback ?? undefined,
    setMacrotaskCallback: DenoCore.setMacrotaskCallback ?? function() {
        throw new Error("Deno.core.setNextTickCallback() is not supported in this environment");
    },
    evalContext: DenoCore.evalContext ?? function(_code, _filename) {
        throw new Error("Deno.core.evalContext is not supported in this environment");
    },
    encode: DenoCore.encode ?? function(chunk) {
        return new TextEncoder().encode(chunk);
    },
    eventLoopHasMoreWork: DenoCore.eventLoopHasMoreWork ?? function() {
        return false;
    },
    isProxy: DenoCore.isProxy ?? function() {
        return false;
    },
    getPromiseDetails: DenoCore.getPromiseDetails ?? function(_promise) {
        throw new Error("Deno.core.getPromiseDetails is not supported in this environment");
    },
    setPromiseHooks: DenoCore.setPromiseHooks ?? function() {
        throw new Error("Deno.core.setPromiseHooks is not supported in this environment");
    },
    ops: DenoCore.ops ?? {
        op_napi_open (_filename) {
            throw new Error("Node API is not supported in this environment");
        }
    }
};
const _toString = Object.prototype.toString;
const _bigIntValueOf = BigInt.prototype.valueOf;
const _booleanValueOf = Boolean.prototype.valueOf;
const _dateValueOf = Date.prototype.valueOf;
const _numberValueOf = Number.prototype.valueOf;
const _stringValueOf = String.prototype.valueOf;
const _symbolValueOf = Symbol.prototype.valueOf;
const _weakMapHas = WeakMap.prototype.has;
const _weakSetHas = WeakSet.prototype.has;
const _getArrayBufferByteLength = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, "byteLength").get;
const _getSharedArrayBufferByteLength = globalThis.SharedArrayBuffer ? Object.getOwnPropertyDescriptor(SharedArrayBuffer.prototype, "byteLength").get : undefined;
const _getTypedArrayToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Uint8Array).prototype, Symbol.toStringTag).get;
const _getSetSize = Object.getOwnPropertyDescriptor(Set.prototype, "size").get;
const _getMapSize = Object.getOwnPropertyDescriptor(Map.prototype, "size").get;
function isObjectLike(value) {
    return value !== null && typeof value === "object";
}
function isAnyArrayBuffer(value) {
    return isArrayBuffer(value) || isSharedArrayBuffer(value);
}
function isArgumentsObject(value) {
    return isObjectLike(value) && value[Symbol.toStringTag] === undefined && _toString.call(value) === "[object Arguments]";
}
function isArrayBuffer(value) {
    try {
        _getArrayBufferByteLength.call(value);
        return true;
    } catch  {
        return false;
    }
}
function isAsyncFunction(value) {
    return typeof value === "function" && value[Symbol.toStringTag] === "AsyncFunction";
}
function isBooleanObject(value) {
    if (!isObjectLike(value)) {
        return false;
    }
    try {
        _booleanValueOf.call(value);
        return true;
    } catch  {
        return false;
    }
}
function isBoxedPrimitive(value) {
    return isBooleanObject(value) || isStringObject(value) || isNumberObject(value) || isSymbolObject(value) || isBigIntObject(value);
}
function isDataView(value) {
    return ArrayBuffer.isView(value) && _getTypedArrayToStringTag.call(value) === undefined;
}
function isDate(value) {
    try {
        _dateValueOf.call(value);
        return true;
    } catch  {
        return false;
    }
}
function isGeneratorFunction(value) {
    return typeof value === "function" && value[Symbol.toStringTag] === "GeneratorFunction";
}
function isGeneratorObject(value) {
    return isObjectLike(value) && value[Symbol.toStringTag] === "Generator";
}
function isMap(value) {
    try {
        _getMapSize.call(value);
        return true;
    } catch  {
        return false;
    }
}
function isMapIterator(value) {
    return isObjectLike(value) && value[Symbol.toStringTag] === "Map Iterator";
}
function isModuleNamespaceObject(value) {
    return isObjectLike(value) && value[Symbol.toStringTag] === "Module";
}
function isNativeError(value) {
    return isObjectLike(value) && value[Symbol.toStringTag] === undefined && _toString.call(value) === "[object Error]";
}
function isNumberObject(value) {
    if (!isObjectLike(value)) {
        return false;
    }
    try {
        _numberValueOf.call(value);
        return true;
    } catch  {
        return false;
    }
}
function isBigIntObject(value) {
    if (!isObjectLike(value)) {
        return false;
    }
    try {
        _bigIntValueOf.call(value);
        return true;
    } catch  {
        return false;
    }
}
function isPromise(value) {
    return isObjectLike(value) && value[Symbol.toStringTag] === "Promise";
}
function isProxy(value) {
    return core.isProxy(value);
}
function isRegExp(value) {
    return isObjectLike(value) && value[Symbol.toStringTag] === undefined && _toString.call(value) === "[object RegExp]";
}
function isSet(value) {
    try {
        _getSetSize.call(value);
        return true;
    } catch  {
        return false;
    }
}
function isSetIterator(value) {
    return isObjectLike(value) && value[Symbol.toStringTag] === "Set Iterator";
}
function isSharedArrayBuffer(value) {
    if (_getSharedArrayBufferByteLength === undefined) {
        return false;
    }
    try {
        _getSharedArrayBufferByteLength.call(value);
        return true;
    } catch  {
        return false;
    }
}
function isStringObject(value) {
    if (!isObjectLike(value)) {
        return false;
    }
    try {
        _stringValueOf.call(value);
        return true;
    } catch  {
        return false;
    }
}
function isSymbolObject(value) {
    if (!isObjectLike(value)) {
        return false;
    }
    try {
        _symbolValueOf.call(value);
        return true;
    } catch  {
        return false;
    }
}
function isWeakMap(value) {
    try {
        _weakMapHas.call(value, null);
        return true;
    } catch  {
        return false;
    }
}
function isWeakSet(value) {
    try {
        _weakSetHas.call(value, null);
        return true;
    } catch  {
        return false;
    }
}
const __default = {
    isAsyncFunction,
    isGeneratorFunction,
    isAnyArrayBuffer,
    isArrayBuffer,
    isArgumentsObject,
    isBoxedPrimitive,
    isDataView,
    isMap,
    isMapIterator,
    isModuleNamespaceObject,
    isNativeError,
    isPromise,
    isSet,
    isSetIterator,
    isWeakMap,
    isWeakSet,
    isRegExp,
    isDate,
    isStringObject,
    isNumberObject,
    isBooleanObject,
    isBigIntObject
};
const mod2 = {
    isAnyArrayBuffer: isAnyArrayBuffer,
    isArgumentsObject: isArgumentsObject,
    isArrayBuffer: isArrayBuffer,
    isAsyncFunction: isAsyncFunction,
    isBooleanObject: isBooleanObject,
    isBoxedPrimitive: isBoxedPrimitive,
    isDataView: isDataView,
    isDate: isDate,
    isGeneratorFunction: isGeneratorFunction,
    isGeneratorObject: isGeneratorObject,
    isMap: isMap,
    isMapIterator: isMapIterator,
    isModuleNamespaceObject: isModuleNamespaceObject,
    isNativeError: isNativeError,
    isNumberObject: isNumberObject,
    isBigIntObject: isBigIntObject,
    isPromise: isPromise,
    isProxy: isProxy,
    isRegExp: isRegExp,
    isSet: isSet,
    isSetIterator: isSetIterator,
    isSharedArrayBuffer: isSharedArrayBuffer,
    isStringObject: isStringObject,
    isSymbolObject: isSymbolObject,
    isWeakMap: isWeakMap,
    isWeakSet: isWeakSet,
    default: __default
};
const kHandle = Symbol("kHandle");
const kKeyObject = Symbol("kKeyObject");
const kKeyType = Symbol("kKeyType");
function isKeyObject(obj) {
    return obj != null && obj[kKeyType] !== undefined;
}
function isCryptoKey(obj) {
    return obj != null && obj[kKeyObject] !== undefined;
}
const _getTypedArrayToStringTag1 = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Uint8Array).prototype, Symbol.toStringTag).get;
function isArrayBufferView(value) {
    return ArrayBuffer.isView(value);
}
function isBigInt64Array(value) {
    return _getTypedArrayToStringTag1.call(value) === "BigInt64Array";
}
function isBigUint64Array(value) {
    return _getTypedArrayToStringTag1.call(value) === "BigUint64Array";
}
function isFloat32Array(value) {
    return _getTypedArrayToStringTag1.call(value) === "Float32Array";
}
function isFloat64Array(value) {
    return _getTypedArrayToStringTag1.call(value) === "Float64Array";
}
function isInt8Array(value) {
    return _getTypedArrayToStringTag1.call(value) === "Int8Array";
}
function isInt16Array(value) {
    return _getTypedArrayToStringTag1.call(value) === "Int16Array";
}
function isInt32Array(value) {
    return _getTypedArrayToStringTag1.call(value) === "Int32Array";
}
function isTypedArray(value) {
    return _getTypedArrayToStringTag1.call(value) !== undefined;
}
function isUint8Array(value) {
    return _getTypedArrayToStringTag1.call(value) === "Uint8Array";
}
function isUint8ClampedArray(value) {
    return _getTypedArrayToStringTag1.call(value) === "Uint8ClampedArray";
}
function isUint16Array(value) {
    return _getTypedArrayToStringTag1.call(value) === "Uint16Array";
}
function isUint32Array(value) {
    return _getTypedArrayToStringTag1.call(value) === "Uint32Array";
}
const { isDate: isDate1 , isArgumentsObject: isArgumentsObject1 , isBigIntObject: isBigIntObject1 , isBooleanObject: isBooleanObject1 , isNumberObject: isNumberObject1 , isStringObject: isStringObject1 , isSymbolObject: isSymbolObject1 , isNativeError: isNativeError1 , isRegExp: isRegExp1 , isAsyncFunction: isAsyncFunction1 , isGeneratorFunction: isGeneratorFunction1 , isGeneratorObject: isGeneratorObject1 , isPromise: isPromise1 , isMap: isMap1 , isSet: isSet1 , isMapIterator: isMapIterator1 , isSetIterator: isSetIterator1 , isWeakMap: isWeakMap1 , isWeakSet: isWeakSet1 , isArrayBuffer: isArrayBuffer1 , isDataView: isDataView1 , isSharedArrayBuffer: isSharedArrayBuffer1 , isProxy: isProxy1 , isModuleNamespaceObject: isModuleNamespaceObject1 , isAnyArrayBuffer: isAnyArrayBuffer1 , isBoxedPrimitive: isBoxedPrimitive1  } = mod2;
const mod3 = {
    isCryptoKey: isCryptoKey,
    isKeyObject: isKeyObject,
    isArrayBufferView: isArrayBufferView,
    isBigInt64Array: isBigInt64Array,
    isBigUint64Array: isBigUint64Array,
    isFloat32Array: isFloat32Array,
    isFloat64Array: isFloat64Array,
    isInt8Array: isInt8Array,
    isInt16Array: isInt16Array,
    isInt32Array: isInt32Array,
    isTypedArray: isTypedArray,
    isUint8Array: isUint8Array,
    isUint8ClampedArray: isUint8ClampedArray,
    isUint16Array: isUint16Array,
    isUint32Array: isUint32Array,
    isDate: isDate1,
    isArgumentsObject: isArgumentsObject1,
    isBigIntObject: isBigIntObject1,
    isBooleanObject: isBooleanObject1,
    isNumberObject: isNumberObject1,
    isStringObject: isStringObject1,
    isSymbolObject: isSymbolObject1,
    isNativeError: isNativeError1,
    isRegExp: isRegExp1,
    isAsyncFunction: isAsyncFunction1,
    isGeneratorFunction: isGeneratorFunction1,
    isGeneratorObject: isGeneratorObject1,
    isPromise: isPromise1,
    isMap: isMap1,
    isSet: isSet1,
    isMapIterator: isMapIterator1,
    isSetIterator: isSetIterator1,
    isWeakMap: isWeakMap1,
    isWeakSet: isWeakSet1,
    isArrayBuffer: isArrayBuffer1,
    isDataView: isDataView1,
    isSharedArrayBuffer: isSharedArrayBuffer1,
    isProxy: isProxy1,
    isModuleNamespaceObject: isModuleNamespaceObject1,
    isAnyArrayBuffer: isAnyArrayBuffer1,
    isBoxedPrimitive: isBoxedPrimitive1
};
const codes = {};
function hideStackFrames(fn) {
    const hidden = "__node_internal_" + fn.name;
    Object.defineProperty(fn, "name", {
        value: hidden
    });
    return fn;
}
function normalizeEncoding(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases(enc);
}
function slowCases(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        case 9:
            if (enc === "base64url" || enc === "BASE64URL" || `${enc}`.toLowerCase() === "base64url") {
                return "base64url";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
function isInt32(value) {
    return value === (value | 0);
}
function isUint32(value) {
    return value === value >>> 0;
}
const octalReg = /^[0-7]+$/;
const modeDesc = "must be a 32-bit unsigned integer or an octal string";
function parseFileMode(value, name, def) {
    value ??= def;
    if (typeof value === "string") {
        if (!octalReg.test(value)) {
            throw new codes.ERR_INVALID_ARG_VALUE(name, value, modeDesc);
        }
        value = Number.parseInt(value, 8);
    }
    validateInt32(value, name, 0, 2 ** 32 - 1);
    return value;
}
const validateBuffer = hideStackFrames((buffer, name = "buffer")=>{
    if (!isArrayBufferView(buffer)) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, [
            "Buffer",
            "TypedArray",
            "DataView"
        ], buffer);
    }
});
const validateInteger = hideStackFrames((value, name, min = Number.MIN_SAFE_INTEGER, max = Number.MAX_SAFE_INTEGER)=>{
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
});
const validateObject = hideStackFrames((value, name, options)=>{
    const useDefaultOptions = options == null;
    const allowArray = useDefaultOptions ? false : options.allowArray;
    const allowFunction = useDefaultOptions ? false : options.allowFunction;
    const nullable = useDefaultOptions ? false : options.nullable;
    if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "Object", value);
    }
});
const validateInt32 = hideStackFrames((value, name, min = -2147483648, max = 2147483647)=>{
    if (!isInt32(value)) {
        if (typeof value !== "number") {
            throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
    if (value < min || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
});
const validateUint32 = hideStackFrames((value, name, positive)=>{
    if (!isUint32(value)) {
        if (typeof value !== "number") {
            throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
        if (!Number.isInteger(value)) {
            throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
        }
        const min = positive ? 1 : 0;
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && < 4294967296`, value);
    }
    if (positive && value === 0) {
        throw new codes.ERR_OUT_OF_RANGE(name, ">= 1 && < 4294967296", value);
    }
});
function validateString(value, name) {
    if (typeof value !== "string") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "string", value);
    }
}
function validateBoolean(value, name) {
    if (typeof value !== "boolean") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "boolean", value);
    }
}
hideStackFrames((value, name, oneOf)=>{
    if (!Array.prototype.includes.call(oneOf, value)) {
        const allowed = Array.prototype.join.call(Array.prototype.map.call(oneOf, (v)=>typeof v === "string" ? `'${v}'` : String(v)), ", ");
        const reason = "must be one of: " + allowed;
        throw new codes.ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});
function validateEncoding(data, encoding) {
    const normalizedEncoding = normalizeEncoding(encoding);
    const length = data.length;
    if (normalizedEncoding === "hex" && length % 2 !== 0) {
        throw new codes.ERR_INVALID_ARG_VALUE("encoding", encoding, `is invalid for data of length ${length}`);
    }
}
const validateAbortSignal = hideStackFrames((signal, name)=>{
    if (signal !== undefined && (signal === null || typeof signal !== "object" || !("aborted" in signal))) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "AbortSignal", signal);
    }
});
const validateFunction = hideStackFrames((value, name)=>{
    if (typeof value !== "function") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "Function", value);
    }
});
hideStackFrames((value, name, minLength = 0)=>{
    if (!Array.isArray(value)) {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "Array", value);
    }
    if (value.length < minLength) {
        const reason = `must be longer than ${minLength}`;
        throw new codes.ERR_INVALID_ARG_VALUE(name, value, reason);
    }
});
class DenoStdInternalError1 extends Error {
    constructor(message){
        super(message);
        this.name = "DenoStdInternalError";
    }
}
function assert1(expr, msg = "") {
    if (!expr) {
        throw new DenoStdInternalError1(msg);
    }
}
function unreachable() {
    throw new DenoStdInternalError1("unreachable");
}
const osType1 = (()=>{
    const { Deno: Deno1  } = globalThis;
    if (typeof Deno1?.build?.os === "string") {
        return Deno1.build.os;
    }
    const { navigator  } = globalThis;
    if (navigator?.appVersion?.includes?.("Win")) {
        return "windows";
    }
    return "linux";
})();
const isWindows1 = osType1 === "windows";
const isLinux = osType1 === "linux";
function uvTranslateSysError(sysErrno) {
    switch(sysErrno){
        case 5:
            return "EACCES";
        case 998:
            return "EACCES";
        case 10013:
            return "EACCES";
        case 1920:
            return "EACCES";
        case 1227:
            return "EADDRINUSE";
        case 10048:
            return "EADDRINUSE";
        case 10049:
            return "EADDRNOTAVAIL";
        case 10047:
            return "EAFNOSUPPORT";
        case 10035:
            return "EAGAIN";
        case 10037:
            return "EALREADY";
        case 1004:
            return "EBADF";
        case 6:
            return "EBADF";
        case 33:
            return "EBUSY";
        case 231:
            return "EBUSY";
        case 32:
            return "EBUSY";
        case 995:
            return "ECANCELED";
        case 10004:
            return "ECANCELED";
        case 1113:
            return "ECHARSET";
        case 1236:
            return "ECONNABORTED";
        case 10053:
            return "ECONNABORTED";
        case 1225:
            return "ECONNREFUSED";
        case 10061:
            return "ECONNREFUSED";
        case 64:
            return "ECONNRESET";
        case 10054:
            return "ECONNRESET";
        case 183:
            return "EEXIST";
        case 80:
            return "EEXIST";
        case 111:
            return "EFAULT";
        case 10014:
            return "EFAULT";
        case 1232:
            return "EHOSTUNREACH";
        case 10065:
            return "EHOSTUNREACH";
        case 122:
            return "EINVAL";
        case 13:
            return "EINVAL";
        case 123:
            return "EINVAL";
        case 87:
            return "EINVAL";
        case 10022:
            return "EINVAL";
        case 10046:
            return "EINVAL";
        case 1102:
            return "EIO";
        case 1111:
            return "EIO";
        case 23:
            return "EIO";
        case 1166:
            return "EIO";
        case 1165:
            return "EIO";
        case 1393:
            return "EIO";
        case 1129:
            return "EIO";
        case 1101:
            return "EIO";
        case 31:
            return "EIO";
        case 1106:
            return "EIO";
        case 1117:
            return "EIO";
        case 1104:
            return "EIO";
        case 205:
            return "EIO";
        case 110:
            return "EIO";
        case 1103:
            return "EIO";
        case 156:
            return "EIO";
        case 10056:
            return "EISCONN";
        case 1921:
            return "ELOOP";
        case 4:
            return "EMFILE";
        case 10024:
            return "EMFILE";
        case 10040:
            return "EMSGSIZE";
        case 206:
            return "ENAMETOOLONG";
        case 1231:
            return "ENETUNREACH";
        case 10051:
            return "ENETUNREACH";
        case 10055:
            return "ENOBUFS";
        case 161:
            return "ENOENT";
        case 267:
            return "ENOTDIR";
        case 203:
            return "ENOENT";
        case 2:
            return "ENOENT";
        case 15:
            return "ENOENT";
        case 4392:
            return "ENOENT";
        case 126:
            return "ENOENT";
        case 3:
            return "ENOENT";
        case 11001:
            return "ENOENT";
        case 11004:
            return "ENOENT";
        case 8:
            return "ENOMEM";
        case 14:
            return "ENOMEM";
        case 82:
            return "ENOSPC";
        case 112:
            return "ENOSPC";
        case 277:
            return "ENOSPC";
        case 1100:
            return "ENOSPC";
        case 39:
            return "ENOSPC";
        case 2250:
            return "ENOTCONN";
        case 10057:
            return "ENOTCONN";
        case 145:
            return "ENOTEMPTY";
        case 10038:
            return "ENOTSOCK";
        case 50:
            return "ENOTSUP";
        case 109:
            return "EOF";
        case 1314:
            return "EPERM";
        case 230:
            return "EPIPE";
        case 232:
            return "EPIPE";
        case 233:
            return "EPIPE";
        case 10058:
            return "EPIPE";
        case 10043:
            return "EPROTONOSUPPORT";
        case 19:
            return "EROFS";
        case 121:
            return "ETIMEDOUT";
        case 10060:
            return "ETIMEDOUT";
        case 17:
            return "EXDEV";
        case 1:
            return "EISDIR";
        case 208:
            return "E2BIG";
        case 10044:
            return "ESOCKTNOSUPPORT";
        default:
            return "UNKNOWN";
    }
}
const codeToErrorWindows = [
    [
        -4093,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -4092,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -4091,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -4090,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -4089,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -4088,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -4084,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -4083,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -4082,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -4081,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -4079,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -4078,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -4077,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -4076,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -4075,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -4074,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -4036,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -4073,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4072,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -4071,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -4070,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -4069,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -4068,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -4067,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -4066,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -4065,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -4064,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -4063,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -4062,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -4061,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -4060,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -4059,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -4058,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -4057,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -4035,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -4055,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -4054,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -4053,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -4052,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -4051,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -4050,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -4049,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -4048,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -4047,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -4046,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -4045,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -4044,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -4034,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -4043,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -4042,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -4041,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -4040,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -4039,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -4038,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -4037,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -4033,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -4032,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -4031,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -4029,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -4027,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ]
];
const errorToCodeWindows = codeToErrorWindows.map(([status, [error]])=>[
        error,
        status
    ]);
const codeToErrorDarwin = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -48,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -49,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -47,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -35,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -37,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -89,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -53,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -61,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -54,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -39,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -65,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -56,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -62,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -40,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -63,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -50,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -51,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -55,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -42,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -78,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -57,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -66,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -38,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -45,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -100,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -43,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -41,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -58,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -60,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -64,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -79,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -92,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ]
];
const errorToCodeDarwin = codeToErrorDarwin.map(([status, [code]])=>[
        code,
        status
    ]);
const codeToErrorLinux = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -98,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -99,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -97,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -11,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -114,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -125,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -103,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -111,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -104,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -89,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -113,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -106,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -40,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -90,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -36,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -100,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -101,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -105,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -64,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -92,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -38,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -107,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -39,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -88,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -95,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -71,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -93,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -91,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -108,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -110,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -112,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -121,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -4028,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -84,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ]
];
const errorToCodeLinux = codeToErrorLinux.map(([status, [code]])=>[
        code,
        status
    ]);
const codeToErrorFreebsd = [
    [
        -7,
        [
            "E2BIG",
            "argument list too long"
        ]
    ],
    [
        -13,
        [
            "EACCES",
            "permission denied"
        ]
    ],
    [
        -48,
        [
            "EADDRINUSE",
            "address already in use"
        ]
    ],
    [
        -49,
        [
            "EADDRNOTAVAIL",
            "address not available"
        ]
    ],
    [
        -47,
        [
            "EAFNOSUPPORT",
            "address family not supported"
        ]
    ],
    [
        -35,
        [
            "EAGAIN",
            "resource temporarily unavailable"
        ]
    ],
    [
        -3000,
        [
            "EAI_ADDRFAMILY",
            "address family not supported"
        ]
    ],
    [
        -3001,
        [
            "EAI_AGAIN",
            "temporary failure"
        ]
    ],
    [
        -3002,
        [
            "EAI_BADFLAGS",
            "bad ai_flags value"
        ]
    ],
    [
        -3013,
        [
            "EAI_BADHINTS",
            "invalid value for hints"
        ]
    ],
    [
        -3003,
        [
            "EAI_CANCELED",
            "request canceled"
        ]
    ],
    [
        -3004,
        [
            "EAI_FAIL",
            "permanent failure"
        ]
    ],
    [
        -3005,
        [
            "EAI_FAMILY",
            "ai_family not supported"
        ]
    ],
    [
        -3006,
        [
            "EAI_MEMORY",
            "out of memory"
        ]
    ],
    [
        -3007,
        [
            "EAI_NODATA",
            "no address"
        ]
    ],
    [
        -3008,
        [
            "EAI_NONAME",
            "unknown node or service"
        ]
    ],
    [
        -3009,
        [
            "EAI_OVERFLOW",
            "argument buffer overflow"
        ]
    ],
    [
        -3014,
        [
            "EAI_PROTOCOL",
            "resolved protocol is unknown"
        ]
    ],
    [
        -3010,
        [
            "EAI_SERVICE",
            "service not available for socket type"
        ]
    ],
    [
        -3011,
        [
            "EAI_SOCKTYPE",
            "socket type not supported"
        ]
    ],
    [
        -37,
        [
            "EALREADY",
            "connection already in progress"
        ]
    ],
    [
        -9,
        [
            "EBADF",
            "bad file descriptor"
        ]
    ],
    [
        -16,
        [
            "EBUSY",
            "resource busy or locked"
        ]
    ],
    [
        -85,
        [
            "ECANCELED",
            "operation canceled"
        ]
    ],
    [
        -4080,
        [
            "ECHARSET",
            "invalid Unicode character"
        ]
    ],
    [
        -53,
        [
            "ECONNABORTED",
            "software caused connection abort"
        ]
    ],
    [
        -61,
        [
            "ECONNREFUSED",
            "connection refused"
        ]
    ],
    [
        -54,
        [
            "ECONNRESET",
            "connection reset by peer"
        ]
    ],
    [
        -39,
        [
            "EDESTADDRREQ",
            "destination address required"
        ]
    ],
    [
        -17,
        [
            "EEXIST",
            "file already exists"
        ]
    ],
    [
        -14,
        [
            "EFAULT",
            "bad address in system call argument"
        ]
    ],
    [
        -27,
        [
            "EFBIG",
            "file too large"
        ]
    ],
    [
        -65,
        [
            "EHOSTUNREACH",
            "host is unreachable"
        ]
    ],
    [
        -4,
        [
            "EINTR",
            "interrupted system call"
        ]
    ],
    [
        -22,
        [
            "EINVAL",
            "invalid argument"
        ]
    ],
    [
        -5,
        [
            "EIO",
            "i/o error"
        ]
    ],
    [
        -56,
        [
            "EISCONN",
            "socket is already connected"
        ]
    ],
    [
        -21,
        [
            "EISDIR",
            "illegal operation on a directory"
        ]
    ],
    [
        -62,
        [
            "ELOOP",
            "too many symbolic links encountered"
        ]
    ],
    [
        -24,
        [
            "EMFILE",
            "too many open files"
        ]
    ],
    [
        -40,
        [
            "EMSGSIZE",
            "message too long"
        ]
    ],
    [
        -63,
        [
            "ENAMETOOLONG",
            "name too long"
        ]
    ],
    [
        -50,
        [
            "ENETDOWN",
            "network is down"
        ]
    ],
    [
        -51,
        [
            "ENETUNREACH",
            "network is unreachable"
        ]
    ],
    [
        -23,
        [
            "ENFILE",
            "file table overflow"
        ]
    ],
    [
        -55,
        [
            "ENOBUFS",
            "no buffer space available"
        ]
    ],
    [
        -19,
        [
            "ENODEV",
            "no such device"
        ]
    ],
    [
        -2,
        [
            "ENOENT",
            "no such file or directory"
        ]
    ],
    [
        -12,
        [
            "ENOMEM",
            "not enough memory"
        ]
    ],
    [
        -4056,
        [
            "ENONET",
            "machine is not on the network"
        ]
    ],
    [
        -42,
        [
            "ENOPROTOOPT",
            "protocol not available"
        ]
    ],
    [
        -28,
        [
            "ENOSPC",
            "no space left on device"
        ]
    ],
    [
        -78,
        [
            "ENOSYS",
            "function not implemented"
        ]
    ],
    [
        -57,
        [
            "ENOTCONN",
            "socket is not connected"
        ]
    ],
    [
        -20,
        [
            "ENOTDIR",
            "not a directory"
        ]
    ],
    [
        -66,
        [
            "ENOTEMPTY",
            "directory not empty"
        ]
    ],
    [
        -38,
        [
            "ENOTSOCK",
            "socket operation on non-socket"
        ]
    ],
    [
        -45,
        [
            "ENOTSUP",
            "operation not supported on socket"
        ]
    ],
    [
        -84,
        [
            "EOVERFLOW",
            "value too large for defined data type"
        ]
    ],
    [
        -1,
        [
            "EPERM",
            "operation not permitted"
        ]
    ],
    [
        -32,
        [
            "EPIPE",
            "broken pipe"
        ]
    ],
    [
        -92,
        [
            "EPROTO",
            "protocol error"
        ]
    ],
    [
        -43,
        [
            "EPROTONOSUPPORT",
            "protocol not supported"
        ]
    ],
    [
        -41,
        [
            "EPROTOTYPE",
            "protocol wrong type for socket"
        ]
    ],
    [
        -34,
        [
            "ERANGE",
            "result too large"
        ]
    ],
    [
        -30,
        [
            "EROFS",
            "read-only file system"
        ]
    ],
    [
        -58,
        [
            "ESHUTDOWN",
            "cannot send after transport endpoint shutdown"
        ]
    ],
    [
        -29,
        [
            "ESPIPE",
            "invalid seek"
        ]
    ],
    [
        -3,
        [
            "ESRCH",
            "no such process"
        ]
    ],
    [
        -60,
        [
            "ETIMEDOUT",
            "connection timed out"
        ]
    ],
    [
        -26,
        [
            "ETXTBSY",
            "text file is busy"
        ]
    ],
    [
        -18,
        [
            "EXDEV",
            "cross-device link not permitted"
        ]
    ],
    [
        -4094,
        [
            "UNKNOWN",
            "unknown error"
        ]
    ],
    [
        -4095,
        [
            "EOF",
            "end of file"
        ]
    ],
    [
        -6,
        [
            "ENXIO",
            "no such device or address"
        ]
    ],
    [
        -31,
        [
            "EMLINK",
            "too many links"
        ]
    ],
    [
        -64,
        [
            "EHOSTDOWN",
            "host is down"
        ]
    ],
    [
        -4030,
        [
            "EREMOTEIO",
            "remote I/O error"
        ]
    ],
    [
        -25,
        [
            "ENOTTY",
            "inappropriate ioctl for device"
        ]
    ],
    [
        -79,
        [
            "EFTYPE",
            "inappropriate file type or format"
        ]
    ],
    [
        -86,
        [
            "EILSEQ",
            "illegal byte sequence"
        ]
    ],
    [
        -44,
        [
            "ESOCKTNOSUPPORT",
            "socket type not supported"
        ]
    ]
];
const errorToCodeFreebsd = codeToErrorFreebsd.map(([status, [code]])=>[
        code,
        status
    ]);
const errorMap = new Map(osType1 === "windows" ? codeToErrorWindows : osType1 === "darwin" ? codeToErrorDarwin : osType1 === "linux" ? codeToErrorLinux : osType1 === "freebsd" ? codeToErrorFreebsd : unreachable());
const codeMap = new Map(osType1 === "windows" ? errorToCodeWindows : osType1 === "darwin" ? errorToCodeDarwin : osType1 === "linux" ? errorToCodeLinux : osType1 === "freebsd" ? errorToCodeFreebsd : unreachable());
function mapSysErrnoToUvErrno(sysErrno) {
    if (osType1 === "windows") {
        const code = uvTranslateSysError(sysErrno);
        return codeMap.get(code) ?? -sysErrno;
    } else {
        return -sysErrno;
    }
}
const UV_EAI_MEMORY = codeMap.get("EAI_MEMORY");
const UV_EBADF = codeMap.get("EBADF");
const UV_EEXIST = codeMap.get("EEXIST");
const UV_EINVAL = codeMap.get("EINVAL");
const UV_ENOENT = codeMap.get("ENOENT");
const UV_ENOTSOCK = codeMap.get("ENOTSOCK");
const UV_UNKNOWN = codeMap.get("UNKNOWN");
const mod4 = {
    errorMap: errorMap,
    codeMap: codeMap,
    mapSysErrnoToUvErrno: mapSysErrnoToUvErrno,
    UV_EAI_MEMORY: UV_EAI_MEMORY,
    UV_EBADF: UV_EBADF,
    UV_EEXIST: UV_EEXIST,
    UV_EINVAL: UV_EINVAL,
    UV_ENOENT: UV_ENOENT,
    UV_ENOTSOCK: UV_ENOTSOCK,
    UV_UNKNOWN: UV_UNKNOWN
};
function notImplemented(msg) {
    const message = msg ? `Not implemented: ${msg}` : "Not implemented";
    throw new Error(message);
}
function warnNotImplemented(msg) {
    const message = msg ? `Warning: Not implemented: ${msg}` : "Warning: Not implemented";
    console.warn(message);
}
TextDecoder;
TextEncoder;
function intoCallbackAPIWithIntercept(func, interceptor, cb, ...args) {
    func(...args).then((value)=>cb && cb(null, interceptor(value)), (err)=>cb && cb(err));
}
function spliceOne(list, index) {
    for(; index + 1 < list.length; index++)list[index] = list[index + 1];
    list.pop();
}
function normalizeEncoding1(enc) {
    if (enc == null || enc === "utf8" || enc === "utf-8") return "utf8";
    return slowCases1(enc);
}
function slowCases1(enc) {
    switch(enc.length){
        case 4:
            if (enc === "UTF8") return "utf8";
            if (enc === "ucs2" || enc === "UCS2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf8") return "utf8";
            if (enc === "ucs2") return "utf16le";
            break;
        case 3:
            if (enc === "hex" || enc === "HEX" || `${enc}`.toLowerCase() === "hex") {
                return "hex";
            }
            break;
        case 5:
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            if (enc === "UTF-8") return "utf8";
            if (enc === "ASCII") return "ascii";
            if (enc === "UCS-2") return "utf16le";
            enc = `${enc}`.toLowerCase();
            if (enc === "utf-8") return "utf8";
            if (enc === "ascii") return "ascii";
            if (enc === "ucs-2") return "utf16le";
            break;
        case 6:
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            if (enc === "BASE64") return "base64";
            if (enc === "LATIN1" || enc === "BINARY") return "latin1";
            enc = `${enc}`.toLowerCase();
            if (enc === "base64") return "base64";
            if (enc === "latin1" || enc === "binary") return "latin1";
            break;
        case 7:
            if (enc === "utf16le" || enc === "UTF16LE" || `${enc}`.toLowerCase() === "utf16le") {
                return "utf16le";
            }
            break;
        case 8:
            if (enc === "utf-16le" || enc === "UTF-16LE" || `${enc}`.toLowerCase() === "utf-16le") {
                return "utf16le";
            }
            break;
        default:
            if (enc === "") return "utf8";
    }
}
const NumberIsSafeInteger = Number.isSafeInteger;
function getSystemErrorName(code) {
    if (typeof code !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE("err", "number", code);
    }
    if (code >= 0 || !NumberIsSafeInteger(code)) {
        throw new codes.ERR_OUT_OF_RANGE("err", "a negative integer", code);
    }
    return errorMap.get(code)?.[0];
}
function guessHandleType(_fd) {
    notImplemented("util.guessHandleType");
}
const isNumericLookup = {};
function isArrayIndex(value) {
    switch(typeof value){
        case "number":
            return value >= 0 && (value | 0) === value;
        case "string":
            {
                const result = isNumericLookup[value];
                if (result !== void 0) {
                    return result;
                }
                const length = value.length;
                if (length === 0) {
                    return isNumericLookup[value] = false;
                }
                let ch = 0;
                let i = 0;
                for(; i < length; ++i){
                    ch = value.charCodeAt(i);
                    if (i === 0 && ch === 0x30 && length > 1 || ch < 0x30 || ch > 0x39) {
                        return isNumericLookup[value] = false;
                    }
                }
                return isNumericLookup[value] = true;
            }
        default:
            return false;
    }
}
function getOwnNonIndexProperties(obj, filter) {
    let allProperties = [
        ...Object.getOwnPropertyNames(obj),
        ...Object.getOwnPropertySymbols(obj)
    ];
    if (Array.isArray(obj)) {
        allProperties = allProperties.filter((k)=>!isArrayIndex(k));
    }
    if (filter === 0) {
        return allProperties;
    }
    const result = [];
    for (const key of allProperties){
        const desc = Object.getOwnPropertyDescriptor(obj, key);
        if (desc === undefined) {
            continue;
        }
        if (filter & 1 && !desc.writable) {
            continue;
        }
        if (filter & 2 && !desc.enumerable) {
            continue;
        }
        if (filter & 4 && !desc.configurable) {
            continue;
        }
        if (filter & 8 && typeof key === "string") {
            continue;
        }
        if (filter & 16 && typeof key === "symbol") {
            continue;
        }
        result.push(key);
    }
    return result;
}
const mod5 = function() {
    return {
        guessHandleType: guessHandleType,
        ALL_PROPERTIES: 0,
        ONLY_WRITABLE: 1,
        ONLY_ENUMERABLE: 2,
        ONLY_CONFIGURABLE: 4,
        ONLY_ENUM_WRITABLE: 6,
        SKIP_STRINGS: 8,
        SKIP_SYMBOLS: 16,
        isArrayIndex: isArrayIndex,
        getOwnNonIndexProperties: getOwnNonIndexProperties
    };
}();
const kObjectType = 0;
const kArrayExtrasType = 2;
const kRejected = 2;
const meta = [
    '\\x00',
    '\\x01',
    '\\x02',
    '\\x03',
    '\\x04',
    '\\x05',
    '\\x06',
    '\\x07',
    '\\b',
    '\\t',
    '\\n',
    '\\x0B',
    '\\f',
    '\\r',
    '\\x0E',
    '\\x0F',
    '\\x10',
    '\\x11',
    '\\x12',
    '\\x13',
    '\\x14',
    '\\x15',
    '\\x16',
    '\\x17',
    '\\x18',
    '\\x19',
    '\\x1A',
    '\\x1B',
    '\\x1C',
    '\\x1D',
    '\\x1E',
    '\\x1F',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    "\\'",
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\\\',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\x7F',
    '\\x80',
    '\\x81',
    '\\x82',
    '\\x83',
    '\\x84',
    '\\x85',
    '\\x86',
    '\\x87',
    '\\x88',
    '\\x89',
    '\\x8A',
    '\\x8B',
    '\\x8C',
    '\\x8D',
    '\\x8E',
    '\\x8F',
    '\\x90',
    '\\x91',
    '\\x92',
    '\\x93',
    '\\x94',
    '\\x95',
    '\\x96',
    '\\x97',
    '\\x98',
    '\\x99',
    '\\x9A',
    '\\x9B',
    '\\x9C',
    '\\x9D',
    '\\x9E',
    '\\x9F'
];
const isUndetectableObject = (v)=>typeof v === "undefined" && v !== undefined;
const strEscapeSequencesRegExp = /[\x00-\x1f\x27\x5c\x7f-\x9f]/;
const strEscapeSequencesReplacer = /[\x00-\x1f\x27\x5c\x7f-\x9f]/g;
const strEscapeSequencesRegExpSingle = /[\x00-\x1f\x5c\x7f-\x9f]/;
const strEscapeSequencesReplacerSingle = /[\x00-\x1f\x5c\x7f-\x9f]/g;
const keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
const numberRegExp = /^(0|[1-9][0-9]*)$/;
const nodeModulesRegExp = /[/\\]node_modules[/\\](.+?)(?=[/\\])/g;
const classRegExp = /^(\s+[^(]*?)\s*{/;
const stripCommentsRegExp = /(\/\/.*?\n)|(\/\*(.|\n)*?\*\/)/g;
const inspectDefaultOptions = {
    showHidden: false,
    depth: 2,
    colors: false,
    customInspect: true,
    showProxy: false,
    maxArrayLength: 100,
    maxStringLength: 10000,
    breakLength: 80,
    compact: 3,
    sorted: false,
    getters: false
};
function getUserOptions(ctx, isCrossContext) {
    const ret = {
        stylize: ctx.stylize,
        showHidden: ctx.showHidden,
        depth: ctx.depth,
        colors: ctx.colors,
        customInspect: ctx.customInspect,
        showProxy: ctx.showProxy,
        maxArrayLength: ctx.maxArrayLength,
        maxStringLength: ctx.maxStringLength,
        breakLength: ctx.breakLength,
        compact: ctx.compact,
        sorted: ctx.sorted,
        getters: ctx.getters,
        ...ctx.userOptions
    };
    if (isCrossContext) {
        Object.setPrototypeOf(ret, null);
        for (const key of Object.keys(ret)){
            if ((typeof ret[key] === "object" || typeof ret[key] === "function") && ret[key] !== null) {
                delete ret[key];
            }
        }
        ret.stylize = Object.setPrototypeOf((value, flavour)=>{
            let stylized;
            try {
                stylized = `${ctx.stylize(value, flavour)}`;
            } catch  {}
            if (typeof stylized !== "string") return value;
            return stylized;
        }, null);
    }
    return ret;
}
function inspect(value, opts) {
    const ctx = {
        budget: {},
        indentationLvl: 0,
        seen: [],
        currentDepth: 0,
        stylize: stylizeNoColor,
        showHidden: inspectDefaultOptions.showHidden,
        depth: inspectDefaultOptions.depth,
        colors: inspectDefaultOptions.colors,
        customInspect: inspectDefaultOptions.customInspect,
        showProxy: inspectDefaultOptions.showProxy,
        maxArrayLength: inspectDefaultOptions.maxArrayLength,
        maxStringLength: inspectDefaultOptions.maxStringLength,
        breakLength: inspectDefaultOptions.breakLength,
        compact: inspectDefaultOptions.compact,
        sorted: inspectDefaultOptions.sorted,
        getters: inspectDefaultOptions.getters
    };
    if (arguments.length > 1) {
        if (arguments.length > 2) {
            if (arguments[2] !== undefined) {
                ctx.depth = arguments[2];
            }
            if (arguments.length > 3 && arguments[3] !== undefined) {
                ctx.colors = arguments[3];
            }
        }
        if (typeof opts === "boolean") {
            ctx.showHidden = opts;
        } else if (opts) {
            const optKeys = Object.keys(opts);
            for(let i = 0; i < optKeys.length; ++i){
                const key = optKeys[i];
                if (inspectDefaultOptions.hasOwnProperty(key) || key === "stylize") {
                    ctx[key] = opts[key];
                } else if (ctx.userOptions === undefined) {
                    ctx.userOptions = opts;
                }
            }
        }
    }
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;
    if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;
    return formatValue(ctx, value, 0);
}
const customInspectSymbol = Symbol.for("nodejs.util.inspect.custom");
inspect.custom = customInspectSymbol;
Object.defineProperty(inspect, "defaultOptions", {
    get () {
        return inspectDefaultOptions;
    },
    set (options) {
        validateObject(options, "options");
        return Object.assign(inspectDefaultOptions, options);
    }
});
const defaultFG = 39;
const defaultBG = 49;
inspect.colors = Object.assign(Object.create(null), {
    reset: [
        0,
        0
    ],
    bold: [
        1,
        22
    ],
    dim: [
        2,
        22
    ],
    italic: [
        3,
        23
    ],
    underline: [
        4,
        24
    ],
    blink: [
        5,
        25
    ],
    inverse: [
        7,
        27
    ],
    hidden: [
        8,
        28
    ],
    strikethrough: [
        9,
        29
    ],
    doubleunderline: [
        21,
        24
    ],
    black: [
        30,
        defaultFG
    ],
    red: [
        31,
        defaultFG
    ],
    green: [
        32,
        defaultFG
    ],
    yellow: [
        33,
        defaultFG
    ],
    blue: [
        34,
        defaultFG
    ],
    magenta: [
        35,
        defaultFG
    ],
    cyan: [
        36,
        defaultFG
    ],
    white: [
        37,
        defaultFG
    ],
    bgBlack: [
        40,
        defaultBG
    ],
    bgRed: [
        41,
        defaultBG
    ],
    bgGreen: [
        42,
        defaultBG
    ],
    bgYellow: [
        43,
        defaultBG
    ],
    bgBlue: [
        44,
        defaultBG
    ],
    bgMagenta: [
        45,
        defaultBG
    ],
    bgCyan: [
        46,
        defaultBG
    ],
    bgWhite: [
        47,
        defaultBG
    ],
    framed: [
        51,
        54
    ],
    overlined: [
        53,
        55
    ],
    gray: [
        90,
        defaultFG
    ],
    redBright: [
        91,
        defaultFG
    ],
    greenBright: [
        92,
        defaultFG
    ],
    yellowBright: [
        93,
        defaultFG
    ],
    blueBright: [
        94,
        defaultFG
    ],
    magentaBright: [
        95,
        defaultFG
    ],
    cyanBright: [
        96,
        defaultFG
    ],
    whiteBright: [
        97,
        defaultFG
    ],
    bgGray: [
        100,
        defaultBG
    ],
    bgRedBright: [
        101,
        defaultBG
    ],
    bgGreenBright: [
        102,
        defaultBG
    ],
    bgYellowBright: [
        103,
        defaultBG
    ],
    bgBlueBright: [
        104,
        defaultBG
    ],
    bgMagentaBright: [
        105,
        defaultBG
    ],
    bgCyanBright: [
        106,
        defaultBG
    ],
    bgWhiteBright: [
        107,
        defaultBG
    ]
});
function defineColorAlias(target, alias) {
    Object.defineProperty(inspect.colors, alias, {
        get () {
            return this[target];
        },
        set (value) {
            this[target] = value;
        },
        configurable: true,
        enumerable: false
    });
}
defineColorAlias("gray", "grey");
defineColorAlias("gray", "blackBright");
defineColorAlias("bgGray", "bgGrey");
defineColorAlias("bgGray", "bgBlackBright");
defineColorAlias("dim", "faint");
defineColorAlias("strikethrough", "crossedout");
defineColorAlias("strikethrough", "strikeThrough");
defineColorAlias("strikethrough", "crossedOut");
defineColorAlias("hidden", "conceal");
defineColorAlias("inverse", "swapColors");
defineColorAlias("inverse", "swapcolors");
defineColorAlias("doubleunderline", "doubleUnderline");
inspect.styles = Object.assign(Object.create(null), {
    special: "cyan",
    number: "yellow",
    bigint: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    symbol: "green",
    date: "magenta",
    regexp: "red",
    module: "underline"
});
function addQuotes(str, quotes) {
    if (quotes === -1) {
        return `"${str}"`;
    }
    if (quotes === -2) {
        return `\`${str}\``;
    }
    return `'${str}'`;
}
const escapeFn = (str)=>meta[str.charCodeAt(0)];
function strEscape(str) {
    let escapeTest = strEscapeSequencesRegExp;
    let escapeReplace = strEscapeSequencesReplacer;
    let singleQuote = 39;
    if (str.includes("'")) {
        if (!str.includes('"')) {
            singleQuote = -1;
        } else if (!str.includes("`") && !str.includes("${")) {
            singleQuote = -2;
        }
        if (singleQuote !== 39) {
            escapeTest = strEscapeSequencesRegExpSingle;
            escapeReplace = strEscapeSequencesReplacerSingle;
        }
    }
    if (str.length < 5000 && !escapeTest.test(str)) {
        return addQuotes(str, singleQuote);
    }
    if (str.length > 100) {
        str = str.replace(escapeReplace, escapeFn);
        return addQuotes(str, singleQuote);
    }
    let result = "";
    let last = 0;
    const lastIndex = str.length;
    for(let i = 0; i < lastIndex; i++){
        const point = str.charCodeAt(i);
        if (point === singleQuote || point === 92 || point < 32 || point > 126 && point < 160) {
            if (last === i) {
                result += meta[point];
            } else {
                result += `${str.slice(last, i)}${meta[point]}`;
            }
            last = i + 1;
        }
    }
    if (last !== lastIndex) {
        result += str.slice(last);
    }
    return addQuotes(result, singleQuote);
}
function stylizeWithColor(str, styleType) {
    const style = inspect.styles[styleType];
    if (style !== undefined) {
        const color = inspect.colors[style];
        if (color !== undefined) {
            return `\u001b[${color[0]}m${str}\u001b[${color[1]}m`;
        }
    }
    return str;
}
function stylizeNoColor(str) {
    return str;
}
function formatValue(ctx, value, recurseTimes, typedArray) {
    if (typeof value !== "object" && typeof value !== "function" && !isUndetectableObject(value)) {
        return formatPrimitive(ctx.stylize, value, ctx);
    }
    if (value === null) {
        return ctx.stylize("null", "null");
    }
    const context = value;
    const proxy = undefined;
    if (ctx.customInspect) {
        const maybeCustom = value[customInspectSymbol];
        if (typeof maybeCustom === "function" && maybeCustom !== inspect && !(value.constructor && value.constructor.prototype === value)) {
            const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;
            const isCrossContext = proxy !== undefined || !(context instanceof Object);
            const ret = maybeCustom.call(context, depth, getUserOptions(ctx, isCrossContext));
            if (ret !== context) {
                if (typeof ret !== "string") {
                    return formatValue(ctx, ret, recurseTimes);
                }
                return ret.replace(/\n/g, `\n${" ".repeat(ctx.indentationLvl)}`);
            }
        }
    }
    if (ctx.seen.includes(value)) {
        let index = 1;
        if (ctx.circular === undefined) {
            ctx.circular = new Map();
            ctx.circular.set(value, index);
        } else {
            index = ctx.circular.get(value);
            if (index === undefined) {
                index = ctx.circular.size + 1;
                ctx.circular.set(value, index);
            }
        }
        return ctx.stylize(`[Circular *${index}]`, "special");
    }
    return formatRaw(ctx, value, recurseTimes, typedArray);
}
function formatRaw(ctx, value, recurseTimes, typedArray) {
    let keys;
    let protoProps;
    if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {
        protoProps = [];
    }
    const constructor = getConstructorName(value, ctx, recurseTimes, protoProps);
    if (protoProps !== undefined && protoProps.length === 0) {
        protoProps = undefined;
    }
    let tag = value[Symbol.toStringTag];
    if (typeof tag !== "string") {
        tag = "";
    }
    let base = "";
    let formatter = getEmptyFormatArray;
    let braces;
    let noIterator = true;
    let i = 0;
    const filter = ctx.showHidden ? 0 : 2;
    let extrasType = 0;
    if (value[Symbol.iterator] || constructor === null) {
        noIterator = false;
        if (Array.isArray(value)) {
            const prefix = constructor !== "Array" || tag !== "" ? getPrefix(constructor, tag, "Array", `(${value.length})`) : "";
            keys = getOwnNonIndexProperties(value, filter);
            braces = [
                `${prefix}[`,
                "]"
            ];
            if (value.length === 0 && keys.length === 0 && protoProps === undefined) {
                return `${braces[0]}]`;
            }
            extrasType = kArrayExtrasType;
            formatter = formatArray;
        } else if (isSet1(value)) {
            const size = value.size;
            const prefix = getPrefix(constructor, tag, "Set", `(${size})`);
            keys = getKeys(value, ctx.showHidden);
            formatter = constructor !== null ? formatSet.bind(null, value) : formatSet.bind(null, value.values());
            if (size === 0 && keys.length === 0 && protoProps === undefined) {
                return `${prefix}{}`;
            }
            braces = [
                `${prefix}{`,
                "}"
            ];
        } else if (isMap1(value)) {
            const size = value.size;
            const prefix = getPrefix(constructor, tag, "Map", `(${size})`);
            keys = getKeys(value, ctx.showHidden);
            formatter = constructor !== null ? formatMap.bind(null, value) : formatMap.bind(null, value.entries());
            if (size === 0 && keys.length === 0 && protoProps === undefined) {
                return `${prefix}{}`;
            }
            braces = [
                `${prefix}{`,
                "}"
            ];
        } else if (isTypedArray(value)) {
            keys = getOwnNonIndexProperties(value, filter);
            const bound = value;
            const fallback = "";
            if (constructor === null) {}
            const size = value.length;
            const prefix = getPrefix(constructor, tag, fallback, `(${size})`);
            braces = [
                `${prefix}[`,
                "]"
            ];
            if (value.length === 0 && keys.length === 0 && !ctx.showHidden) {
                return `${braces[0]}]`;
            }
            formatter = formatTypedArray.bind(null, bound, size);
            extrasType = kArrayExtrasType;
        } else if (isMapIterator1(value)) {
            keys = getKeys(value, ctx.showHidden);
            braces = getIteratorBraces("Map", tag);
            formatter = formatIterator.bind(null, braces);
        } else if (isSetIterator1(value)) {
            keys = getKeys(value, ctx.showHidden);
            braces = getIteratorBraces("Set", tag);
            formatter = formatIterator.bind(null, braces);
        } else {
            noIterator = true;
        }
    }
    if (noIterator) {
        keys = getKeys(value, ctx.showHidden);
        braces = [
            "{",
            "}"
        ];
        if (constructor === "Object") {
            if (isArgumentsObject1(value)) {
                braces[0] = "[Arguments] {";
            } else if (tag !== "") {
                braces[0] = `${getPrefix(constructor, tag, "Object")}{`;
            }
            if (keys.length === 0 && protoProps === undefined) {
                return `${braces[0]}}`;
            }
        } else if (typeof value === "function") {
            base = getFunctionBase(value, constructor, tag);
            if (keys.length === 0 && protoProps === undefined) {
                return ctx.stylize(base, "special");
            }
        } else if (isRegExp1(value)) {
            base = RegExp(constructor !== null ? value : new RegExp(value)).toString();
            const prefix = getPrefix(constructor, tag, "RegExp");
            if (prefix !== "RegExp ") {
                base = `${prefix}${base}`;
            }
            if (keys.length === 0 && protoProps === undefined || recurseTimes > ctx.depth && ctx.depth !== null) {
                return ctx.stylize(base, "regexp");
            }
        } else if (isDate1(value)) {
            base = Number.isNaN(value.getTime()) ? value.toString() : value.toISOString();
            const prefix = getPrefix(constructor, tag, "Date");
            if (prefix !== "Date ") {
                base = `${prefix}${base}`;
            }
            if (keys.length === 0 && protoProps === undefined) {
                return ctx.stylize(base, "date");
            }
        } else if (value instanceof Error) {
            base = formatError(value, constructor, tag, ctx, keys);
            if (keys.length === 0 && protoProps === undefined) {
                return base;
            }
        } else if (isAnyArrayBuffer1(value)) {
            const arrayType = isArrayBuffer1(value) ? "ArrayBuffer" : "SharedArrayBuffer";
            const prefix = getPrefix(constructor, tag, arrayType);
            if (typedArray === undefined) {
                formatter = formatArrayBuffer;
            } else if (keys.length === 0 && protoProps === undefined) {
                return prefix + `{ byteLength: ${formatNumber(ctx.stylize, value.byteLength)} }`;
            }
            braces[0] = `${prefix}{`;
            Array.prototype.unshift.call(keys, "byteLength");
        } else if (isDataView1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "DataView")}{`;
            Array.prototype.unshift.call(keys, "byteLength", "byteOffset", "buffer");
        } else if (isPromise1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "Promise")}{`;
            formatter = formatPromise;
        } else if (isWeakSet1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "WeakSet")}{`;
            formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;
        } else if (isWeakMap1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "WeakMap")}{`;
            formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;
        } else if (isModuleNamespaceObject1(value)) {
            braces[0] = `${getPrefix(constructor, tag, "Module")}{`;
            formatter = formatNamespaceObject.bind(null, keys);
        } else if (isBoxedPrimitive1(value)) {
            base = getBoxedBase(value, ctx, keys, constructor, tag);
            if (keys.length === 0 && protoProps === undefined) {
                return base;
            }
        } else {
            if (keys.length === 0 && protoProps === undefined) {
                return `${getCtxStyle(value, constructor, tag)}{}`;
            }
            braces[0] = `${getCtxStyle(value, constructor, tag)}{`;
        }
    }
    if (recurseTimes > ctx.depth && ctx.depth !== null) {
        let constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);
        if (constructor !== null) {
            constructorName = `[${constructorName}]`;
        }
        return ctx.stylize(constructorName, "special");
    }
    recurseTimes += 1;
    ctx.seen.push(value);
    ctx.currentDepth = recurseTimes;
    let output;
    const indentationLvl = ctx.indentationLvl;
    try {
        output = formatter(ctx, value, recurseTimes);
        for(i = 0; i < keys.length; i++){
            output.push(formatProperty(ctx, value, recurseTimes, keys[i], extrasType));
        }
        if (protoProps !== undefined) {
            output.push(...protoProps);
        }
    } catch (err) {
        const constructorName = getCtxStyle(value, constructor, tag).slice(0, -1);
        return handleMaxCallStackSize(ctx, err, constructorName, indentationLvl);
    }
    if (ctx.circular !== undefined) {
        const index = ctx.circular.get(value);
        if (index !== undefined) {
            const reference = ctx.stylize(`<ref *${index}>`, "special");
            if (ctx.compact !== true) {
                base = base === "" ? reference : `${reference} ${base}`;
            } else {
                braces[0] = `${reference} ${braces[0]}`;
            }
        }
    }
    ctx.seen.pop();
    if (ctx.sorted) {
        const comparator = ctx.sorted === true ? undefined : ctx.sorted;
        if (extrasType === 0) {
            output = output.sort(comparator);
        } else if (keys.length > 1) {
            const sorted = output.slice(output.length - keys.length).sort(comparator);
            output.splice(output.length - keys.length, keys.length, ...sorted);
        }
    }
    const res = reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value);
    const budget = ctx.budget[ctx.indentationLvl] || 0;
    const newLength = budget + res.length;
    ctx.budget[ctx.indentationLvl] = newLength;
    if (newLength > 2 ** 27) {
        ctx.depth = -1;
    }
    return res;
}
const builtInObjects = new Set(Object.getOwnPropertyNames(globalThis).filter((e)=>/^[A-Z][a-zA-Z0-9]+$/.test(e)));
function addPrototypeProperties(ctx, main, obj, recurseTimes, output) {
    let depth = 0;
    let keys;
    let keySet;
    do {
        if (depth !== 0 || main === obj) {
            obj = Object.getPrototypeOf(obj);
            if (obj === null) {
                return;
            }
            const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
            if (descriptor !== undefined && typeof descriptor.value === "function" && builtInObjects.has(descriptor.value.name)) {
                return;
            }
        }
        if (depth === 0) {
            keySet = new Set();
        } else {
            Array.prototype.forEach.call(keys, (key)=>keySet.add(key));
        }
        keys = Reflect.ownKeys(obj);
        Array.prototype.push.call(ctx.seen, main);
        for (const key of keys){
            if (key === "constructor" || main.hasOwnProperty(key) || depth !== 0 && keySet.has(key)) {
                continue;
            }
            const desc = Object.getOwnPropertyDescriptor(obj, key);
            if (typeof desc.value === "function") {
                continue;
            }
            const value = formatProperty(ctx, obj, recurseTimes, key, 0, desc, main);
            if (ctx.colors) {
                Array.prototype.push.call(output, `\u001b[2m${value}\u001b[22m`);
            } else {
                Array.prototype.push.call(output, value);
            }
        }
        Array.prototype.pop.call(ctx.seen);
    }while (++depth !== 3)
}
function getConstructorName(obj, ctx, recurseTimes, protoProps) {
    let firstProto;
    const tmp = obj;
    while(obj || isUndetectableObject(obj)){
        const descriptor = Object.getOwnPropertyDescriptor(obj, "constructor");
        if (descriptor !== undefined && typeof descriptor.value === "function" && descriptor.value.name !== "" && isInstanceof(tmp, descriptor.value)) {
            if (protoProps !== undefined && (firstProto !== obj || !builtInObjects.has(descriptor.value.name))) {
                addPrototypeProperties(ctx, tmp, firstProto || tmp, recurseTimes, protoProps);
            }
            return descriptor.value.name;
        }
        obj = Object.getPrototypeOf(obj);
        if (firstProto === undefined) {
            firstProto = obj;
        }
    }
    if (firstProto === null) {
        return null;
    }
    const res = undefined;
    if (recurseTimes > ctx.depth && ctx.depth !== null) {
        return `${res} <Complex prototype>`;
    }
    const protoConstr = getConstructorName(firstProto, ctx, recurseTimes + 1, protoProps);
    if (protoConstr === null) {
        return `${res} <${inspect(firstProto, {
            ...ctx,
            customInspect: false,
            depth: -1
        })}>`;
    }
    return `${res} <${protoConstr}>`;
}
function formatPrimitive(fn, value, ctx) {
    if (typeof value === "string") {
        let trailer = "";
        if (value.length > ctx.maxStringLength) {
            const remaining = value.length - ctx.maxStringLength;
            value = value.slice(0, ctx.maxStringLength);
            trailer = `... ${remaining} more character${remaining > 1 ? "s" : ""}`;
        }
        if (ctx.compact !== true && value.length > 16 && value.length > ctx.breakLength - ctx.indentationLvl - 4) {
            return value.split(/(?<=\n)/).map((line)=>fn(strEscape(line), "string")).join(` +\n${" ".repeat(ctx.indentationLvl + 2)}`) + trailer;
        }
        return fn(strEscape(value), "string") + trailer;
    }
    if (typeof value === "number") {
        return formatNumber(fn, value);
    }
    if (typeof value === "bigint") {
        return formatBigInt(fn, value);
    }
    if (typeof value === "boolean") {
        return fn(`${value}`, "boolean");
    }
    if (typeof value === "undefined") {
        return fn("undefined", "undefined");
    }
    return fn(value.toString(), "symbol");
}
function getEmptyFormatArray() {
    return [];
}
function isInstanceof(object, proto) {
    try {
        return object instanceof proto;
    } catch  {
        return false;
    }
}
function getPrefix(constructor, tag, fallback, size = "") {
    if (constructor === null) {
        if (tag !== "" && fallback !== tag) {
            return `[${fallback}${size}: null prototype] [${tag}] `;
        }
        return `[${fallback}${size}: null prototype] `;
    }
    if (tag !== "" && constructor !== tag) {
        return `${constructor}${size} [${tag}] `;
    }
    return `${constructor}${size} `;
}
function formatArray(ctx, value, recurseTimes) {
    const valLen = value.length;
    const len = Math.min(Math.max(0, ctx.maxArrayLength), valLen);
    const remaining = valLen - len;
    const output = [];
    for(let i = 0; i < len; i++){
        if (!value.hasOwnProperty(i)) {
            return formatSpecialArray(ctx, value, recurseTimes, len, output, i);
        }
        output.push(formatProperty(ctx, value, recurseTimes, i, 1));
    }
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function getCtxStyle(_value, constructor, tag) {
    let fallback = "";
    if (constructor === null) {
        if (fallback === tag) {
            fallback = "Object";
        }
    }
    return getPrefix(constructor, tag, fallback);
}
function getKeys(value, showHidden) {
    let keys;
    const symbols = Object.getOwnPropertySymbols(value);
    if (showHidden) {
        keys = Object.getOwnPropertyNames(value);
        if (symbols.length !== 0) {
            Array.prototype.push.apply(keys, symbols);
        }
    } else {
        try {
            keys = Object.keys(value);
        } catch (_err) {
            keys = Object.getOwnPropertyNames(value);
        }
        if (symbols.length !== 0) {}
    }
    return keys;
}
function formatSet(value, ctx, _ignored, recurseTimes) {
    const output = [];
    ctx.indentationLvl += 2;
    for (const v of value){
        Array.prototype.push.call(output, formatValue(ctx, v, recurseTimes));
    }
    ctx.indentationLvl -= 2;
    return output;
}
function formatMap(value, ctx, _gnored, recurseTimes) {
    const output = [];
    ctx.indentationLvl += 2;
    for (const { 0: k , 1: v  } of value){
        output.push(`${formatValue(ctx, k, recurseTimes)} => ${formatValue(ctx, v, recurseTimes)}`);
    }
    ctx.indentationLvl -= 2;
    return output;
}
function formatTypedArray(value, length, ctx, _ignored, recurseTimes) {
    const maxLength = Math.min(Math.max(0, ctx.maxArrayLength), length);
    const remaining = value.length - maxLength;
    const output = new Array(maxLength);
    const elementFormatter = value.length > 0 && typeof value[0] === "number" ? formatNumber : formatBigInt;
    for(let i = 0; i < maxLength; ++i){
        output[i] = elementFormatter(ctx.stylize, value[i]);
    }
    if (remaining > 0) {
        output[maxLength] = `... ${remaining} more item${remaining > 1 ? "s" : ""}`;
    }
    if (ctx.showHidden) {
        ctx.indentationLvl += 2;
        for (const key of [
            "BYTES_PER_ELEMENT",
            "length",
            "byteLength",
            "byteOffset",
            "buffer"
        ]){
            const str = formatValue(ctx, value[key], recurseTimes, true);
            Array.prototype.push.call(output, `[${key}]: ${str}`);
        }
        ctx.indentationLvl -= 2;
    }
    return output;
}
function getIteratorBraces(type, tag) {
    if (tag !== `${type} Iterator`) {
        if (tag !== "") {
            tag += "] [";
        }
        tag += `${type} Iterator`;
    }
    return [
        `[${tag}] {`,
        "}"
    ];
}
function formatIterator(braces, ctx, value, recurseTimes) {
    const { 0: entries , 1: isKeyValue  } = value;
    if (isKeyValue) {
        braces[0] = braces[0].replace(/ Iterator] {$/, " Entries] {");
        return formatMapIterInner(ctx, recurseTimes, entries, 2);
    }
    return formatSetIterInner(ctx, recurseTimes, entries, 1);
}
function getFunctionBase(value, constructor, tag) {
    const stringified = Function.prototype.toString.call(value);
    if (stringified.slice(0, 5) === "class" && stringified.endsWith("}")) {
        const slice = stringified.slice(5, -1);
        const bracketIndex = slice.indexOf("{");
        if (bracketIndex !== -1 && (!slice.slice(0, bracketIndex).includes("(") || classRegExp.test(slice.replace(stripCommentsRegExp)))) {
            return getClassBase(value, constructor, tag);
        }
    }
    let type = "Function";
    if (isGeneratorFunction1(value)) {
        type = `Generator${type}`;
    }
    if (isAsyncFunction1(value)) {
        type = `Async${type}`;
    }
    let base = `[${type}`;
    if (constructor === null) {
        base += " (null prototype)";
    }
    if (value.name === "") {
        base += " (anonymous)";
    } else {
        base += `: ${value.name}`;
    }
    base += "]";
    if (constructor !== type && constructor !== null) {
        base += ` ${constructor}`;
    }
    if (tag !== "" && constructor !== tag) {
        base += ` [${tag}]`;
    }
    return base;
}
function formatError(err, constructor, tag, ctx, keys) {
    const name = err.name != null ? String(err.name) : "Error";
    let len = name.length;
    let stack = err.stack ? String(err.stack) : err.toString();
    if (!ctx.showHidden && keys.length !== 0) {
        for (const name of [
            "name",
            "message",
            "stack"
        ]){
            const index = keys.indexOf(name);
            if (index !== -1 && stack.includes(err[name])) {
                keys.splice(index, 1);
            }
        }
    }
    if (constructor === null || name.endsWith("Error") && stack.startsWith(name) && (stack.length === len || stack[len] === ":" || stack[len] === "\n")) {
        let fallback = "Error";
        if (constructor === null) {
            const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\]()-]+)(?::|\n {4}at)/) || stack.match(/^([a-z_A-Z0-9-]*Error)$/);
            fallback = start && start[1] || "";
            len = fallback.length;
            fallback = fallback || "Error";
        }
        const prefix = getPrefix(constructor, tag, fallback).slice(0, -1);
        if (name !== prefix) {
            if (prefix.includes(name)) {
                if (len === 0) {
                    stack = `${prefix}: ${stack}`;
                } else {
                    stack = `${prefix}${stack.slice(len)}`;
                }
            } else {
                stack = `${prefix} [${name}]${stack.slice(len)}`;
            }
        }
    }
    let pos = err.message && stack.indexOf(err.message) || -1;
    if (pos !== -1) {
        pos += err.message.length;
    }
    const stackStart = stack.indexOf("\n    at", pos);
    if (stackStart === -1) {
        stack = `[${stack}]`;
    } else if (ctx.colors) {
        let newStack = stack.slice(0, stackStart);
        const lines = stack.slice(stackStart + 1).split("\n");
        for (const line of lines){
            let nodeModule;
            newStack += "\n";
            let pos = 0;
            while(nodeModule = nodeModulesRegExp.exec(line)){
                newStack += line.slice(pos, nodeModule.index + 14);
                newStack += ctx.stylize(nodeModule[1], "module");
                pos = nodeModule.index + nodeModule[0].length;
            }
            newStack += pos === 0 ? line : line.slice(pos);
        }
        stack = newStack;
    }
    if (ctx.indentationLvl !== 0) {
        const indentation = " ".repeat(ctx.indentationLvl);
        stack = stack.replace(/\n/g, `\n${indentation}`);
    }
    return stack;
}
let hexSlice;
function formatArrayBuffer(ctx, value) {
    let buffer;
    try {
        buffer = new Uint8Array(value);
    } catch  {
        return [
            ctx.stylize("(detached)", "special")
        ];
    }
    let str = hexSlice(buffer, 0, Math.min(ctx.maxArrayLength, buffer.length)).replace(/(.{2})/g, "$1 ").trim();
    const remaining = buffer.length - ctx.maxArrayLength;
    if (remaining > 0) {
        str += ` ... ${remaining} more byte${remaining > 1 ? "s" : ""}`;
    }
    return [
        `${ctx.stylize("[Uint8Contents]", "special")}: <${str}>`
    ];
}
function formatNumber(fn, value) {
    return fn(Object.is(value, -0) ? "-0" : `${value}`, "number");
}
function formatPromise(ctx, value, recurseTimes) {
    let output;
    const { 0: state , 1: result  } = value;
    if (state === 0) {
        output = [
            ctx.stylize("<pending>", "special")
        ];
    } else {
        ctx.indentationLvl += 2;
        const str = formatValue(ctx, result, recurseTimes);
        ctx.indentationLvl -= 2;
        output = [
            state === kRejected ? `${ctx.stylize("<rejected>", "special")} ${str}` : str
        ];
    }
    return output;
}
function formatWeakCollection(ctx) {
    return [
        ctx.stylize("<items unknown>", "special")
    ];
}
function formatWeakSet(ctx, value, recurseTimes) {
    const entries = value;
    return formatSetIterInner(ctx, recurseTimes, entries, 0);
}
function formatWeakMap(ctx, value, recurseTimes) {
    const entries = value;
    return formatMapIterInner(ctx, recurseTimes, entries, 0);
}
function formatProperty(ctx, value, recurseTimes, key, type, desc, original = value) {
    let name, str;
    let extra = " ";
    desc = desc || Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key],
        enumerable: true
    };
    if (desc.value !== undefined) {
        const diff = ctx.compact !== true || type !== 0 ? 2 : 3;
        ctx.indentationLvl += diff;
        str = formatValue(ctx, desc.value, recurseTimes);
        if (diff === 3 && ctx.breakLength < getStringWidth(str, ctx.colors)) {
            extra = `\n${" ".repeat(ctx.indentationLvl)}`;
        }
        ctx.indentationLvl -= diff;
    } else if (desc.get !== undefined) {
        const label = desc.set !== undefined ? "Getter/Setter" : "Getter";
        const s = ctx.stylize;
        const sp = "special";
        if (ctx.getters && (ctx.getters === true || ctx.getters === "get" && desc.set === undefined || ctx.getters === "set" && desc.set !== undefined)) {
            try {
                const tmp = desc.get.call(original);
                ctx.indentationLvl += 2;
                if (tmp === null) {
                    str = `${s(`[${label}:`, sp)} ${s("null", "null")}${s("]", sp)}`;
                } else if (typeof tmp === "object") {
                    str = `${s(`[${label}]`, sp)} ${formatValue(ctx, tmp, recurseTimes)}`;
                } else {
                    const primitive = formatPrimitive(s, tmp, ctx);
                    str = `${s(`[${label}:`, sp)} ${primitive}${s("]", sp)}`;
                }
                ctx.indentationLvl -= 2;
            } catch (err) {
                const message = `<Inspection threw (${err.message})>`;
                str = `${s(`[${label}:`, sp)} ${message}${s("]", sp)}`;
            }
        } else {
            str = ctx.stylize(`[${label}]`, sp);
        }
    } else if (desc.set !== undefined) {
        str = ctx.stylize("[Setter]", "special");
    } else {
        str = ctx.stylize("undefined", "undefined");
    }
    if (type === 1) {
        return str;
    }
    if (typeof key === "symbol") {
        const tmp = key.toString().replace(strEscapeSequencesReplacer, escapeFn);
        name = `[${ctx.stylize(tmp, "symbol")}]`;
    } else if (key === "__proto__") {
        name = "['__proto__']";
    } else if (desc.enumerable === false) {
        const tmp = key.replace(strEscapeSequencesReplacer, escapeFn);
        name = `[${tmp}]`;
    } else if (keyStrRegExp.test(key)) {
        name = ctx.stylize(key, "name");
    } else {
        name = ctx.stylize(strEscape(key), "string");
    }
    return `${name}:${extra}${str}`;
}
function handleMaxCallStackSize(_ctx, _err, _constructorName, _indentationLvl) {}
const colorRegExp = /\u001b\[\d\d?m/g;
function removeColors(str) {
    return str.replace(colorRegExp, "");
}
function isBelowBreakLength(ctx, output, start, base) {
    let totalLength = output.length + start;
    if (totalLength + output.length > ctx.breakLength) {
        return false;
    }
    for(let i = 0; i < output.length; i++){
        if (ctx.colors) {
            totalLength += removeColors(output[i]).length;
        } else {
            totalLength += output[i].length;
        }
        if (totalLength > ctx.breakLength) {
            return false;
        }
    }
    return base === "" || !base.includes("\n");
}
function formatBigInt(fn, value) {
    return fn(`${value}n`, "bigint");
}
function formatNamespaceObject(keys, ctx, value, recurseTimes) {
    const output = new Array(keys.length);
    for(let i = 0; i < keys.length; i++){
        try {
            output[i] = formatProperty(ctx, value, recurseTimes, keys[i], kObjectType);
        } catch (_err) {
            const tmp = {
                [keys[i]]: ""
            };
            output[i] = formatProperty(ctx, tmp, recurseTimes, keys[i], kObjectType);
            const pos = output[i].lastIndexOf(" ");
            output[i] = output[i].slice(0, pos + 1) + ctx.stylize("<uninitialized>", "special");
        }
    }
    keys.length = 0;
    return output;
}
function formatSpecialArray(ctx, value, recurseTimes, maxLength, output, i) {
    const keys = Object.keys(value);
    let index = i;
    for(; i < keys.length && output.length < maxLength; i++){
        const key = keys[i];
        const tmp = +key;
        if (tmp > 2 ** 32 - 2) {
            break;
        }
        if (`${index}` !== key) {
            if (!numberRegExp.test(key)) {
                break;
            }
            const emptyItems = tmp - index;
            const ending = emptyItems > 1 ? "s" : "";
            const message = `<${emptyItems} empty item${ending}>`;
            output.push(ctx.stylize(message, "undefined"));
            index = tmp;
            if (output.length === maxLength) {
                break;
            }
        }
        output.push(formatProperty(ctx, value, recurseTimes, key, 1));
        index++;
    }
    const remaining = value.length - index;
    if (output.length !== maxLength) {
        if (remaining > 0) {
            const ending = remaining > 1 ? "s" : "";
            const message = `<${remaining} empty item${ending}>`;
            output.push(ctx.stylize(message, "undefined"));
        }
    } else if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function getBoxedBase(value, ctx, keys, constructor, tag) {
    let type;
    if (isNumberObject1(value)) {
        type = "Number";
    } else if (isStringObject1(value)) {
        type = "String";
        keys.splice(0, value.length);
    } else if (isBooleanObject1(value)) {
        type = "Boolean";
    } else if (isBigIntObject1(value)) {
        type = "BigInt";
    } else {
        type = "Symbol";
    }
    let base = `[${type}`;
    if (type !== constructor) {
        if (constructor === null) {
            base += " (null prototype)";
        } else {
            base += ` (${constructor})`;
        }
    }
    base += `: ${formatPrimitive(stylizeNoColor, value.valueOf(), ctx)}]`;
    if (tag !== "" && tag !== constructor) {
        base += ` [${tag}]`;
    }
    if (keys.length !== 0 || ctx.stylize === stylizeNoColor) {
        return base;
    }
    return ctx.stylize(base, type.toLowerCase());
}
function getClassBase(value, constructor, tag) {
    const hasName = value.hasOwnProperty("name");
    const name = hasName && value.name || "(anonymous)";
    let base = `class ${name}`;
    if (constructor !== "Function" && constructor !== null) {
        base += ` [${constructor}]`;
    }
    if (tag !== "" && constructor !== tag) {
        base += ` [${tag}]`;
    }
    if (constructor !== null) {
        const superName = Object.getPrototypeOf(value).name;
        if (superName) {
            base += ` extends ${superName}`;
        }
    } else {
        base += " extends [null prototype]";
    }
    return `[${base}]`;
}
function reduceToSingleString(ctx, output, base, braces, extrasType, recurseTimes, value) {
    if (ctx.compact !== true) {
        if (typeof ctx.compact === "number" && ctx.compact >= 1) {
            const entries = output.length;
            if (extrasType === 2 && entries > 6) {
                output = groupArrayElements(ctx, output, value);
            }
            if (ctx.currentDepth - recurseTimes < ctx.compact && entries === output.length) {
                const start = output.length + ctx.indentationLvl + braces[0].length + base.length + 10;
                if (isBelowBreakLength(ctx, output, start, base)) {
                    return `${base ? `${base} ` : ""}${braces[0]} ${join4(output, ", ")}` + ` ${braces[1]}`;
                }
            }
        }
        const indentation = `\n${" ".repeat(ctx.indentationLvl)}`;
        return `${base ? `${base} ` : ""}${braces[0]}${indentation}  ` + `${join4(output, `,${indentation}  `)}${indentation}${braces[1]}`;
    }
    if (isBelowBreakLength(ctx, output, 0, base)) {
        return `${braces[0]}${base ? ` ${base}` : ""} ${join4(output, ", ")} ` + braces[1];
    }
    const indentation = " ".repeat(ctx.indentationLvl);
    const ln = base === "" && braces[0].length === 1 ? " " : `${base ? ` ${base}` : ""}\n${indentation}  `;
    return `${braces[0]}${ln}${join4(output, `,\n${indentation}  `)} ${braces[1]}`;
}
function join4(output, separator) {
    let str = "";
    if (output.length !== 0) {
        const lastIndex = output.length - 1;
        for(let i = 0; i < lastIndex; i++){
            str += output[i];
            str += separator;
        }
        str += output[lastIndex];
    }
    return str;
}
function groupArrayElements(ctx, output, value) {
    let totalLength = 0;
    let maxLength = 0;
    let i = 0;
    let outputLength = output.length;
    if (ctx.maxArrayLength < output.length) {
        outputLength--;
    }
    const separatorSpace = 2;
    const dataLen = new Array(outputLength);
    for(; i < outputLength; i++){
        const len = getStringWidth(output[i], ctx.colors);
        dataLen[i] = len;
        totalLength += len + separatorSpace;
        if (maxLength < len) {
            maxLength = len;
        }
    }
    const actualMax = maxLength + 2;
    if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength && (totalLength / actualMax > 5 || maxLength <= 6)) {
        const averageBias = Math.sqrt(actualMax - totalLength / output.length);
        const biasedMax = Math.max(actualMax - 3 - averageBias, 1);
        const columns = Math.min(Math.round(Math.sqrt(2.5 * biasedMax * outputLength) / biasedMax), Math.floor((ctx.breakLength - ctx.indentationLvl) / actualMax), ctx.compact * 4, 15);
        if (columns <= 1) {
            return output;
        }
        const tmp = [];
        const maxLineLength = [];
        for(let i = 0; i < columns; i++){
            let lineMaxLength = 0;
            for(let j = i; j < output.length; j += columns){
                if (dataLen[j] > lineMaxLength) {
                    lineMaxLength = dataLen[j];
                }
            }
            lineMaxLength += separatorSpace;
            maxLineLength[i] = lineMaxLength;
        }
        let order = String.prototype.padStart;
        if (value !== undefined) {
            for(let i = 0; i < output.length; i++){
                if (typeof value[i] !== "number" && typeof value[i] !== "bigint") {
                    order = String.prototype.padEnd;
                    break;
                }
            }
        }
        for(let i = 0; i < outputLength; i += columns){
            const max = Math.min(i + columns, outputLength);
            let str = "";
            let j = i;
            for(; j < max - 1; j++){
                const padding = maxLineLength[j - i] + output[j].length - dataLen[j];
                str += `${output[j]}, `.padStart(padding, " ");
            }
            if (order === String.prototype.padStart) {
                const padding = maxLineLength[j - i] + output[j].length - dataLen[j] - 2;
                str += output[j].padStart(padding, " ");
            } else {
                str += output[j];
            }
            Array.prototype.push.call(tmp, str);
        }
        if (ctx.maxArrayLength < output.length) {
            Array.prototype.push.call(tmp, output[outputLength]);
        }
        output = tmp;
    }
    return output;
}
function formatMapIterInner(ctx, recurseTimes, entries, state) {
    const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
    const len = entries.length / 2;
    const remaining = len - maxArrayLength;
    const maxLength = Math.min(maxArrayLength, len);
    let output = new Array(maxLength);
    let i = 0;
    ctx.indentationLvl += 2;
    if (state === 0) {
        for(; i < maxLength; i++){
            const pos = i * 2;
            output[i] = `${formatValue(ctx, entries[pos], recurseTimes)} => ${formatValue(ctx, entries[pos + 1], recurseTimes)}`;
        }
        if (!ctx.sorted) {
            output = output.sort();
        }
    } else {
        for(; i < maxLength; i++){
            const pos = i * 2;
            const res = [
                formatValue(ctx, entries[pos], recurseTimes),
                formatValue(ctx, entries[pos + 1], recurseTimes)
            ];
            output[i] = reduceToSingleString(ctx, res, "", [
                "[",
                "]"
            ], kArrayExtrasType, recurseTimes);
        }
    }
    ctx.indentationLvl -= 2;
    if (remaining > 0) {
        output.push(`... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
function formatSetIterInner(ctx, recurseTimes, entries, state) {
    const maxArrayLength = Math.max(ctx.maxArrayLength, 0);
    const maxLength = Math.min(maxArrayLength, entries.length);
    const output = new Array(maxLength);
    ctx.indentationLvl += 2;
    for(let i = 0; i < maxLength; i++){
        output[i] = formatValue(ctx, entries[i], recurseTimes);
    }
    ctx.indentationLvl -= 2;
    if (state === 0 && !ctx.sorted) {
        output.sort();
    }
    const remaining = entries.length - maxLength;
    if (remaining > 0) {
        Array.prototype.push.call(output, `... ${remaining} more item${remaining > 1 ? "s" : ""}`);
    }
    return output;
}
const ansiPattern = "[\\u001B\\u009B][[\\]()#;?]*" + "(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*" + "|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)" + "|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))";
const ansi = new RegExp(ansiPattern, "g");
function getStringWidth(str, removeControlChars = true) {
    let width = 0;
    if (removeControlChars) {
        str = stripVTControlCharacters(str);
    }
    str = str.normalize("NFC");
    for (const __char of str[Symbol.iterator]()){
        const code = __char.codePointAt(0);
        if (isFullWidthCodePoint(code)) {
            width += 2;
        } else if (!isZeroWidthCodePoint(code)) {
            width++;
        }
    }
    return width;
}
const isFullWidthCodePoint = (code)=>{
    return code >= 0x1100 && (code <= 0x115f || code === 0x2329 || code === 0x232a || code >= 0x2e80 && code <= 0x3247 && code !== 0x303f || code >= 0x3250 && code <= 0x4dbf || code >= 0x4e00 && code <= 0xa4c6 || code >= 0xa960 && code <= 0xa97c || code >= 0xac00 && code <= 0xd7a3 || code >= 0xf900 && code <= 0xfaff || code >= 0xfe10 && code <= 0xfe19 || code >= 0xfe30 && code <= 0xfe6b || code >= 0xff01 && code <= 0xff60 || code >= 0xffe0 && code <= 0xffe6 || code >= 0x1b000 && code <= 0x1b001 || code >= 0x1f200 && code <= 0x1f251 || code >= 0x1f300 && code <= 0x1f64f || code >= 0x20000 && code <= 0x3fffd);
};
const isZeroWidthCodePoint = (code)=>{
    return code <= 0x1F || code >= 0x7F && code <= 0x9F || code >= 0x300 && code <= 0x36F || code >= 0x200B && code <= 0x200F || code >= 0x20D0 && code <= 0x20FF || code >= 0xFE00 && code <= 0xFE0F || code >= 0xFE20 && code <= 0xFE2F || code >= 0xE0100 && code <= 0xE01EF;
};
function stripVTControlCharacters(str) {
    validateString(str, "str");
    return str.replace(ansi, "");
}
let os;
if (Deno.build.os === "darwin") {
    os = {
        UV_UDP_REUSEADDR: 4,
        dlopen: {
            RTLD_LAZY: 1,
            RTLD_NOW: 2,
            RTLD_GLOBAL: 8,
            RTLD_LOCAL: 4
        },
        errno: {
            E2BIG: 7,
            EACCES: 13,
            EADDRINUSE: 48,
            EADDRNOTAVAIL: 49,
            EAFNOSUPPORT: 47,
            EAGAIN: 35,
            EALREADY: 37,
            EBADF: 9,
            EBADMSG: 94,
            EBUSY: 16,
            ECANCELED: 89,
            ECHILD: 10,
            ECONNABORTED: 53,
            ECONNREFUSED: 61,
            ECONNRESET: 54,
            EDEADLK: 11,
            EDESTADDRREQ: 39,
            EDOM: 33,
            EDQUOT: 69,
            EEXIST: 17,
            EFAULT: 14,
            EFBIG: 27,
            EHOSTUNREACH: 65,
            EIDRM: 90,
            EILSEQ: 92,
            EINPROGRESS: 36,
            EINTR: 4,
            EINVAL: 22,
            EIO: 5,
            EISCONN: 56,
            EISDIR: 21,
            ELOOP: 62,
            EMFILE: 24,
            EMLINK: 31,
            EMSGSIZE: 40,
            EMULTIHOP: 95,
            ENAMETOOLONG: 63,
            ENETDOWN: 50,
            ENETRESET: 52,
            ENETUNREACH: 51,
            ENFILE: 23,
            ENOBUFS: 55,
            ENODATA: 96,
            ENODEV: 19,
            ENOENT: 2,
            ENOEXEC: 8,
            ENOLCK: 77,
            ENOLINK: 97,
            ENOMEM: 12,
            ENOMSG: 91,
            ENOPROTOOPT: 42,
            ENOSPC: 28,
            ENOSR: 98,
            ENOSTR: 99,
            ENOSYS: 78,
            ENOTCONN: 57,
            ENOTDIR: 20,
            ENOTEMPTY: 66,
            ENOTSOCK: 38,
            ENOTSUP: 45,
            ENOTTY: 25,
            ENXIO: 6,
            EOPNOTSUPP: 102,
            EOVERFLOW: 84,
            EPERM: 1,
            EPIPE: 32,
            EPROTO: 100,
            EPROTONOSUPPORT: 43,
            EPROTOTYPE: 41,
            ERANGE: 34,
            EROFS: 30,
            ESPIPE: 29,
            ESRCH: 3,
            ESTALE: 70,
            ETIME: 101,
            ETIMEDOUT: 60,
            ETXTBSY: 26,
            EWOULDBLOCK: 35,
            EXDEV: 18
        },
        signals: {
            SIGHUP: 1,
            SIGINT: 2,
            SIGQUIT: 3,
            SIGILL: 4,
            SIGTRAP: 5,
            SIGABRT: 6,
            SIGIOT: 6,
            SIGBUS: 10,
            SIGFPE: 8,
            SIGKILL: 9,
            SIGUSR1: 30,
            SIGSEGV: 11,
            SIGUSR2: 31,
            SIGPIPE: 13,
            SIGALRM: 14,
            SIGTERM: 15,
            SIGCHLD: 20,
            SIGCONT: 19,
            SIGSTOP: 17,
            SIGTSTP: 18,
            SIGTTIN: 21,
            SIGTTOU: 22,
            SIGURG: 16,
            SIGXCPU: 24,
            SIGXFSZ: 25,
            SIGVTALRM: 26,
            SIGPROF: 27,
            SIGWINCH: 28,
            SIGIO: 23,
            SIGINFO: 29,
            SIGSYS: 12
        },
        priority: {
            PRIORITY_LOW: 19,
            PRIORITY_BELOW_NORMAL: 10,
            PRIORITY_NORMAL: 0,
            PRIORITY_ABOVE_NORMAL: -7,
            PRIORITY_HIGH: -14,
            PRIORITY_HIGHEST: -20
        }
    };
} else if (Deno.build.os === "linux") {
    os = {
        UV_UDP_REUSEADDR: 4,
        dlopen: {
            RTLD_LAZY: 1,
            RTLD_NOW: 2,
            RTLD_GLOBAL: 256,
            RTLD_LOCAL: 0,
            RTLD_DEEPBIND: 8
        },
        errno: {
            E2BIG: 7,
            EACCES: 13,
            EADDRINUSE: 98,
            EADDRNOTAVAIL: 99,
            EAFNOSUPPORT: 97,
            EAGAIN: 11,
            EALREADY: 114,
            EBADF: 9,
            EBADMSG: 74,
            EBUSY: 16,
            ECANCELED: 125,
            ECHILD: 10,
            ECONNABORTED: 103,
            ECONNREFUSED: 111,
            ECONNRESET: 104,
            EDEADLK: 35,
            EDESTADDRREQ: 89,
            EDOM: 33,
            EDQUOT: 122,
            EEXIST: 17,
            EFAULT: 14,
            EFBIG: 27,
            EHOSTUNREACH: 113,
            EIDRM: 43,
            EILSEQ: 84,
            EINPROGRESS: 115,
            EINTR: 4,
            EINVAL: 22,
            EIO: 5,
            EISCONN: 106,
            EISDIR: 21,
            ELOOP: 40,
            EMFILE: 24,
            EMLINK: 31,
            EMSGSIZE: 90,
            EMULTIHOP: 72,
            ENAMETOOLONG: 36,
            ENETDOWN: 100,
            ENETRESET: 102,
            ENETUNREACH: 101,
            ENFILE: 23,
            ENOBUFS: 105,
            ENODATA: 61,
            ENODEV: 19,
            ENOENT: 2,
            ENOEXEC: 8,
            ENOLCK: 37,
            ENOLINK: 67,
            ENOMEM: 12,
            ENOMSG: 42,
            ENOPROTOOPT: 92,
            ENOSPC: 28,
            ENOSR: 63,
            ENOSTR: 60,
            ENOSYS: 38,
            ENOTCONN: 107,
            ENOTDIR: 20,
            ENOTEMPTY: 39,
            ENOTSOCK: 88,
            ENOTSUP: 95,
            ENOTTY: 25,
            ENXIO: 6,
            EOPNOTSUPP: 95,
            EOVERFLOW: 75,
            EPERM: 1,
            EPIPE: 32,
            EPROTO: 71,
            EPROTONOSUPPORT: 93,
            EPROTOTYPE: 91,
            ERANGE: 34,
            EROFS: 30,
            ESPIPE: 29,
            ESRCH: 3,
            ESTALE: 116,
            ETIME: 62,
            ETIMEDOUT: 110,
            ETXTBSY: 26,
            EWOULDBLOCK: 11,
            EXDEV: 18
        },
        signals: {
            SIGHUP: 1,
            SIGINT: 2,
            SIGQUIT: 3,
            SIGILL: 4,
            SIGTRAP: 5,
            SIGABRT: 6,
            SIGIOT: 6,
            SIGBUS: 7,
            SIGFPE: 8,
            SIGKILL: 9,
            SIGUSR1: 10,
            SIGSEGV: 11,
            SIGUSR2: 12,
            SIGPIPE: 13,
            SIGALRM: 14,
            SIGTERM: 15,
            SIGCHLD: 17,
            SIGSTKFLT: 16,
            SIGCONT: 18,
            SIGSTOP: 19,
            SIGTSTP: 20,
            SIGTTIN: 21,
            SIGTTOU: 22,
            SIGURG: 23,
            SIGXCPU: 24,
            SIGXFSZ: 25,
            SIGVTALRM: 26,
            SIGPROF: 27,
            SIGWINCH: 28,
            SIGIO: 29,
            SIGPOLL: 29,
            SIGPWR: 30,
            SIGSYS: 31,
            SIGUNUSED: 31
        },
        priority: {
            PRIORITY_LOW: 19,
            PRIORITY_BELOW_NORMAL: 10,
            PRIORITY_NORMAL: 0,
            PRIORITY_ABOVE_NORMAL: -7,
            PRIORITY_HIGH: -14,
            PRIORITY_HIGHEST: -20
        }
    };
} else {
    os = {
        UV_UDP_REUSEADDR: 4,
        dlopen: {},
        errno: {
            E2BIG: 7,
            EACCES: 13,
            EADDRINUSE: 100,
            EADDRNOTAVAIL: 101,
            EAFNOSUPPORT: 102,
            EAGAIN: 11,
            EALREADY: 103,
            EBADF: 9,
            EBADMSG: 104,
            EBUSY: 16,
            ECANCELED: 105,
            ECHILD: 10,
            ECONNABORTED: 106,
            ECONNREFUSED: 107,
            ECONNRESET: 108,
            EDEADLK: 36,
            EDESTADDRREQ: 109,
            EDOM: 33,
            EEXIST: 17,
            EFAULT: 14,
            EFBIG: 27,
            EHOSTUNREACH: 110,
            EIDRM: 111,
            EILSEQ: 42,
            EINPROGRESS: 112,
            EINTR: 4,
            EINVAL: 22,
            EIO: 5,
            EISCONN: 113,
            EISDIR: 21,
            ELOOP: 114,
            EMFILE: 24,
            EMLINK: 31,
            EMSGSIZE: 115,
            ENAMETOOLONG: 38,
            ENETDOWN: 116,
            ENETRESET: 117,
            ENETUNREACH: 118,
            ENFILE: 23,
            ENOBUFS: 119,
            ENODATA: 120,
            ENODEV: 19,
            ENOENT: 2,
            ENOEXEC: 8,
            ENOLCK: 39,
            ENOLINK: 121,
            ENOMEM: 12,
            ENOMSG: 122,
            ENOPROTOOPT: 123,
            ENOSPC: 28,
            ENOSR: 124,
            ENOSTR: 125,
            ENOSYS: 40,
            ENOTCONN: 126,
            ENOTDIR: 20,
            ENOTEMPTY: 41,
            ENOTSOCK: 128,
            ENOTSUP: 129,
            ENOTTY: 25,
            ENXIO: 6,
            EOPNOTSUPP: 130,
            EOVERFLOW: 132,
            EPERM: 1,
            EPIPE: 32,
            EPROTO: 134,
            EPROTONOSUPPORT: 135,
            EPROTOTYPE: 136,
            ERANGE: 34,
            EROFS: 30,
            ESPIPE: 29,
            ESRCH: 3,
            ETIME: 137,
            ETIMEDOUT: 138,
            ETXTBSY: 139,
            EWOULDBLOCK: 140,
            EXDEV: 18,
            WSAEINTR: 10004,
            WSAEBADF: 10009,
            WSAEACCES: 10013,
            WSAEFAULT: 10014,
            WSAEINVAL: 10022,
            WSAEMFILE: 10024,
            WSAEWOULDBLOCK: 10035,
            WSAEINPROGRESS: 10036,
            WSAEALREADY: 10037,
            WSAENOTSOCK: 10038,
            WSAEDESTADDRREQ: 10039,
            WSAEMSGSIZE: 10040,
            WSAEPROTOTYPE: 10041,
            WSAENOPROTOOPT: 10042,
            WSAEPROTONOSUPPORT: 10043,
            WSAESOCKTNOSUPPORT: 10044,
            WSAEOPNOTSUPP: 10045,
            WSAEPFNOSUPPORT: 10046,
            WSAEAFNOSUPPORT: 10047,
            WSAEADDRINUSE: 10048,
            WSAEADDRNOTAVAIL: 10049,
            WSAENETDOWN: 10050,
            WSAENETUNREACH: 10051,
            WSAENETRESET: 10052,
            WSAECONNABORTED: 10053,
            WSAECONNRESET: 10054,
            WSAENOBUFS: 10055,
            WSAEISCONN: 10056,
            WSAENOTCONN: 10057,
            WSAESHUTDOWN: 10058,
            WSAETOOMANYREFS: 10059,
            WSAETIMEDOUT: 10060,
            WSAECONNREFUSED: 10061,
            WSAELOOP: 10062,
            WSAENAMETOOLONG: 10063,
            WSAEHOSTDOWN: 10064,
            WSAEHOSTUNREACH: 10065,
            WSAENOTEMPTY: 10066,
            WSAEPROCLIM: 10067,
            WSAEUSERS: 10068,
            WSAEDQUOT: 10069,
            WSAESTALE: 10070,
            WSAEREMOTE: 10071,
            WSASYSNOTREADY: 10091,
            WSAVERNOTSUPPORTED: 10092,
            WSANOTINITIALISED: 10093,
            WSAEDISCON: 10101,
            WSAENOMORE: 10102,
            WSAECANCELLED: 10103,
            WSAEINVALIDPROCTABLE: 10104,
            WSAEINVALIDPROVIDER: 10105,
            WSAEPROVIDERFAILEDINIT: 10106,
            WSASYSCALLFAILURE: 10107,
            WSASERVICE_NOT_FOUND: 10108,
            WSATYPE_NOT_FOUND: 10109,
            WSA_E_NO_MORE: 10110,
            WSA_E_CANCELLED: 10111,
            WSAEREFUSED: 10112
        },
        signals: {
            SIGHUP: 1,
            SIGINT: 2,
            SIGILL: 4,
            SIGABRT: 22,
            SIGFPE: 8,
            SIGKILL: 9,
            SIGSEGV: 11,
            SIGTERM: 15,
            SIGBREAK: 21,
            SIGWINCH: 28
        },
        priority: {
            PRIORITY_LOW: 19,
            PRIORITY_BELOW_NORMAL: 10,
            PRIORITY_NORMAL: 0,
            PRIORITY_ABOVE_NORMAL: -7,
            PRIORITY_HIGH: -14,
            PRIORITY_HIGHEST: -20
        }
    };
}
const fs = {
    UV_FS_SYMLINK_DIR: 1,
    UV_FS_SYMLINK_JUNCTION: 2,
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    UV_DIRENT_UNKNOWN: 0,
    UV_DIRENT_FILE: 1,
    UV_DIRENT_DIR: 2,
    UV_DIRENT_LINK: 3,
    UV_DIRENT_FIFO: 4,
    UV_DIRENT_SOCKET: 5,
    UV_DIRENT_CHAR: 6,
    UV_DIRENT_BLOCK: 7,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 512,
    O_EXCL: 2048,
    UV_FS_O_FILEMAP: 0,
    O_NOCTTY: 131072,
    O_TRUNC: 1024,
    O_APPEND: 8,
    O_DIRECTORY: 1048576,
    O_NOFOLLOW: 256,
    O_SYNC: 128,
    O_DSYNC: 4194304,
    O_SYMLINK: 2097152,
    O_NONBLOCK: 4,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_COPYFILE_EXCL: 1,
    COPYFILE_EXCL: 1,
    UV_FS_COPYFILE_FICLONE: 2,
    COPYFILE_FICLONE: 2,
    UV_FS_COPYFILE_FICLONE_FORCE: 4,
    COPYFILE_FICLONE_FORCE: 4
};
const crypto1 = {
    OPENSSL_VERSION_NUMBER: 269488319,
    SSL_OP_ALL: 2147485780,
    SSL_OP_ALLOW_NO_DHE_KEX: 1024,
    SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: 262144,
    SSL_OP_CIPHER_SERVER_PREFERENCE: 4194304,
    SSL_OP_CISCO_ANYCONNECT: 32768,
    SSL_OP_COOKIE_EXCHANGE: 8192,
    SSL_OP_CRYPTOPRO_TLSEXT_BUG: 2147483648,
    SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: 2048,
    SSL_OP_EPHEMERAL_RSA: 0,
    SSL_OP_LEGACY_SERVER_CONNECT: 4,
    SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: 0,
    SSL_OP_MICROSOFT_SESS_ID_BUG: 0,
    SSL_OP_MSIE_SSLV2_RSA_PADDING: 0,
    SSL_OP_NETSCAPE_CA_DN_BUG: 0,
    SSL_OP_NETSCAPE_CHALLENGE_BUG: 0,
    SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: 0,
    SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: 0,
    SSL_OP_NO_COMPRESSION: 131072,
    SSL_OP_NO_ENCRYPT_THEN_MAC: 524288,
    SSL_OP_NO_QUERY_MTU: 4096,
    SSL_OP_NO_RENEGOTIATION: 1073741824,
    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: 65536,
    SSL_OP_NO_SSLv2: 0,
    SSL_OP_NO_SSLv3: 33554432,
    SSL_OP_NO_TICKET: 16384,
    SSL_OP_NO_TLSv1: 67108864,
    SSL_OP_NO_TLSv1_1: 268435456,
    SSL_OP_NO_TLSv1_2: 134217728,
    SSL_OP_NO_TLSv1_3: 536870912,
    SSL_OP_PKCS1_CHECK_1: 0,
    SSL_OP_PKCS1_CHECK_2: 0,
    SSL_OP_PRIORITIZE_CHACHA: 2097152,
    SSL_OP_SINGLE_DH_USE: 0,
    SSL_OP_SINGLE_ECDH_USE: 0,
    SSL_OP_SSLEAY_080_CLIENT_DH_BUG: 0,
    SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: 0,
    SSL_OP_TLS_BLOCK_PADDING_BUG: 0,
    SSL_OP_TLS_D5_BUG: 0,
    SSL_OP_TLS_ROLLBACK_BUG: 8388608,
    ENGINE_METHOD_RSA: 1,
    ENGINE_METHOD_DSA: 2,
    ENGINE_METHOD_DH: 4,
    ENGINE_METHOD_RAND: 8,
    ENGINE_METHOD_EC: 2048,
    ENGINE_METHOD_CIPHERS: 64,
    ENGINE_METHOD_DIGESTS: 128,
    ENGINE_METHOD_PKEY_METHS: 512,
    ENGINE_METHOD_PKEY_ASN1_METHS: 1024,
    ENGINE_METHOD_ALL: 65535,
    ENGINE_METHOD_NONE: 0,
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    RSA_PSS_SALTLEN_DIGEST: -1,
    RSA_PSS_SALTLEN_MAX_SIGN: -2,
    RSA_PSS_SALTLEN_AUTO: -2,
    defaultCoreCipherList: "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA",
    TLS1_VERSION: 769,
    TLS1_1_VERSION: 770,
    TLS1_2_VERSION: 771,
    TLS1_3_VERSION: 772,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
};
const zlib = {
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_VERSION_ERROR: -6,
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    ZLIB_VERNUM: 4784,
    DEFLATE: 1,
    INFLATE: 2,
    GZIP: 3,
    GUNZIP: 4,
    DEFLATERAW: 5,
    INFLATERAW: 6,
    UNZIP: 7,
    BROTLI_DECODE: 8,
    BROTLI_ENCODE: 9,
    Z_MIN_WINDOWBITS: 8,
    Z_MAX_WINDOWBITS: 15,
    Z_DEFAULT_WINDOWBITS: 15,
    Z_MIN_CHUNK: 64,
    Z_MAX_CHUNK: Infinity,
    Z_DEFAULT_CHUNK: 16384,
    Z_MIN_MEMLEVEL: 1,
    Z_MAX_MEMLEVEL: 9,
    Z_DEFAULT_MEMLEVEL: 8,
    Z_MIN_LEVEL: -1,
    Z_MAX_LEVEL: 9,
    Z_DEFAULT_LEVEL: -1,
    BROTLI_OPERATION_PROCESS: 0,
    BROTLI_OPERATION_FLUSH: 1,
    BROTLI_OPERATION_FINISH: 2,
    BROTLI_OPERATION_EMIT_METADATA: 3,
    BROTLI_PARAM_MODE: 0,
    BROTLI_MODE_GENERIC: 0,
    BROTLI_MODE_TEXT: 1,
    BROTLI_MODE_FONT: 2,
    BROTLI_DEFAULT_MODE: 0,
    BROTLI_PARAM_QUALITY: 1,
    BROTLI_MIN_QUALITY: 0,
    BROTLI_MAX_QUALITY: 11,
    BROTLI_DEFAULT_QUALITY: 11,
    BROTLI_PARAM_LGWIN: 2,
    BROTLI_MIN_WINDOW_BITS: 10,
    BROTLI_MAX_WINDOW_BITS: 24,
    BROTLI_LARGE_MAX_WINDOW_BITS: 30,
    BROTLI_DEFAULT_WINDOW: 22,
    BROTLI_PARAM_LGBLOCK: 3,
    BROTLI_MIN_INPUT_BLOCK_BITS: 16,
    BROTLI_MAX_INPUT_BLOCK_BITS: 24,
    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
    BROTLI_PARAM_SIZE_HINT: 5,
    BROTLI_PARAM_LARGE_WINDOW: 6,
    BROTLI_PARAM_NPOSTFIX: 7,
    BROTLI_PARAM_NDIRECT: 8,
    BROTLI_DECODER_RESULT_ERROR: 0,
    BROTLI_DECODER_RESULT_SUCCESS: 1,
    BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
    BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
    BROTLI_DECODER_NO_ERROR: 0,
    BROTLI_DECODER_SUCCESS: 1,
    BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
    BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
    BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
    BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
    BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
    BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
    BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
    BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
    BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
    BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
    BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
    BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
    BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
    BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
    BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
    BROTLI_DECODER_ERROR_UNREACHABLE: -31
};
const trace = {
    TRACE_EVENT_PHASE_BEGIN: 66,
    TRACE_EVENT_PHASE_END: 69,
    TRACE_EVENT_PHASE_COMPLETE: 88,
    TRACE_EVENT_PHASE_INSTANT: 73,
    TRACE_EVENT_PHASE_ASYNC_BEGIN: 83,
    TRACE_EVENT_PHASE_ASYNC_STEP_INTO: 84,
    TRACE_EVENT_PHASE_ASYNC_STEP_PAST: 112,
    TRACE_EVENT_PHASE_ASYNC_END: 70,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN: 98,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_END: 101,
    TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT: 110,
    TRACE_EVENT_PHASE_FLOW_BEGIN: 115,
    TRACE_EVENT_PHASE_FLOW_STEP: 116,
    TRACE_EVENT_PHASE_FLOW_END: 102,
    TRACE_EVENT_PHASE_METADATA: 77,
    TRACE_EVENT_PHASE_COUNTER: 67,
    TRACE_EVENT_PHASE_SAMPLE: 80,
    TRACE_EVENT_PHASE_CREATE_OBJECT: 78,
    TRACE_EVENT_PHASE_SNAPSHOT_OBJECT: 79,
    TRACE_EVENT_PHASE_DELETE_OBJECT: 68,
    TRACE_EVENT_PHASE_MEMORY_DUMP: 118,
    TRACE_EVENT_PHASE_MARK: 82,
    TRACE_EVENT_PHASE_CLOCK_SYNC: 99,
    TRACE_EVENT_PHASE_ENTER_CONTEXT: 40,
    TRACE_EVENT_PHASE_LEAVE_CONTEXT: 41,
    TRACE_EVENT_PHASE_LINK_IDS: 61
};
const mod6 = {
    os: os,
    fs: fs,
    crypto: crypto1,
    zlib: zlib,
    trace: trace
};
const { errno: { ENOTDIR , ENOENT  }  } = os;
const kIsNodeError = Symbol("kIsNodeError");
const classRegExp1 = /^([A-Z][a-z0-9]*)+$/;
const kTypes = [
    "string",
    "function",
    "number",
    "object",
    "Function",
    "Object",
    "boolean",
    "bigint",
    "symbol"
];
class AbortError extends Error {
    code;
    constructor(message = "The operation was aborted", options){
        if (options !== undefined && typeof options !== "object") {
            throw new codes.ERR_INVALID_ARG_TYPE("options", "Object", options);
        }
        super(message, options);
        this.code = "ABORT_ERR";
        this.name = "AbortError";
    }
}
function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for(; i >= start + 4; i -= 3){
        res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
}
const captureLargerStackTrace = hideStackFrames(function captureLargerStackTrace(err) {
    Error.captureStackTrace(err);
    return err;
});
hideStackFrames(function uvExceptionWithHostPort(err, syscall, address, port) {
    const { 0: code , 1: uvmsg  } = uvErrmapGet(err) || uvUnmappedError;
    const message = `${syscall} ${code}: ${uvmsg}`;
    let details = "";
    if (port && port > 0) {
        details = ` ${address}:${port}`;
    } else if (address) {
        details = ` ${address}`;
    }
    const ex = new Error(`${message}${details}`);
    ex.code = code;
    ex.errno = err;
    ex.syscall = syscall;
    ex.address = address;
    if (port) {
        ex.port = port;
    }
    return captureLargerStackTrace(ex);
});
const errnoException = hideStackFrames(function errnoException(err, syscall, original) {
    const code = getSystemErrorName(err);
    const message = original ? `${syscall} ${code} ${original}` : `${syscall} ${code}`;
    const ex = new Error(message);
    ex.errno = err;
    ex.code = code;
    ex.syscall = syscall;
    return captureLargerStackTrace(ex);
});
function uvErrmapGet(name) {
    return errorMap.get(name);
}
const uvUnmappedError = [
    "UNKNOWN",
    "unknown error"
];
const uvException = hideStackFrames(function uvException(ctx) {
    const { 0: code , 1: uvmsg  } = uvErrmapGet(ctx.errno) || uvUnmappedError;
    let message = `${code}: ${ctx.message || uvmsg}, ${ctx.syscall}`;
    let path;
    let dest;
    if (ctx.path) {
        path = ctx.path.toString();
        message += ` '${path}'`;
    }
    if (ctx.dest) {
        dest = ctx.dest.toString();
        message += ` -> '${dest}'`;
    }
    const err = new Error(message);
    for (const prop of Object.keys(ctx)){
        if (prop === "message" || prop === "path" || prop === "dest") {
            continue;
        }
        err[prop] = ctx[prop];
    }
    err.code = code;
    if (path) {
        err.path = path;
    }
    if (dest) {
        err.dest = dest;
    }
    return captureLargerStackTrace(err);
});
hideStackFrames(function exceptionWithHostPort(err, syscall, address, port, additional) {
    const code = getSystemErrorName(err);
    let details = "";
    if (port && port > 0) {
        details = ` ${address}:${port}`;
    } else if (address) {
        details = ` ${address}`;
    }
    if (additional) {
        details += ` - Local (${additional})`;
    }
    const ex = new Error(`${syscall} ${code}${details}`);
    ex.errno = err;
    ex.code = code;
    ex.syscall = syscall;
    ex.address = address;
    if (port) {
        ex.port = port;
    }
    return captureLargerStackTrace(ex);
});
hideStackFrames(function(code, syscall, hostname) {
    let errno;
    if (typeof code === "number") {
        errno = code;
        if (code === codeMap.get("EAI_NODATA") || code === codeMap.get("EAI_NONAME")) {
            code = "ENOTFOUND";
        } else {
            code = getSystemErrorName(code);
        }
    }
    const message = `${syscall} ${code}${hostname ? ` ${hostname}` : ""}`;
    const ex = new Error(message);
    ex.errno = errno;
    ex.code = code;
    ex.syscall = syscall;
    if (hostname) {
        ex.hostname = hostname;
    }
    return captureLargerStackTrace(ex);
});
class NodeErrorAbstraction extends Error {
    code;
    constructor(name, code, message){
        super(message);
        this.code = code;
        this.name = name;
        this.stack = this.stack && `${name} [${this.code}]${this.stack.slice(20)}`;
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
class NodeError extends NodeErrorAbstraction {
    constructor(code, message){
        super(Error.prototype.name, code, message);
    }
}
class NodeRangeError extends NodeErrorAbstraction {
    constructor(code, message){
        super(RangeError.prototype.name, code, message);
        Object.setPrototypeOf(this, RangeError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeTypeError extends NodeErrorAbstraction {
    constructor(code, message){
        super(TypeError.prototype.name, code, message);
        Object.setPrototypeOf(this, TypeError.prototype);
        this.toString = function() {
            return `${this.name} [${this.code}]: ${this.message}`;
        };
    }
}
class NodeSystemError extends NodeErrorAbstraction {
    constructor(key, context, msgPrefix){
        let message = `${msgPrefix}: ${context.syscall} returned ` + `${context.code} (${context.message})`;
        if (context.path !== undefined) {
            message += ` ${context.path}`;
        }
        if (context.dest !== undefined) {
            message += ` => ${context.dest}`;
        }
        super("SystemError", key, message);
        captureLargerStackTrace(this);
        Object.defineProperties(this, {
            [kIsNodeError]: {
                value: true,
                enumerable: false,
                writable: false,
                configurable: true
            },
            info: {
                value: context,
                enumerable: true,
                configurable: true,
                writable: false
            },
            errno: {
                get () {
                    return context.errno;
                },
                set: (value)=>{
                    context.errno = value;
                },
                enumerable: true,
                configurable: true
            },
            syscall: {
                get () {
                    return context.syscall;
                },
                set: (value)=>{
                    context.syscall = value;
                },
                enumerable: true,
                configurable: true
            }
        });
        if (context.path !== undefined) {
            Object.defineProperty(this, "path", {
                get () {
                    return context.path;
                },
                set: (value)=>{
                    context.path = value;
                },
                enumerable: true,
                configurable: true
            });
        }
        if (context.dest !== undefined) {
            Object.defineProperty(this, "dest", {
                get () {
                    return context.dest;
                },
                set: (value)=>{
                    context.dest = value;
                },
                enumerable: true,
                configurable: true
            });
        }
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
function makeSystemErrorWithCode(key, msgPrfix) {
    return class NodeError extends NodeSystemError {
        constructor(ctx){
            super(key, ctx, msgPrfix);
        }
    };
}
const ERR_FS_EISDIR = makeSystemErrorWithCode("ERR_FS_EISDIR", "Path is a directory");
function createInvalidArgType(name, expected) {
    expected = Array.isArray(expected) ? expected : [
        expected
    ];
    let msg = "The ";
    if (name.endsWith(" argument")) {
        msg += `${name} `;
    } else {
        const type = name.includes(".") ? "property" : "argument";
        msg += `"${name}" ${type} `;
    }
    msg += "must be ";
    const types = [];
    const instances = [];
    const other = [];
    for (const value of expected){
        if (kTypes.includes(value)) {
            types.push(value.toLocaleLowerCase());
        } else if (classRegExp1.test(value)) {
            instances.push(value);
        } else {
            other.push(value);
        }
    }
    if (instances.length > 0) {
        const pos = types.indexOf("object");
        if (pos !== -1) {
            types.splice(pos, 1);
            instances.push("Object");
        }
    }
    if (types.length > 0) {
        if (types.length > 2) {
            const last = types.pop();
            msg += `one of type ${types.join(", ")}, or ${last}`;
        } else if (types.length === 2) {
            msg += `one of type ${types[0]} or ${types[1]}`;
        } else {
            msg += `of type ${types[0]}`;
        }
        if (instances.length > 0 || other.length > 0) {
            msg += " or ";
        }
    }
    if (instances.length > 0) {
        if (instances.length > 2) {
            const last = instances.pop();
            msg += `an instance of ${instances.join(", ")}, or ${last}`;
        } else {
            msg += `an instance of ${instances[0]}`;
            if (instances.length === 2) {
                msg += ` or ${instances[1]}`;
            }
        }
        if (other.length > 0) {
            msg += " or ";
        }
    }
    if (other.length > 0) {
        if (other.length > 2) {
            const last = other.pop();
            msg += `one of ${other.join(", ")}, or ${last}`;
        } else if (other.length === 2) {
            msg += `one of ${other[0]} or ${other[1]}`;
        } else {
            if (other[0].toLowerCase() !== other[0]) {
                msg += "an ";
            }
            msg += `${other[0]}`;
        }
    }
    return msg;
}
class ERR_INVALID_ARG_TYPE_RANGE extends NodeRangeError {
    constructor(name, expected, actual){
        const msg = createInvalidArgType(name, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
    }
}
class ERR_INVALID_ARG_TYPE extends NodeTypeError {
    constructor(name, expected, actual){
        const msg = createInvalidArgType(name, expected);
        super("ERR_INVALID_ARG_TYPE", `${msg}.${invalidArgTypeHelper(actual)}`);
    }
    static RangeError = ERR_INVALID_ARG_TYPE_RANGE;
}
class ERR_INVALID_ARG_VALUE_RANGE extends NodeRangeError {
    constructor(name, value, reason = "is invalid"){
        const type = name.includes(".") ? "property" : "argument";
        const inspected = inspect(value);
        super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
    }
}
class ERR_INVALID_ARG_VALUE extends NodeTypeError {
    constructor(name, value, reason = "is invalid"){
        const type = name.includes(".") ? "property" : "argument";
        const inspected = inspect(value);
        super("ERR_INVALID_ARG_VALUE", `The ${type} '${name}' ${reason}. Received ${inspected}`);
    }
    static RangeError = ERR_INVALID_ARG_VALUE_RANGE;
}
function invalidArgTypeHelper(input) {
    if (input == null) {
        return ` Received ${input}`;
    }
    if (typeof input === "function" && input.name) {
        return ` Received function ${input.name}`;
    }
    if (typeof input === "object") {
        if (input.constructor && input.constructor.name) {
            return ` Received an instance of ${input.constructor.name}`;
        }
        return ` Received ${inspect(input, {
            depth: -1
        })}`;
    }
    let inspected = inspect(input, {
        colors: false
    });
    if (inspected.length > 25) {
        inspected = `${inspected.slice(0, 25)}...`;
    }
    return ` Received type ${typeof input} (${inspected})`;
}
class ERR_OUT_OF_RANGE extends RangeError {
    code = "ERR_OUT_OF_RANGE";
    constructor(str, range, input, replaceDefaultBoolean = false){
        assert1(range, 'Missing "range" argument');
        let msg = replaceDefaultBoolean ? str : `The value of "${str}" is out of range.`;
        let received;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
            received = String(input);
            if (input > 2n ** 32n || input < -(2n ** 32n)) {
                received = addNumericalSeparator(received);
            }
            received += "n";
        } else {
            received = inspect(input);
        }
        msg += ` It must be ${range}. Received ${received}`;
        super(msg);
        const { name  } = this;
        this.name = `${name} [${this.code}]`;
        this.stack;
        this.name = name;
    }
}
class ERR_BUFFER_OUT_OF_BOUNDS extends NodeRangeError {
    constructor(name){
        super("ERR_BUFFER_OUT_OF_BOUNDS", name ? `"${name}" is outside of buffer bounds` : "Attempt to access memory outside buffer bounds");
    }
}
class ERR_CRYPTO_FIPS_FORCED extends NodeError {
    constructor(){
        super("ERR_CRYPTO_FIPS_FORCED", "Cannot set FIPS mode, it was forced with --force-fips at startup.");
    }
}
class ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE extends NodeTypeError {
    constructor(x, y){
        super("ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE", `Invalid key object type ${x}, expected ${y}.`);
    }
}
class ERR_FS_INVALID_SYMLINK_TYPE extends NodeError {
    constructor(x){
        super("ERR_FS_INVALID_SYMLINK_TYPE", `Symlink type must be one of "dir", "file", or "junction". Received "${x}"`);
    }
}
class ERR_INVALID_CURSOR_POS extends NodeTypeError {
    constructor(){
        super("ERR_INVALID_CURSOR_POS", `Cannot set cursor row without setting its column`);
    }
}
class ERR_INVALID_FILE_URL_HOST extends NodeTypeError {
    constructor(x){
        super("ERR_INVALID_FILE_URL_HOST", `File URL host must be "localhost" or empty on ${x}`);
    }
}
class ERR_INVALID_FILE_URL_PATH extends NodeTypeError {
    constructor(x){
        super("ERR_INVALID_FILE_URL_PATH", `File URL path ${x}`);
    }
}
class ERR_INVALID_OPT_VALUE_ENCODING extends NodeTypeError {
    constructor(x){
        super("ERR_INVALID_OPT_VALUE_ENCODING", `The value "${x}" is invalid for option "encoding"`);
    }
}
class ERR_IPC_CHANNEL_CLOSED extends NodeError {
    constructor(){
        super("ERR_IPC_CHANNEL_CLOSED", `Channel closed`);
    }
}
class ERR_MISSING_ARGS extends NodeTypeError {
    constructor(...args){
        let msg = "The ";
        const len = args.length;
        const wrap = (a)=>`"${a}"`;
        args = args.map((a)=>Array.isArray(a) ? a.map(wrap).join(" or ") : wrap(a));
        switch(len){
            case 1:
                msg += `${args[0]} argument`;
                break;
            case 2:
                msg += `${args[0]} and ${args[1]} arguments`;
                break;
            default:
                msg += args.slice(0, len - 1).join(", ");
                msg += `, and ${args[len - 1]} arguments`;
                break;
        }
        super("ERR_MISSING_ARGS", `${msg} must be specified`);
    }
}
class ERR_SOCKET_BAD_PORT extends NodeRangeError {
    constructor(name, port, allowZero = true){
        assert1(typeof allowZero === "boolean", "The 'allowZero' argument must be of type boolean.");
        const operator = allowZero ? ">=" : ">";
        super("ERR_SOCKET_BAD_PORT", `${name} should be ${operator} 0 and < 65536. Received ${port}.`);
    }
}
class ERR_STREAM_PREMATURE_CLOSE extends NodeError {
    constructor(){
        super("ERR_STREAM_PREMATURE_CLOSE", `Premature close`);
    }
}
class ERR_UNHANDLED_ERROR extends NodeError {
    constructor(x){
        super("ERR_UNHANDLED_ERROR", `Unhandled error. (${x})`);
    }
}
class ERR_UNKNOWN_ENCODING extends NodeTypeError {
    constructor(x){
        super("ERR_UNKNOWN_ENCODING", `Unknown encoding: ${x}`);
    }
}
class ERR_UNKNOWN_SIGNAL extends NodeTypeError {
    constructor(x){
        super("ERR_UNKNOWN_SIGNAL", `Unknown signal: ${x}`);
    }
}
class ERR_INVALID_URL_SCHEME extends NodeTypeError {
    constructor(expected){
        expected = Array.isArray(expected) ? expected : [
            expected
        ];
        const res = expected.length === 2 ? `one of scheme ${expected[0]} or ${expected[1]}` : `of scheme ${expected[0]}`;
        super("ERR_INVALID_URL_SCHEME", `The URL must be ${res}`);
    }
}
class ERR_INTERNAL_ASSERTION extends NodeError {
    constructor(message){
        const suffix = "This is caused by either a bug in Node.js " + "or incorrect usage of Node.js internals.\n" + "Please open an issue with this stack trace at " + "https://github.com/nodejs/node/issues\n";
        super("ERR_INTERNAL_ASSERTION", message === undefined ? suffix : `${message}\n${suffix}`);
    }
}
class ERR_FS_RMDIR_ENOTDIR extends NodeSystemError {
    constructor(path){
        const code = isWindows1 ? "ENOENT" : "ENOTDIR";
        const ctx = {
            message: "not a directory",
            path,
            syscall: "rmdir",
            code,
            errno: isWindows1 ? ENOENT : ENOTDIR
        };
        super(code, ctx, "Path is not a directory");
    }
}
function denoErrorToNodeError(e, ctx) {
    const errno = extractOsErrorNumberFromErrorMessage(e);
    if (typeof errno === "undefined") {
        return e;
    }
    const ex = uvException({
        errno: mapSysErrnoToUvErrno(errno),
        ...ctx
    });
    return ex;
}
function extractOsErrorNumberFromErrorMessage(e) {
    const match = e instanceof Error ? e.message.match(/\(os error (\d+)\)/) : false;
    if (match) {
        return +match[1];
    }
    return undefined;
}
function aggregateTwoErrors(innerError, outerError) {
    if (innerError && outerError && innerError !== outerError) {
        if (Array.isArray(outerError.errors)) {
            outerError.errors.push(innerError);
            return outerError;
        }
        const err = new AggregateError([
            outerError,
            innerError
        ], outerError.message);
        err.code = outerError.code;
        return err;
    }
    return innerError || outerError;
}
codes.ERR_IPC_CHANNEL_CLOSED = ERR_IPC_CHANNEL_CLOSED;
codes.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE;
codes.ERR_INVALID_ARG_VALUE = ERR_INVALID_ARG_VALUE;
codes.ERR_OUT_OF_RANGE = ERR_OUT_OF_RANGE;
codes.ERR_SOCKET_BAD_PORT = ERR_SOCKET_BAD_PORT;
codes.ERR_BUFFER_OUT_OF_BOUNDS = ERR_BUFFER_OUT_OF_BOUNDS;
codes.ERR_UNKNOWN_ENCODING = ERR_UNKNOWN_ENCODING;
hideStackFrames(function genericNodeError(message, errorProperties) {
    const err = new Error(message);
    Object.assign(err, errorProperties);
    return err;
});
const { hasOwn  } = Object;
function get(obj, key) {
    if (hasOwn(obj, key)) {
        return obj[key];
    }
}
function getForce(obj, key) {
    const v = get(obj, key);
    assert1(v != null);
    return v;
}
function isNumber(x) {
    if (typeof x === "number") return true;
    if (/^0x[0-9a-f]+$/i.test(String(x))) return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(String(x));
}
function hasKey(obj, keys) {
    let o = obj;
    keys.slice(0, -1).forEach((key)=>{
        o = get(o, key) ?? {};
    });
    const key = keys[keys.length - 1];
    return hasOwn(o, key);
}
function parse3(args, { "--": doubleDash = false , alias ={} , boolean: __boolean = false , default: defaults = {} , stopEarly =false , string =[] , collect =[] , negatable =[] , unknown =(i)=>i  } = {}) {
    const aliases = {};
    const flags = {
        bools: {},
        strings: {},
        unknownFn: unknown,
        allBools: false,
        collect: {},
        negatable: {}
    };
    if (alias !== undefined) {
        for(const key in alias){
            const val = getForce(alias, key);
            if (typeof val === "string") {
                aliases[key] = [
                    val
                ];
            } else {
                aliases[key] = val;
            }
            for (const alias of getForce(aliases, key)){
                aliases[alias] = [
                    key
                ].concat(aliases[key].filter((y)=>alias !== y));
            }
        }
    }
    if (__boolean !== undefined) {
        if (typeof __boolean === "boolean") {
            flags.allBools = !!__boolean;
        } else {
            const booleanArgs = typeof __boolean === "string" ? [
                __boolean
            ] : __boolean;
            for (const key of booleanArgs.filter(Boolean)){
                flags.bools[key] = true;
                const alias = get(aliases, key);
                if (alias) {
                    for (const al of alias){
                        flags.bools[al] = true;
                    }
                }
            }
        }
    }
    if (string !== undefined) {
        const stringArgs = typeof string === "string" ? [
            string
        ] : string;
        for (const key of stringArgs.filter(Boolean)){
            flags.strings[key] = true;
            const alias = get(aliases, key);
            if (alias) {
                for (const al of alias){
                    flags.strings[al] = true;
                }
            }
        }
    }
    if (collect !== undefined) {
        const collectArgs = typeof collect === "string" ? [
            collect
        ] : collect;
        for (const key of collectArgs.filter(Boolean)){
            flags.collect[key] = true;
            const alias = get(aliases, key);
            if (alias) {
                for (const al of alias){
                    flags.collect[al] = true;
                }
            }
        }
    }
    if (negatable !== undefined) {
        const negatableArgs = typeof negatable === "string" ? [
            negatable
        ] : negatable;
        for (const key of negatableArgs.filter(Boolean)){
            flags.negatable[key] = true;
            const alias = get(aliases, key);
            if (alias) {
                for (const al of alias){
                    flags.negatable[al] = true;
                }
            }
        }
    }
    const argv = {
        _: []
    };
    function argDefined(key, arg) {
        return flags.allBools && /^--[^=]+$/.test(arg) || get(flags.bools, key) || !!get(flags.strings, key) || !!get(aliases, key);
    }
    function setKey(obj, name, value, collect = true) {
        let o = obj;
        const keys = name.split(".");
        keys.slice(0, -1).forEach(function(key) {
            if (get(o, key) === undefined) {
                o[key] = {};
            }
            o = get(o, key);
        });
        const key = keys[keys.length - 1];
        const collectable = collect && !!get(flags.collect, name);
        if (!collectable) {
            o[key] = value;
        } else if (get(o, key) === undefined) {
            o[key] = [
                value
            ];
        } else if (Array.isArray(get(o, key))) {
            o[key].push(value);
        } else {
            o[key] = [
                get(o, key),
                value
            ];
        }
    }
    function setArg(key, val, arg = undefined, collect) {
        if (arg && flags.unknownFn && !argDefined(key, arg)) {
            if (flags.unknownFn(arg, key, val) === false) return;
        }
        const value = !get(flags.strings, key) && isNumber(val) ? Number(val) : val;
        setKey(argv, key, value, collect);
        const alias = get(aliases, key);
        if (alias) {
            for (const x of alias){
                setKey(argv, x, value, collect);
            }
        }
    }
    function aliasIsBoolean(key) {
        return getForce(aliases, key).some((x)=>typeof get(flags.bools, x) === "boolean");
    }
    let notFlags = [];
    if (args.includes("--")) {
        notFlags = args.slice(args.indexOf("--") + 1);
        args = args.slice(0, args.indexOf("--"));
    }
    for(let i = 0; i < args.length; i++){
        const arg = args[i];
        if (/^--.+=/.test(arg)) {
            const m = arg.match(/^--([^=]+)=(.*)$/s);
            assert1(m != null);
            const [, key, value] = m;
            if (flags.bools[key]) {
                const booleanValue = value !== "false";
                setArg(key, booleanValue, arg);
            } else {
                setArg(key, value, arg);
            }
        } else if (/^--no-.+/.test(arg) && get(flags.negatable, arg.replace(/^--no-/, ""))) {
            const m = arg.match(/^--no-(.+)/);
            assert1(m != null);
            setArg(m[1], false, arg, false);
        } else if (/^--.+/.test(arg)) {
            const m = arg.match(/^--(.+)/);
            assert1(m != null);
            const [, key] = m;
            const next = args[i + 1];
            if (next !== undefined && !/^-/.test(next) && !get(flags.bools, key) && !flags.allBools && (get(aliases, key) ? !aliasIsBoolean(key) : true)) {
                setArg(key, next, arg);
                i++;
            } else if (/^(true|false)$/.test(next)) {
                setArg(key, next === "true", arg);
                i++;
            } else {
                setArg(key, get(flags.strings, key) ? "" : true, arg);
            }
        } else if (/^-[^-]+/.test(arg)) {
            const letters = arg.slice(1, -1).split("");
            let broken = false;
            for(let j = 0; j < letters.length; j++){
                const next = arg.slice(j + 2);
                if (next === "-") {
                    setArg(letters[j], next, arg);
                    continue;
                }
                if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
                    setArg(letters[j], next.split(/=(.+)/)[1], arg);
                    broken = true;
                    break;
                }
                if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                    setArg(letters[j], next, arg);
                    broken = true;
                    break;
                }
                if (letters[j + 1] && letters[j + 1].match(/\W/)) {
                    setArg(letters[j], arg.slice(j + 2), arg);
                    broken = true;
                    break;
                } else {
                    setArg(letters[j], get(flags.strings, letters[j]) ? "" : true, arg);
                }
            }
            const [key] = arg.slice(-1);
            if (!broken && key !== "-") {
                if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !get(flags.bools, key) && (get(aliases, key) ? !aliasIsBoolean(key) : true)) {
                    setArg(key, args[i + 1], arg);
                    i++;
                } else if (args[i + 1] && /^(true|false)$/.test(args[i + 1])) {
                    setArg(key, args[i + 1] === "true", arg);
                    i++;
                } else {
                    setArg(key, get(flags.strings, key) ? "" : true, arg);
                }
            }
        } else {
            if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                argv._.push(flags.strings["_"] ?? !isNumber(arg) ? arg : Number(arg));
            }
            if (stopEarly) {
                argv._.push(...args.slice(i + 1));
                break;
            }
        }
    }
    for (const [key, value] of Object.entries(defaults)){
        if (!hasKey(argv, key.split("."))) {
            setKey(argv, key, value);
            if (aliases[key]) {
                for (const x of aliases[key]){
                    setKey(argv, x, value);
                }
            }
        }
    }
    for (const key of Object.keys(flags.bools)){
        if (!hasKey(argv, key.split("."))) {
            const value = get(flags.collect, key) ? [] : false;
            setKey(argv, key, value, false);
        }
    }
    for (const key of Object.keys(flags.strings)){
        if (!hasKey(argv, key.split(".")) && get(flags.collect, key)) {
            setKey(argv, key, [], false);
        }
    }
    if (doubleDash) {
        argv["--"] = [];
        for (const key of notFlags){
            argv["--"].push(key);
        }
    } else {
        for (const key of notFlags){
            argv._.push(key);
        }
    }
    return argv;
}
function getOptions() {
    const { Deno: Deno1  } = globalThis;
    const args = parse3(Deno1?.args ?? []);
    const options = new Map(Object.entries(args).map(([key, value])=>[
            key,
            {
                value
            }
        ]));
    return {
        options
    };
}
let optionsMap;
function getOptionsFromBinding() {
    if (!optionsMap) {
        ({ options: optionsMap  } = getOptions());
    }
    return optionsMap;
}
function getOptionValue(optionName) {
    const options = getOptionsFromBinding();
    if (optionName.startsWith("--no-")) {
        const option = options.get("--" + optionName.slice(5));
        return option && !option.value;
    }
    return options.get(optionName)?.value;
}
var Encodings;
(function(Encodings) {
    Encodings[Encodings["ASCII"] = 0] = "ASCII";
    Encodings[Encodings["UTF8"] = 1] = "UTF8";
    Encodings[Encodings["BASE64"] = 2] = "BASE64";
    Encodings[Encodings["UCS2"] = 3] = "UCS2";
    Encodings[Encodings["BINARY"] = 4] = "BINARY";
    Encodings[Encodings["HEX"] = 5] = "HEX";
    Encodings[Encodings["BUFFER"] = 6] = "BUFFER";
    Encodings[Encodings["BASE64URL"] = 7] = "BASE64URL";
    Encodings[Encodings["LATIN1"] = 4] = "LATIN1";
})(Encodings || (Encodings = {}));
const encodings = [];
encodings[Encodings.ASCII] = "ascii";
encodings[Encodings.BASE64] = "base64";
encodings[Encodings.BASE64URL] = "base64url";
encodings[Encodings.BUFFER] = "buffer";
encodings[Encodings.HEX] = "hex";
encodings[Encodings.LATIN1] = "latin1";
encodings[Encodings.UCS2] = "utf16le";
encodings[Encodings.UTF8] = "utf8";
const __default1 = {
    encodings
};
const mod7 = {
    encodings: encodings,
    default: __default1
};
function indexOfNeedle(source, needle, start = 0) {
    if (start >= source.length) {
        return -1;
    }
    if (start < 0) {
        start = Math.max(0, source.length + start);
    }
    const s = needle[0];
    for(let i = start; i < source.length; i++){
        if (source[i] !== s) continue;
        const pin = i;
        let matched = 1;
        let j = i;
        while(matched < needle.length){
            j++;
            if (source[j] !== needle[j - pin]) {
                break;
            }
            matched++;
        }
        if (matched === needle.length) {
            return pin;
        }
    }
    return -1;
}
function numberToBytes(n) {
    if (n === 0) return new Uint8Array([
        0
    ]);
    const bytes = [];
    bytes.unshift(n & 255);
    while(n >= 256){
        n = n >>> 8;
        bytes.unshift(n & 255);
    }
    return new Uint8Array(bytes);
}
function findLastIndex(targetBuffer, buffer, offset) {
    offset = offset > targetBuffer.length ? targetBuffer.length : offset;
    const searchableBuffer = targetBuffer.slice(0, offset + buffer.length);
    const searchableBufferLastIndex = searchableBuffer.length - 1;
    const bufferLastIndex = buffer.length - 1;
    let lastMatchIndex = -1;
    let matches = 0;
    let index = -1;
    for(let x = 0; x <= searchableBufferLastIndex; x++){
        if (searchableBuffer[searchableBufferLastIndex - x] === buffer[bufferLastIndex - matches]) {
            if (lastMatchIndex === -1) {
                lastMatchIndex = x;
            }
            matches++;
        } else {
            matches = 0;
            if (lastMatchIndex !== -1) {
                x = lastMatchIndex + 1;
                lastMatchIndex = -1;
            }
            continue;
        }
        if (matches === buffer.length) {
            index = x;
            break;
        }
    }
    if (index === -1) return index;
    return searchableBufferLastIndex - index;
}
function indexOfBuffer(targetBuffer, buffer, byteOffset, encoding, forwardDirection) {
    if (!Encodings[encoding] === undefined) {
        throw new Error(`Unknown encoding code ${encoding}`);
    }
    if (!forwardDirection) {
        if (byteOffset < 0) {
            byteOffset = targetBuffer.length + byteOffset;
        }
        if (buffer.length === 0) {
            return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
        }
        return findLastIndex(targetBuffer, buffer, byteOffset);
    }
    if (buffer.length === 0) {
        return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return indexOfNeedle(targetBuffer, buffer, byteOffset);
}
function indexOfNumber(targetBuffer, number, byteOffset, forwardDirection) {
    const bytes = numberToBytes(number);
    if (bytes.length > 1) {
        throw new Error("Multi byte number search is not supported");
    }
    return indexOfBuffer(targetBuffer, numberToBytes(number), byteOffset, Encodings.UTF8, forwardDirection);
}
const __default2 = {
    indexOfBuffer,
    indexOfNumber
};
const mod8 = {
    indexOfBuffer: indexOfBuffer,
    indexOfNumber: indexOfNumber,
    numberToBytes: numberToBytes,
    default: __default2
};
const base64abc = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "+",
    "/"
];
function encode(data) {
    const uint8 = typeof data === "string" ? new TextEncoder().encode(data) : data instanceof Uint8Array ? data : new Uint8Array(data);
    let result = "", i;
    const l = uint8.length;
    for(i = 2; i < l; i += 3){
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc[(uint8[i - 1] & 0x0f) << 2 | uint8[i] >> 6];
        result += base64abc[uint8[i] & 0x3f];
    }
    if (i === l + 1) {
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4];
        result += "==";
    }
    if (i === l) {
        result += base64abc[uint8[i - 2] >> 2];
        result += base64abc[(uint8[i - 2] & 0x03) << 4 | uint8[i - 1] >> 4];
        result += base64abc[(uint8[i - 1] & 0x0f) << 2];
        result += "=";
    }
    return result;
}
function decode(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i = 0; i < size; i++){
        bytes[i] = binString.charCodeAt(i);
    }
    return bytes;
}
function addPaddingToBase64url(base64url) {
    if (base64url.length % 4 === 2) return base64url + "==";
    if (base64url.length % 4 === 3) return base64url + "=";
    if (base64url.length % 4 === 1) {
        throw new TypeError("Illegal base64url string!");
    }
    return base64url;
}
function convertBase64urlToBase64(b64url) {
    if (!/^[-_A-Z0-9]*?={0,2}$/i.test(b64url)) {
        throw new TypeError("Failed to decode base64url: invalid character");
    }
    return addPaddingToBase64url(b64url).replace(/\-/g, "+").replace(/_/g, "/");
}
function convertBase64ToBase64url(b64) {
    return b64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function encode1(data) {
    return convertBase64ToBase64url(encode(data));
}
function decode1(b64url) {
    return decode(convertBase64urlToBase64(b64url));
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        byteArray.push(str.charCodeAt(i) & 255);
    }
    return new Uint8Array(byteArray);
}
function base64ToBytes(str) {
    str = base64clean(str);
    str = str.replaceAll("-", "+").replaceAll("_", "/");
    return decode(str);
}
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while(str.length % 4 !== 0){
        str = str + "=";
    }
    return str;
}
function base64UrlToBytes(str) {
    str = base64clean(str);
    str = str.replaceAll("+", "-").replaceAll("/", "_");
    return decode1(str);
}
function hexToBytes(str) {
    const byteArray = new Uint8Array(Math.floor((str || "").length / 2));
    let i;
    for(i = 0; i < byteArray.length; i++){
        const a = Number.parseInt(str[i * 2], 16);
        const b = Number.parseInt(str[i * 2 + 1], 16);
        if (Number.isNaN(a) && Number.isNaN(b)) {
            break;
        }
        byteArray[i] = a << 4 | b;
    }
    return new Uint8Array(i === byteArray.length ? byteArray : byteArray.slice(0, i));
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) {
            break;
        }
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return new Uint8Array(byteArray);
}
function bytesToAscii(bytes) {
    let ret = "";
    for(let i = 0; i < bytes.length; ++i){
        ret += String.fromCharCode(bytes[i] & 127);
    }
    return ret;
}
function bytesToUtf16le(bytes) {
    let res = "";
    for(let i = 0; i < bytes.length - 1; i += 2){
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
}
Array.isArray;
Object.assign;
Object.create;
Object.hasOwn;
RegExp.prototype.exec;
String.fromCharCode;
const { signals  } = os;
Symbol.for("nodejs.util.inspect.custom");
const kEnumerableProperty = Object.create(null);
kEnumerableProperty.enumerable = true;
const kEmptyObject = Object.freeze(Object.create(null));
function once(callback) {
    let called = false;
    return function(...args) {
        if (called) return;
        called = true;
        Reflect.apply(callback, this, args);
    };
}
function createDeferredPromise() {
    let resolve;
    let reject;
    const promise = new Promise((res, rej)=>{
        resolve = res;
        reject = rej;
    });
    return {
        promise,
        resolve,
        reject
    };
}
const kCustomPromisifiedSymbol = Symbol.for("nodejs.util.promisify.custom");
const kCustomPromisifyArgsSymbol = Symbol.for("nodejs.util.promisify.customArgs");
function promisify(original) {
    validateFunction(original, "original");
    if (original[kCustomPromisifiedSymbol]) {
        const fn = original[kCustomPromisifiedSymbol];
        validateFunction(fn, "util.promisify.custom");
        return Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    const argumentNames = original[kCustomPromisifyArgsSymbol];
    function fn(...args) {
        return new Promise((resolve, reject)=>{
            args.push((err, ...values)=>{
                if (err) {
                    return reject(err);
                }
                if (argumentNames !== undefined && values.length > 1) {
                    const obj = {};
                    for(let i = 0; i < argumentNames.length; i++){
                        obj[argumentNames[i]] = values[i];
                    }
                    resolve(obj);
                } else {
                    resolve(values[0]);
                }
            });
            Reflect.apply(original, this, args);
        });
    }
    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
    });
    return Object.defineProperties(fn, Object.getOwnPropertyDescriptors(original));
}
promisify.custom = kCustomPromisifiedSymbol;
const utf8Encoder = new TextEncoder();
const float32Array = new Float32Array(1);
const uInt8Float32Array = new Uint8Array(float32Array.buffer);
const float64Array = new Float64Array(1);
const uInt8Float64Array = new Uint8Array(float64Array.buffer);
float32Array[0] = -1;
const bigEndian = uInt8Float32Array[3] === 0;
const kMaxLength = 2147483647;
const MAX_UINT32 = 2 ** 32;
const customInspectSymbol1 = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
const INSPECT_MAX_BYTES = 50;
const constants = {
    MAX_LENGTH: 2147483647,
    MAX_STRING_LENGTH: 536870888
};
Object.defineProperty(Buffer.prototype, "parent", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) {
            return void 0;
        }
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, "offset", {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) {
            return void 0;
        }
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > 2147483647) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function Buffer(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
            throw new codes.ERR_INVALID_ARG_TYPE("string", "string", arg);
        }
        return _allocUnsafe(arg);
    }
    return _from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192;
function _from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
    }
    if (typeof value === "object" && value !== null) {
        if (isAnyArrayBuffer1(value)) {
            return fromArrayBuffer(value, encodingOrOffset, length);
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value && (typeof valueOf === "string" || typeof valueOf === "object")) {
            return _from(valueOf, encodingOrOffset, length);
        }
        const b = fromObject(value);
        if (b) {
            return b;
        }
        if (typeof value[Symbol.toPrimitive] === "function") {
            const primitive = value[Symbol.toPrimitive]("string");
            if (typeof primitive === "string") {
                return fromString(primitive, encodingOrOffset);
            }
        }
    }
    throw new codes.ERR_INVALID_ARG_TYPE("first argument", [
        "string",
        "Buffer",
        "ArrayBuffer",
        "Array",
        "Array-like Object"
    ], value);
}
Buffer.from = function from(value, encodingOrOffset, length) {
    return _from(value, encodingOrOffset, length);
};
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    validateNumber(size, "size");
    if (!(size >= 0 && size <= 2147483647)) {
        throw new codes.ERR_INVALID_ARG_VALUE.RangeError("size", size);
    }
}
function _alloc(size, fill, encoding) {
    assertSize(size);
    const buffer = createBuffer(size);
    if (fill !== undefined) {
        if (encoding !== undefined && typeof encoding !== "string") {
            throw new codes.ERR_INVALID_ARG_TYPE("encoding", "string", encoding);
        }
        return buffer.fill(fill, encoding);
    }
    return buffer;
}
Buffer.alloc = function alloc(size, fill, encoding) {
    return _alloc(size, fill, encoding);
};
function _allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
Buffer.allocUnsafe = function allocUnsafe(size) {
    return _allocUnsafe(size);
};
Buffer.allocUnsafeSlow = function allocUnsafeSlow(size) {
    return _allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
    }
    if (!Buffer.isEncoding(encoding)) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
        buf = buf.slice(0, actual);
    }
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1){
        buf[i] = array[i] & 255;
    }
    return buf;
}
function fromObject(obj) {
    if (obj.length !== undefined || isAnyArrayBuffer1(obj.buffer)) {
        if (typeof obj.length !== "number") {
            return createBuffer(0);
        }
        return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
    }
}
function checked(length) {
    if (length >= 2147483647) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647..toString(16) + " bytes");
    }
    return length | 0;
}
function SlowBuffer(length) {
    assertSize(length);
    return Buffer.alloc(+length);
}
Object.setPrototypeOf(SlowBuffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(SlowBuffer, Uint8Array);
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) {
        a = Buffer.from(a, a.offset, a.byteLength);
    }
    if (isInstance(b, Uint8Array)) {
        b = Buffer.from(b, b.offset, b.byteLength);
    }
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b) {
        return 0;
    }
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i){
        if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    return typeof encoding === "string" && encoding.length !== 0 && normalizeEncoding(encoding) !== undefined;
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
        throw new codes.ERR_INVALID_ARG_TYPE("list", "Array", list);
    }
    if (list.length === 0) {
        return Buffer.alloc(0);
    }
    if (length === undefined) {
        length = 0;
        for(let i = 0; i < list.length; i++){
            if (list[i].length) {
                length += list[i].length;
            }
        }
    } else {
        validateOffset(length, "length");
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(let i = 0; i < list.length; i++){
        const buf = list[i];
        if (!isUint8Array(buf)) {
            throw new codes.ERR_INVALID_ARG_TYPE(`list[${i}]`, [
                "Buffer",
                "Uint8Array"
            ], list[i]);
        }
        pos += _copyActual(buf, buffer, pos, 0, buf.length);
    }
    if (pos < length) {
        buffer.fill(0, pos, length);
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (typeof string !== "string") {
        if (isArrayBufferView(string) || isAnyArrayBuffer1(string)) {
            return string.byteLength;
        }
        throw new codes.ERR_INVALID_ARG_TYPE("string", [
            "string",
            "Buffer",
            "ArrayBuffer"
        ], string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) {
        return 0;
    }
    if (!encoding) {
        return mustMatch ? -1 : byteLengthUtf8(string);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        return mustMatch ? -1 : byteLengthUtf8(string);
    }
    return ops.byteLength(string);
}
Buffer.byteLength = byteLength;
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for(let i = 0; i < len; i += 2){
        swap(this, i, i + 1);
    }
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString(encoding, start, end) {
    if (arguments.length === 0) {
        return this.utf8Slice(0, this.length);
    }
    const len = this.length;
    if (start <= 0) {
        start = 0;
    } else if (start >= len) {
        return "";
    } else {
        start |= 0;
    }
    if (end === undefined || end > len) {
        end = len;
    } else {
        end |= 0;
    }
    if (end <= start) {
        return "";
    }
    if (encoding === undefined) {
        return this.utf8Slice(start, end);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.slice(this, start, end);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!isUint8Array(b)) {
        throw new codes.ERR_INVALID_ARG_TYPE("otherBuffer", [
            "Buffer",
            "Uint8Array"
        ], b);
    }
    if (this === b) {
        return true;
    }
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = "";
    const max = INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) {
        str += " ... ";
    }
    return "<Buffer " + str + ">";
};
if (customInspectSymbol1) {
    Buffer.prototype[customInspectSymbol1] = Buffer.prototype.inspect;
}
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength);
    }
    if (!Buffer.isBuffer(target)) {
        throw new codes.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (start === undefined) {
        start = 0;
    } else {
        validateOffset(start, "targetStart", 0, kMaxLength);
    }
    if (end === undefined) {
        end = target.length;
    } else {
        validateOffset(end, "targetEnd", 0, target.length);
    }
    if (thisStart === undefined) {
        thisStart = 0;
    } else {
        validateOffset(start, "sourceStart", 0, kMaxLength);
    }
    if (thisEnd === undefined) {
        thisEnd = this.length;
    } else {
        validateOffset(end, "sourceEnd", 0, this.length);
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new codes.ERR_OUT_OF_RANGE("out of range index", "range");
    }
    if (thisStart >= thisEnd && start >= end) {
        return 0;
    }
    if (thisStart >= thisEnd) {
        return -1;
    }
    if (start >= end) {
        return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) {
        return 0;
    }
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i){
        if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
        }
    }
    if (x < y) {
        return -1;
    }
    if (y < x) {
        return 1;
    }
    return 0;
};
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    validateBuffer(buffer);
    if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = undefined;
    } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;
    if (Number.isNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length || buffer.byteLength;
    }
    dir = !!dir;
    if (typeof val === "number") {
        return indexOfNumber(buffer, val >>> 0, byteOffset, dir);
    }
    let ops;
    if (encoding === undefined) {
        ops = encodingOps.utf8;
    } else {
        ops = getEncodingOps(encoding);
    }
    if (typeof val === "string") {
        if (ops === undefined) {
            throw new codes.ERR_UNKNOWN_ENCODING(encoding);
        }
        return ops.indexOf(buffer, val, byteOffset, dir);
    }
    if (isUint8Array(val)) {
        const encodingVal = ops === undefined ? encodingsMap.utf8 : ops.encodingVal;
        return indexOfBuffer(buffer, val, byteOffset, encodingVal, dir);
    }
    throw new codes.ERR_INVALID_ARG_TYPE("value", [
        "number",
        "string",
        "Buffer",
        "Uint8Array"
    ], val);
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
Buffer.prototype.asciiSlice = function asciiSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToAscii(this);
    } else {
        return bytesToAscii(this.slice(offset, length));
    }
};
Buffer.prototype.asciiWrite = function asciiWrite(string, offset, length) {
    return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer.prototype.base64Slice = function base64Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode(this);
    } else {
        return encode(this.slice(offset, length));
    }
};
Buffer.prototype.base64Write = function base64Write(string, offset, length) {
    return blitBuffer(base64ToBytes(string), this, offset, length);
};
Buffer.prototype.base64urlSlice = function base64urlSlice(offset, length) {
    if (offset === 0 && length === this.length) {
        return encode1(this);
    } else {
        return encode1(this.slice(offset, length));
    }
};
Buffer.prototype.base64urlWrite = function base64urlWrite(string, offset, length) {
    return blitBuffer(base64UrlToBytes(string), this, offset, length);
};
Buffer.prototype.hexWrite = function hexWrite(string, offset, length) {
    return blitBuffer(hexToBytes(string, this.length - offset), this, offset, length);
};
Buffer.prototype.hexSlice = function hexSlice(string, offset, length) {
    return _hexSlice(this, string, offset, length);
};
Buffer.prototype.latin1Slice = function latin1Slice(string, offset, length) {
    return _latin1Slice(this, string, offset, length);
};
Buffer.prototype.latin1Write = function latin1Write(string, offset, length) {
    return blitBuffer(asciiToBytes(string), this, offset, length);
};
Buffer.prototype.ucs2Slice = function ucs2Slice(offset, length) {
    if (offset === 0 && length === this.length) {
        return bytesToUtf16le(this);
    } else {
        return bytesToUtf16le(this.slice(offset, length));
    }
};
Buffer.prototype.ucs2Write = function ucs2Write(string, offset, length) {
    return blitBuffer(utf16leToBytes(string, this.length - offset), this, offset, length);
};
Buffer.prototype.utf8Slice = function utf8Slice(string, offset, length) {
    return _utf8Slice(this, string, offset, length);
};
Buffer.prototype.utf8Write = function utf8Write(string, offset, length) {
    return blitBuffer(utf8ToBytes(string, this.length - offset), this, offset, length);
};
Buffer.prototype.write = function write(string, offset, length, encoding) {
    if (offset === undefined) {
        return this.utf8Write(string, 0, this.length);
    }
    if (length === undefined && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
    } else {
        validateOffset(offset, "offset", 0, this.length);
        const remaining = this.length - offset;
        if (length === undefined) {
            length = remaining;
        } else if (typeof length === "string") {
            encoding = length;
            length = remaining;
        } else {
            validateOffset(length, "length", 0, this.length);
            if (length > remaining) {
                length = remaining;
            }
        }
    }
    if (!encoding) {
        return this.utf8Write(string, offset, length);
    }
    const ops = getEncodingOps(encoding);
    if (ops === undefined) {
        throw new codes.ERR_UNKNOWN_ENCODING(encoding);
    }
    return ops.write(this, string, offset, length);
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function fromArrayBuffer(obj, byteOffset, length) {
    if (byteOffset === undefined) {
        byteOffset = 0;
    } else {
        byteOffset = +byteOffset;
        if (Number.isNaN(byteOffset)) {
            byteOffset = 0;
        }
    }
    const maxLength = obj.byteLength - byteOffset;
    if (maxLength < 0) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("offset");
    }
    if (length === undefined) {
        length = maxLength;
    } else {
        length = +length;
        if (length > 0) {
            if (length > maxLength) {
                throw new codes.ERR_BUFFER_OUT_OF_BOUNDS("length");
            }
        } else {
            length = 0;
        }
    }
    const buffer = new Uint8Array(obj, byteOffset, length);
    Object.setPrototypeOf(buffer, Buffer.prototype);
    return buffer;
}
const decoder = new TextDecoder();
function _utf8Slice(buf, start, end) {
    return decoder.decode(buf.slice(start, end));
}
function _latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i){
        ret += String.fromCharCode(buf[i]);
    }
    return ret;
}
function _hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) {
        start = 0;
    }
    if (!end || end < 0 || end > len) {
        end = len;
    }
    let out = "";
    for(let i = start; i < end; ++i){
        out += hexSliceLookupTable[buf[i]];
    }
    return out;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) {
            start = 0;
        }
    } else if (start > len) {
        start = len;
    }
    if (end < 0) {
        end += len;
        if (end < 0) {
            end = 0;
        }
    } else if (end > len) {
        end = len;
    }
    if (end < start) {
        end = start;
    }
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readUInt48LE(this, offset);
    }
    if (byteLength === 5) {
        return readUInt40LE(this, offset);
    }
    if (byteLength === 3) {
        return readUInt24LE(this, offset);
    }
    if (byteLength === 4) {
        return this.readUInt32LE(offset);
    }
    if (byteLength === 2) {
        return this.readUInt16LE(offset);
    }
    if (byteLength === 1) {
        return this.readUInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readUInt48BE(this, offset);
    }
    if (byteLength === 5) {
        return readUInt40BE(this, offset);
    }
    if (byteLength === 3) {
        return readUInt24BE(this, offset);
    }
    if (byteLength === 4) {
        return this.readUInt32BE(offset);
    }
    if (byteLength === 2) {
        return this.readUInt16BE(offset);
    }
    if (byteLength === 1) {
        return this.readUInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset = 0) {
    validateNumber(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError(offset, this.length - 1);
    }
    return val;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = readUInt16BE;
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    return first + last * 2 ** 8;
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = readUInt32BE;
Buffer.prototype.readBigUint64LE = Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUint64BE = Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readInt48LE(this, offset);
    }
    if (byteLength === 5) {
        return readInt40LE(this, offset);
    }
    if (byteLength === 3) {
        return readInt24LE(this, offset);
    }
    if (byteLength === 4) {
        return this.readInt32LE(offset);
    }
    if (byteLength === 2) {
        return this.readInt16LE(offset);
    }
    if (byteLength === 1) {
        return this.readInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength) {
    if (offset === undefined) {
        throw new codes.ERR_INVALID_ARG_TYPE("offset", "number", offset);
    }
    if (byteLength === 6) {
        return readInt48BE(this, offset);
    }
    if (byteLength === 5) {
        return readInt40BE(this, offset);
    }
    if (byteLength === 3) {
        return readInt24BE(this, offset);
    }
    if (byteLength === 4) {
        return this.readInt32BE(offset);
    }
    if (byteLength === 2) {
        return this.readInt16BE(offset);
    }
    if (byteLength === 1) {
        return this.readInt8(offset);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.readInt8 = function readInt8(offset = 0) {
    validateNumber(offset, "offset");
    const val = this[offset];
    if (val === undefined) {
        boundsError(offset, this.length - 1);
    }
    return val | (val & 2 ** 7) * 0x1fffffe;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    const val = first + last * 2 ** 8;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    const val = first * 2 ** 8 + last;
    return val | (val & 2 ** 15) * 0x1fffe;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + (last << 24);
};
Buffer.prototype.readInt32BE = function readInt32BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset) {
    return bigEndian ? readFloatBackwards(this, offset) : readFloatForwards(this, offset);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset) {
    return bigEndian ? readFloatForwards(this, offset) : readFloatBackwards(this, offset);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset) {
    return bigEndian ? readDoubleBackwards(this, offset) : readDoubleForwards(this, offset);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset) {
    return bigEndian ? readDoubleForwards(this, offset) : readDoubleBackwards(this, offset);
};
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48LE(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40LE(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24LE(this, value, offset, 0, 0xffffff);
    }
    if (byteLength === 4) {
        return writeU_Int32LE(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16LE(this, value, offset, 0, 0xffff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, 0, 0xff);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48BE(this, value, offset, 0, 0xffffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40BE(this, value, offset, 0, 0xffffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24BE(this, value, offset, 0, 0xffffff);
    }
    if (byteLength === 4) {
        return writeU_Int32BE(this, value, offset, 0, 0xffffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16BE(this, value, offset, 0, 0xffff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, 0, 0xff);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset = 0) {
    return writeU_Int8(this, value, offset, 0, 0xff);
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset = 0) {
    return writeU_Int16LE(this, value, offset, 0, 0xffff);
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset = 0) {
    return writeU_Int16BE(this, value, offset, 0, 0xffff);
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset = 0) {
    return _writeUInt32LE(this, value, offset, 0, 0xffffffff);
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset = 0) {
    return _writeUInt32BE(this, value, offset, 0, 0xffffffff);
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUint64LE = Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeBigUint64BE = Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48LE(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40LE(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24LE(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength === 4) {
        return writeU_Int32LE(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16LE(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, -0x80, 0x7f);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength) {
    if (byteLength === 6) {
        return writeU_Int48BE(this, value, offset, -0x800000000000, 0x7fffffffffff);
    }
    if (byteLength === 5) {
        return writeU_Int40BE(this, value, offset, -0x8000000000, 0x7fffffffff);
    }
    if (byteLength === 3) {
        return writeU_Int24BE(this, value, offset, -0x800000, 0x7fffff);
    }
    if (byteLength === 4) {
        return writeU_Int32BE(this, value, offset, -0x80000000, 0x7fffffff);
    }
    if (byteLength === 2) {
        return writeU_Int16BE(this, value, offset, -0x8000, 0x7fff);
    }
    if (byteLength === 1) {
        return writeU_Int8(this, value, offset, -0x80, 0x7f);
    }
    boundsError(byteLength, 6, "byteLength");
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset = 0) {
    return writeU_Int8(this, value, offset, -0x80, 0x7f);
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset = 0) {
    return writeU_Int16LE(this, value, offset, -0x8000, 0x7fff);
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset = 0) {
    return writeU_Int16BE(this, value, offset, -0x8000, 0x7fff);
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset = 0) {
    return writeU_Int32LE(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset = 0) {
    return writeU_Int32BE(this, value, offset, -0x80000000, 0x7fffffff);
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
});
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset) {
    return bigEndian ? writeFloatBackwards(this, value, offset) : writeFloatForwards(this, value, offset);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset) {
    return bigEndian ? writeFloatForwards(this, value, offset) : writeFloatBackwards(this, value, offset);
};
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset) {
    return bigEndian ? writeDoubleBackwards(this, value, offset) : writeDoubleForwards(this, value, offset);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset) {
    return bigEndian ? writeDoubleForwards(this, value, offset) : writeDoubleBackwards(this, value, offset);
};
Buffer.prototype.copy = function copy(target, targetStart, sourceStart, sourceEnd) {
    if (!isUint8Array(this)) {
        throw new codes.ERR_INVALID_ARG_TYPE("source", [
            "Buffer",
            "Uint8Array"
        ], this);
    }
    if (!isUint8Array(target)) {
        throw new codes.ERR_INVALID_ARG_TYPE("target", [
            "Buffer",
            "Uint8Array"
        ], target);
    }
    if (targetStart === undefined) {
        targetStart = 0;
    } else {
        targetStart = toInteger(targetStart, 0);
        if (targetStart < 0) {
            throw new codes.ERR_OUT_OF_RANGE("targetStart", ">= 0", targetStart);
        }
    }
    if (sourceStart === undefined) {
        sourceStart = 0;
    } else {
        sourceStart = toInteger(sourceStart, 0);
        if (sourceStart < 0) {
            throw new codes.ERR_OUT_OF_RANGE("sourceStart", ">= 0", sourceStart);
        }
        if (sourceStart >= MAX_UINT32) {
            throw new codes.ERR_OUT_OF_RANGE("sourceStart", `< ${MAX_UINT32}`, sourceStart);
        }
    }
    if (sourceEnd === undefined) {
        sourceEnd = this.length;
    } else {
        sourceEnd = toInteger(sourceEnd, 0);
        if (sourceEnd < 0) {
            throw new codes.ERR_OUT_OF_RANGE("sourceEnd", ">= 0", sourceEnd);
        }
        if (sourceEnd >= MAX_UINT32) {
            throw new codes.ERR_OUT_OF_RANGE("sourceEnd", `< ${MAX_UINT32}`, sourceEnd);
        }
    }
    if (targetStart >= target.length) {
        return 0;
    }
    if (sourceEnd > 0 && sourceEnd < sourceStart) {
        sourceEnd = sourceStart;
    }
    if (sourceEnd === sourceStart) {
        return 0;
    }
    if (target.length === 0 || this.length === 0) {
        return 0;
    }
    if (sourceEnd > this.length) {
        sourceEnd = this.length;
    }
    if (target.length - targetStart < sourceEnd - sourceStart) {
        sourceEnd = target.length - targetStart + sourceStart;
    }
    const len = sourceEnd - sourceStart;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, sourceStart, sourceEnd);
    } else {
        Uint8Array.prototype.set.call(target, this.subarray(sourceStart, sourceEnd), targetStart);
    }
    return len;
};
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
        if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
                val = code;
            }
        }
    } else if (typeof val === "number") {
        val = val & 255;
    } else if (typeof val === "boolean") {
        val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
    }
    if (end <= start) {
        return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) {
        val = 0;
    }
    let i;
    if (typeof val === "number") {
        for(i = start; i < end; ++i){
            this[i] = val;
        }
    } else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
            throw new codes.ERR_INVALID_ARG_VALUE("value", val);
        }
        for(i = 0; i < end - start; ++i){
            this[i + start] = bytes[i % len];
        }
    }
    return this;
};
function checkBounds(buf, offset, byteLength2) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
    }
}
function checkIntBI(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new codes.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength2);
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
                if (codePoint > 56319) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                } else if (i + 1 === length) {
                    if ((units -= 3) > -1) {
                        bytes.push(239, 191, 189);
                    }
                    continue;
                }
                leadSurrogate = codePoint;
                continue;
            }
            if (codePoint < 56320) {
                if ((units -= 3) > -1) {
                    bytes.push(239, 191, 189);
                }
                leadSurrogate = codePoint;
                continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
            if ((units -= 3) > -1) {
                bytes.push(239, 191, 189);
            }
        }
        leadSurrogate = null;
        if (codePoint < 128) {
            if ((units -= 1) < 0) {
                break;
            }
            bytes.push(codePoint);
        } else if (codePoint < 2048) {
            if ((units -= 2) < 0) {
                break;
            }
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
            if ((units -= 3) < 0) {
                break;
            }
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) {
                break;
            }
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
            throw new Error("Invalid code point");
        }
    }
    return bytes;
}
function blitBuffer(src, dst, offset, byteLength) {
    let i;
    const length = byteLength === undefined ? src.length : byteLength;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) {
            break;
        }
        dst[i + offset] = src[i];
    }
    return i;
}
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j){
            table[i16 + j] = alphabet[i] + alphabet[j];
        }
    }
    return table;
}();
function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
}
const atob1 = globalThis.atob;
const Blob1 = globalThis.Blob;
const btoa = globalThis.btoa;
function readUInt48LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + (buf[++offset] + last * 2 ** 8) * 2 ** 32;
}
function readUInt40LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24 + last * 2 ** 32;
}
function readUInt24LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
}
function readUInt48BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt40BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return first * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt24BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readUInt16BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 1];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 2);
    }
    return first * 2 ** 8 + last;
}
function readUInt32BE(offset = 0) {
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 4);
    }
    return first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
}
function readDoubleBackwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 8);
    }
    uInt8Float64Array[7] = first;
    uInt8Float64Array[6] = buffer[++offset];
    uInt8Float64Array[5] = buffer[++offset];
    uInt8Float64Array[4] = buffer[++offset];
    uInt8Float64Array[3] = buffer[++offset];
    uInt8Float64Array[2] = buffer[++offset];
    uInt8Float64Array[1] = buffer[++offset];
    uInt8Float64Array[0] = last;
    return float64Array[0];
}
function readDoubleForwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 8);
    }
    uInt8Float64Array[0] = first;
    uInt8Float64Array[1] = buffer[++offset];
    uInt8Float64Array[2] = buffer[++offset];
    uInt8Float64Array[3] = buffer[++offset];
    uInt8Float64Array[4] = buffer[++offset];
    uInt8Float64Array[5] = buffer[++offset];
    uInt8Float64Array[6] = buffer[++offset];
    uInt8Float64Array[7] = last;
    return float64Array[0];
}
function writeDoubleForwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 7);
    float64Array[0] = val;
    buffer[offset++] = uInt8Float64Array[0];
    buffer[offset++] = uInt8Float64Array[1];
    buffer[offset++] = uInt8Float64Array[2];
    buffer[offset++] = uInt8Float64Array[3];
    buffer[offset++] = uInt8Float64Array[4];
    buffer[offset++] = uInt8Float64Array[5];
    buffer[offset++] = uInt8Float64Array[6];
    buffer[offset++] = uInt8Float64Array[7];
    return offset;
}
function writeDoubleBackwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 7);
    float64Array[0] = val;
    buffer[offset++] = uInt8Float64Array[7];
    buffer[offset++] = uInt8Float64Array[6];
    buffer[offset++] = uInt8Float64Array[5];
    buffer[offset++] = uInt8Float64Array[4];
    buffer[offset++] = uInt8Float64Array[3];
    buffer[offset++] = uInt8Float64Array[2];
    buffer[offset++] = uInt8Float64Array[1];
    buffer[offset++] = uInt8Float64Array[0];
    return offset;
}
function readFloatBackwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 4);
    }
    uInt8Float32Array[3] = first;
    uInt8Float32Array[2] = buffer[++offset];
    uInt8Float32Array[1] = buffer[++offset];
    uInt8Float32Array[0] = last;
    return float32Array[0];
}
function readFloatForwards(buffer, offset = 0) {
    validateNumber(offset, "offset");
    const first = buffer[offset];
    const last = buffer[offset + 3];
    if (first === undefined || last === undefined) {
        boundsError(offset, buffer.length - 4);
    }
    uInt8Float32Array[0] = first;
    uInt8Float32Array[1] = buffer[++offset];
    uInt8Float32Array[2] = buffer[++offset];
    uInt8Float32Array[3] = last;
    return float32Array[0];
}
function writeFloatForwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 3);
    float32Array[0] = val;
    buffer[offset++] = uInt8Float32Array[0];
    buffer[offset++] = uInt8Float32Array[1];
    buffer[offset++] = uInt8Float32Array[2];
    buffer[offset++] = uInt8Float32Array[3];
    return offset;
}
function writeFloatBackwards(buffer, val, offset = 0) {
    val = +val;
    checkBounds(buffer, offset, 3);
    float32Array[0] = val;
    buffer[offset++] = uInt8Float32Array[3];
    buffer[offset++] = uInt8Float32Array[2];
    buffer[offset++] = uInt8Float32Array[1];
    buffer[offset++] = uInt8Float32Array[0];
    return offset;
}
function readInt24LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt40LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return (last | (last & 2 ** 7) * 0x1fffffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt48LE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    const val = buf[offset + 4] + last * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + first + buf[++offset] * 2 ** 8 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 24;
}
function readInt24BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 2];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 3);
    }
    const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
    return val | (val & 2 ** 23) * 0x1fe;
}
function readInt48BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 5];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 6);
    }
    const val = buf[++offset] + first * 2 ** 8;
    return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function readInt40BE(buf, offset = 0) {
    validateNumber(offset, "offset");
    const first = buf[offset];
    const last = buf[offset + 4];
    if (first === undefined || last === undefined) {
        boundsError(offset, buf.length - 5);
    }
    return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 + buf[++offset] * 2 ** 24 + buf[++offset] * 2 ** 16 + buf[++offset] * 2 ** 8 + last;
}
function byteLengthUtf8(str) {
    return utf8Encoder.encode(str).length;
}
function base64ByteLength(str, bytes) {
    if (str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    if (bytes > 1 && str.charCodeAt(bytes - 1) === 0x3D) {
        bytes--;
    }
    return bytes * 3 >>> 2;
}
const encodingsMap = Object.create(null);
for(let i = 0; i < encodings.length; ++i){
    encodingsMap[encodings[i]] = i;
}
const encodingOps = {
    ascii: {
        byteLength: (string)=>string.length,
        encoding: "ascii",
        encodingVal: encodingsMap.ascii,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.ascii, dir),
        slice: (buf, start, end)=>buf.asciiSlice(start, end),
        write: (buf, string, offset, len)=>buf.asciiWrite(string, offset, len)
    },
    base64: {
        byteLength: (string)=>base64ByteLength(string, string.length),
        encoding: "base64",
        encodingVal: encodingsMap.base64,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, base64ToBytes(val), byteOffset, encodingsMap.base64, dir),
        slice: (buf, start, end)=>buf.base64Slice(start, end),
        write: (buf, string, offset, len)=>buf.base64Write(string, offset, len)
    },
    base64url: {
        byteLength: (string)=>base64ByteLength(string, string.length),
        encoding: "base64url",
        encodingVal: encodingsMap.base64url,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, base64UrlToBytes(val), byteOffset, encodingsMap.base64url, dir),
        slice: (buf, start, end)=>buf.base64urlSlice(start, end),
        write: (buf, string, offset, len)=>buf.base64urlWrite(string, offset, len)
    },
    hex: {
        byteLength: (string)=>string.length >>> 1,
        encoding: "hex",
        encodingVal: encodingsMap.hex,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, hexToBytes(val), byteOffset, encodingsMap.hex, dir),
        slice: (buf, start, end)=>buf.hexSlice(start, end),
        write: (buf, string, offset, len)=>buf.hexWrite(string, offset, len)
    },
    latin1: {
        byteLength: (string)=>string.length,
        encoding: "latin1",
        encodingVal: encodingsMap.latin1,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, asciiToBytes(val), byteOffset, encodingsMap.latin1, dir),
        slice: (buf, start, end)=>buf.latin1Slice(start, end),
        write: (buf, string, offset, len)=>buf.latin1Write(string, offset, len)
    },
    ucs2: {
        byteLength: (string)=>string.length * 2,
        encoding: "ucs2",
        encodingVal: encodingsMap.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir),
        slice: (buf, start, end)=>buf.ucs2Slice(start, end),
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    },
    utf8: {
        byteLength: byteLengthUtf8,
        encoding: "utf8",
        encodingVal: encodingsMap.utf8,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf8Encoder.encode(val), byteOffset, encodingsMap.utf8, dir),
        slice: (buf, start, end)=>buf.utf8Slice(start, end),
        write: (buf, string, offset, len)=>buf.utf8Write(string, offset, len)
    },
    utf16le: {
        byteLength: (string)=>string.length * 2,
        encoding: "utf16le",
        encodingVal: encodingsMap.utf16le,
        indexOf: (buf, val, byteOffset, dir)=>indexOfBuffer(buf, utf16leToBytes(val), byteOffset, encodingsMap.utf16le, dir),
        slice: (buf, start, end)=>buf.ucs2Slice(start, end),
        write: (buf, string, offset, len)=>buf.ucs2Write(string, offset, len)
    }
};
function getEncodingOps(encoding) {
    encoding = String(encoding).toLowerCase();
    switch(encoding.length){
        case 4:
            if (encoding === "utf8") return encodingOps.utf8;
            if (encoding === "ucs2") return encodingOps.ucs2;
            break;
        case 5:
            if (encoding === "utf-8") return encodingOps.utf8;
            if (encoding === "ascii") return encodingOps.ascii;
            if (encoding === "ucs-2") return encodingOps.ucs2;
            break;
        case 7:
            if (encoding === "utf16le") {
                return encodingOps.utf16le;
            }
            break;
        case 8:
            if (encoding === "utf-16le") {
                return encodingOps.utf16le;
            }
            break;
        case 6:
            if (encoding === "latin1" || encoding === "binary") {
                return encodingOps.latin1;
            }
            if (encoding === "base64") return encodingOps.base64;
        case 3:
            if (encoding === "hex") {
                return encodingOps.hex;
            }
            break;
        case 9:
            if (encoding === "base64url") {
                return encodingOps.base64url;
            }
            break;
    }
}
function _copyActual(source, target, targetStart, sourceStart, sourceEnd) {
    if (sourceEnd - sourceStart > target.length - targetStart) {
        sourceEnd = sourceStart + target.length - targetStart;
    }
    let nb = sourceEnd - sourceStart;
    const sourceLen = source.length - sourceStart;
    if (nb > sourceLen) {
        nb = sourceLen;
    }
    if (sourceStart !== 0 || sourceEnd < source.length) {
        source = new Uint8Array(source.buffer, source.byteOffset + sourceStart, nb);
    }
    target.set(source, targetStart);
    return nb;
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new codes.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length < 0) {
        throw new codes.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new codes.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length}`, value);
}
function validateNumber(value, name) {
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
}
function checkInt(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === 0n) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and ` + `< 2${n} ** ${(byteLength + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new codes.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function toInteger(n, defaultVal) {
    n = +n;
    if (!Number.isNaN(n) && n >= Number.MIN_SAFE_INTEGER && n <= Number.MAX_SAFE_INTEGER) {
        return n % 1 === 0 ? n : Math.floor(n);
    }
    return defaultVal;
}
function writeU_Int8(buf, value, offset, min, max) {
    value = +value;
    validateNumber(offset, "offset");
    if (value > max || value < min) {
        throw new codes.ERR_OUT_OF_RANGE("value", `>= ${min} and <= ${max}`, value);
    }
    if (buf[offset] === undefined) {
        boundsError(offset, buf.length - 1);
    }
    buf[offset] = value;
    return offset + 1;
}
function writeU_Int16BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 1);
    buf[offset++] = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function _writeUInt32LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int16LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 1);
    buf[offset++] = value;
    buf[offset++] = value >>> 8;
    return offset;
}
function _writeUInt32BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int48BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = newVal >>> 8;
    buf[offset++] = newVal;
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int40BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 4);
    buf[offset++] = Math.floor(value * 2 ** -32);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int32BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset + 3] = value;
    value = value >>> 8;
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 4;
}
function writeU_Int24BE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 2);
    buf[offset + 2] = value;
    value = value >>> 8;
    buf[offset + 1] = value;
    value = value >>> 8;
    buf[offset] = value;
    return offset + 3;
}
function validateOffset(value, name, min = 0, max = Number.MAX_SAFE_INTEGER) {
    if (typeof value !== "number") {
        throw new codes.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
    if (!Number.isInteger(value)) {
        throw new codes.ERR_OUT_OF_RANGE(name, "an integer", value);
    }
    if (value < min || value > max) {
        throw new codes.ERR_OUT_OF_RANGE(name, `>= ${min} && <= ${max}`, value);
    }
}
function writeU_Int48LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 5);
    const newVal = Math.floor(value * 2 ** -32);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = newVal;
    buf[offset++] = newVal >>> 8;
    return offset;
}
function writeU_Int40LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 4);
    const newVal = value;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    buf[offset++] = Math.floor(newVal * 2 ** -32);
    return offset;
}
function writeU_Int32LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 3);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
function writeU_Int24LE(buf, value, offset, min, max) {
    value = +value;
    checkInt(value, min, max, buf, offset, 2);
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    value = value >>> 8;
    buf[offset++] = value;
    return offset;
}
const __default3 = {
    atob: atob1,
    btoa,
    Blob: Blob1,
    Buffer,
    constants,
    kMaxLength: 2147483647,
    kStringMaxLength: 536870888,
    SlowBuffer
};
function timingSafeEqual(a, b) {
    if (a.byteLength !== b.byteLength) {
        return false;
    }
    if (!(a instanceof DataView)) {
        a = new DataView(ArrayBuffer.isView(a) ? a.buffer : a);
    }
    if (!(b instanceof DataView)) {
        b = new DataView(ArrayBuffer.isView(b) ? b.buffer : b);
    }
    assert1(a instanceof DataView);
    assert1(b instanceof DataView);
    const length = a.byteLength;
    let out = 0;
    let i = -1;
    while(++i < length){
        out |= a.getUint8(i) ^ b.getUint8(i);
    }
    return out === 0;
}
const timingSafeEqual1 = (a, b)=>{
    if (a instanceof Buffer) a = new DataView(a.buffer);
    if (a instanceof Buffer) b = new DataView(a.buffer);
    return timingSafeEqual(a, b);
};
function getFipsCrypto() {
    notImplemented("crypto.getFipsCrypto");
}
function setFipsCrypto(_fips) {
    notImplemented("crypto.setFipsCrypto");
}
const mod9 = {
    timingSafeEqual: timingSafeEqual1,
    getFipsCrypto: getFipsCrypto,
    setFipsCrypto: setFipsCrypto
};
const MAX_RANDOM_VALUES = 65536;
function generateRandomBytes(size) {
    if (size > 4294967295) {
        throw new RangeError(`The value of "size" is out of range. It must be >= 0 && <= ${4294967295}. Received ${size}`);
    }
    const bytes = Buffer.allocUnsafe(size);
    if (size > 65536) {
        for(let generated = 0; generated < size; generated += MAX_RANDOM_VALUES){
            globalThis.crypto.getRandomValues(bytes.slice(generated, generated + 65536));
        }
    } else {
        globalThis.crypto.getRandomValues(bytes);
    }
    return bytes;
}
function randomBytes(size, cb) {
    if (typeof cb === "function") {
        let err = null, bytes;
        try {
            bytes = generateRandomBytes(size);
        } catch (e) {
            if (e instanceof RangeError && e.message.includes('The value of "size" is out of range')) {
                throw e;
            } else if (e instanceof Error) {
                err = e;
            } else {
                err = new Error("[non-error thrown]");
            }
        }
        setTimeout(()=>{
            if (err) {
                cb(err);
            } else {
                cb(null, bytes);
            }
        }, 0);
    } else {
        return generateRandomBytes(size);
    }
}
function assertOffset(offset, length) {
    if (offset > 4294967295 || offset < 0) {
        throw new TypeError("offset must be a uint32");
    }
    if (offset > 0x7fffffff || offset > length) {
        throw new RangeError("offset out of range");
    }
}
function assertSize1(size, offset, length) {
    if (size > 4294967295 || size < 0) {
        throw new TypeError("size must be a uint32");
    }
    if (size + offset > length || size > 0x7fffffff) {
        throw new RangeError("buffer too small");
    }
}
function randomFill(buf, offset, size, cb) {
    if (typeof offset === "function") {
        cb = offset;
        offset = 0;
        size = buf.length;
    } else if (typeof size === "function") {
        cb = size;
        size = buf.length - Number(offset);
    }
    assertOffset(offset, buf.length);
    assertSize1(size, offset, buf.length);
    randomBytes(size, (err, bytes)=>{
        if (err) return cb(err, buf);
        bytes?.copy(buf, offset);
        cb(null, buf);
    });
}
function randomFillSync(buf, offset = 0, size) {
    assertOffset(offset, buf.length);
    if (size === undefined) size = buf.length - offset;
    assertSize1(size, offset, buf.length);
    const bytes = randomBytes(size);
    bytes.copy(buf, offset);
    return buf;
}
function randomInt(max, min, cb) {
    if (typeof max === "number" && typeof min === "number") {
        [max, min] = [
            min,
            max
        ];
    }
    if (min === undefined) min = 0;
    else if (typeof min === "function") {
        cb = min;
        min = 0;
    }
    if (!Number.isSafeInteger(min) || typeof max === "number" && !Number.isSafeInteger(max)) {
        throw new Error("max or min is not a Safe Number");
    }
    if (max - min > Math.pow(2, 48)) {
        throw new RangeError("max - min should be less than 2^48!");
    }
    if (min >= max) {
        throw new Error("Min is bigger than Max!");
    }
    const randomBuffer = new Uint32Array(1);
    globalThis.crypto.getRandomValues(randomBuffer);
    const randomNumber = randomBuffer[0] / (0xffffffff + 1);
    min = Math.ceil(min);
    max = Math.floor(max);
    const result = Math.floor(randomNumber * (max - min)) + min;
    if (cb) {
        cb(null, result);
        return;
    }
    return result;
}
function checkPrime(_candidate, _options, _callback) {
    notImplemented("crypto.checkPrime");
}
function checkPrimeSync(_candidate, _options) {
    notImplemented("crypto.checkPrimeSync");
}
function generatePrime(_size, _options, _callback) {
    notImplemented("crypto.generatePrime");
}
function generatePrimeSync(_size, _options) {
    notImplemented("crypto.generatePrimeSync");
}
const randomUUID = ()=>globalThis.crypto.randomUUID();
let wasm;
const heap = new Array(32).fill(undefined);
heap.push(undefined, null, true, false);
function getObject(idx) {
    return heap[idx];
}
let heap_next = heap.length;
function dropObject(idx) {
    if (idx < 36) return;
    heap[idx] = heap_next;
    heap_next = idx;
}
function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}
function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];
    heap[idx] = obj;
    return idx;
}
const cachedTextDecoder = new TextDecoder("utf-8", {
    ignoreBOM: true,
    fatal: true
});
cachedTextDecoder.decode();
let cachedUint8Memory0 = new Uint8Array();
function getUint8Memory0() {
    if (cachedUint8Memory0.byteLength === 0) {
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
let WASM_VECTOR_LEN = 0;
const cachedTextEncoder = new TextEncoder("utf-8");
const encodeString = function(arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
};
function passStringToWasm0(arg, malloc, realloc) {
    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length);
        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }
    let len = arg.length;
    let ptr = malloc(len);
    const mem = getUint8Memory0();
    let offset = 0;
    for(; offset < len; offset++){
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr + offset] = code;
    }
    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3);
        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);
        offset += ret.written;
    }
    WASM_VECTOR_LEN = offset;
    return ptr;
}
function isLikeNone(x) {
    return x === undefined || x === null;
}
let cachedInt32Memory0 = new Int32Array();
function getInt32Memory0() {
    if (cachedInt32Memory0.byteLength === 0) {
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachedInt32Memory0;
}
function getArrayU8FromWasm0(ptr, len) {
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
function digest(algorithm, data, length) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        const ptr0 = passStringToWasm0(algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        wasm.digest(retptr, ptr0, len0, addHeapObject(data), !isLikeNone(length), isLikeNone(length) ? 0 : length);
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        var r2 = getInt32Memory0()[retptr / 4 + 2];
        var r3 = getInt32Memory0()[retptr / 4 + 3];
        if (r3) {
            throw takeObject(r2);
        }
        var v1 = getArrayU8FromWasm0(r0, r1).slice();
        wasm.__wbindgen_free(r0, r1 * 1);
        return v1;
    } finally{
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}
const DigestContextFinalization = new FinalizationRegistry((ptr)=>wasm.__wbg_digestcontext_free(ptr));
class DigestContext {
    static __wrap(ptr) {
        const obj = Object.create(DigestContext.prototype);
        obj.ptr = ptr;
        DigestContextFinalization.register(obj, obj.ptr, obj);
        return obj;
    }
    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DigestContextFinalization.unregister(this);
        return ptr;
    }
    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_digestcontext_free(ptr);
    }
    constructor(algorithm){
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(algorithm, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.digestcontext_new(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DigestContext.__wrap(r0);
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    update(data) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_update(retptr, this.ptr, addHeapObject(data));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    digest(length) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_digest(retptr, this.ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    digestAndReset(length) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_digestAndReset(retptr, this.ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    digestAndDrop(length) {
        try {
            const ptr = this.__destroy_into_raw();
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_digestAndDrop(retptr, ptr, !isLikeNone(length), isLikeNone(length) ? 0 : length);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    reset() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.digestcontext_reset(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            if (r1) {
                throw takeObject(r0);
            }
        } finally{
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    clone() {
        const ret = wasm.digestcontext_clone(this.ptr);
        return DigestContext.__wrap(ret);
    }
}
const imports = {
    __wbindgen_placeholder__: {
        __wbg_new_db254ae0a1bb0ff5: function(arg0, arg1) {
            const ret = new TypeError(getStringFromWasm0(arg0, arg1));
            return addHeapObject(ret);
        },
        __wbindgen_object_drop_ref: function(arg0) {
            takeObject(arg0);
        },
        __wbg_byteLength_87a0436a74adc26c: function(arg0) {
            const ret = getObject(arg0).byteLength;
            return ret;
        },
        __wbg_byteOffset_4477d54710af6f9b: function(arg0) {
            const ret = getObject(arg0).byteOffset;
            return ret;
        },
        __wbg_buffer_21310ea17257b0b4: function(arg0) {
            const ret = getObject(arg0).buffer;
            return addHeapObject(ret);
        },
        __wbg_newwithbyteoffsetandlength_d9aa266703cb98be: function(arg0, arg1, arg2) {
            const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
            return addHeapObject(ret);
        },
        __wbg_length_9e1ae1900cb0fbd5: function(arg0) {
            const ret = getObject(arg0).length;
            return ret;
        },
        __wbindgen_memory: function() {
            const ret = wasm.memory;
            return addHeapObject(ret);
        },
        __wbg_buffer_3f3d764d4747d564: function(arg0) {
            const ret = getObject(arg0).buffer;
            return addHeapObject(ret);
        },
        __wbg_new_8c3f0052272a457a: function(arg0) {
            const ret = new Uint8Array(getObject(arg0));
            return addHeapObject(ret);
        },
        __wbg_set_83db9690f9353e79: function(arg0, arg1, arg2) {
            getObject(arg0).set(getObject(arg1), arg2 >>> 0);
        },
        __wbindgen_throw: function(arg0, arg1) {
            throw new Error(getStringFromWasm0(arg0, arg1));
        }
    }
};
function instantiate() {
    return instantiateWithInstance().exports;
}
let instanceWithExports;
function instantiateWithInstance() {
    if (instanceWithExports == null) {
        const instance = instantiateInstance();
        wasm = instance.exports;
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
        instanceWithExports = {
            instance,
            exports: {
                digest,
                DigestContext
            }
        };
    }
    return instanceWithExports;
}
function instantiateInstance() {
    const wasmBytes = base64decode("\
AGFzbQEAAAABrIGAgAAZYAAAYAABf2ABfwBgAX8Bf2ABfwF+YAJ/fwBgAn9/AX9gA39/fwBgA39/fw\
F/YAR/f39/AGAEf39/fwF/YAV/f39/fwBgBX9/f39/AX9gBn9/f39/fwBgBn9/f39/fwF/YAV/f39+\
fwBgB39/f35/f38Bf2ADf39+AGAFf39+f38AYAV/f31/fwBgBX9/fH9/AGACf34AYAR/fn9/AGAEf3\
1/fwBgBH98f38AAqSFgIAADBhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18aX193YmdfbmV3X2RiMjU0\
YWUwYTFiYjBmZjUABhhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18aX193YmluZGdlbl9vYmplY3RfZH\
JvcF9yZWYAAhhfX3diaW5kZ2VuX3BsYWNlaG9sZGVyX18hX193YmdfYnl0ZUxlbmd0aF84N2EwNDM2\
YTc0YWRjMjZjAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fIV9fd2JnX2J5dGVPZmZzZXRfNDQ3N2\
Q1NDcxMGFmNmY5YgADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXx1fX3diZ19idWZmZXJfMjEzMTBl\
YTE3MjU3YjBiNAADGF9fd2JpbmRnZW5fcGxhY2Vob2xkZXJfXzFfX3diZ19uZXd3aXRoYnl0ZW9mZn\
NldGFuZGxlbmd0aF9kOWFhMjY2NzAzY2I5OGJlAAgYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9f\
d2JnX2xlbmd0aF85ZTFhZTE5MDBjYjBmYmQ1AAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fEV9fd2\
JpbmRnZW5fbWVtb3J5AAEYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fHV9fd2JnX2J1ZmZlcl8zZjNk\
NzY0ZDQ3NDdkNTY0AAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX25ld184YzNmMDA1Mj\
I3MmE0NTdhAAMYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fGl9fd2JnX3NldF84M2RiOTY5MGY5MzUz\
ZTc5AAcYX193YmluZGdlbl9wbGFjZWhvbGRlcl9fEF9fd2JpbmRnZW5fdGhyb3cABQOPgYCAAI0BCw\
cLBwMJEQUHBwUHDwMHBQgFEAUHBQIHBQIGBwYHFQgHDgcHBwYBAQEBBwgHBwcBBwcHAQgHBwcHBwUC\
BwcHBwcBAQcHBQ0IBwkHCQEBAQEBBQkNCwkFBQUFBQUGBgcHBwcCAggHBwUCCgAFAgMCAg4MCwwLCx\
MUEgkICAYGBQcHAAYDAAAFCAgIBAACBIWAgIAAAXABFRUFg4CAgAABABEGiYCAgAABfwFBgIDAAAsH\
uYKAgAAOBm1lbW9yeQIABmRpZ2VzdABSGF9fd2JnX2RpZ2VzdGNvbnRleHRfZnJlZQBuEWRpZ2VzdG\
NvbnRleHRfbmV3AFYUZGlnZXN0Y29udGV4dF91cGRhdGUAcRRkaWdlc3Rjb250ZXh0X2RpZ2VzdABV\
HGRpZ2VzdGNvbnRleHRfZGlnZXN0QW5kUmVzZXQAVxtkaWdlc3Rjb250ZXh0X2RpZ2VzdEFuZERyb3\
AAXhNkaWdlc3Rjb250ZXh0X3Jlc2V0ACETZGlnZXN0Y29udGV4dF9jbG9uZQAQH19fd2JpbmRnZW5f\
YWRkX3RvX3N0YWNrX3BvaW50ZXIAjwERX193YmluZGdlbl9tYWxsb2MAeRJfX3diaW5kZ2VuX3JlYW\
xsb2MAhgEPX193YmluZGdlbl9mcmVlAIoBCaaAgIAAAQBBAQsUiAGJASiOAX1ffn98hwGFAYABgQGC\
AYMBhAGYAWlolgEK//KIgACNAYZ2AhF/An4jAEHAKGsiBSQAAkACQAJAAkACQAJAAkACQAJAAkACQA\
JAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABDhgAAQIDBAUGBwgJCgsMDQ4PEBES\
ExQVFhcAC0HQARAZIgZFDRggBUHQE2pBOGogAkE4aikDADcDACAFQdATakEwaiACQTBqKQMANwMAIA\
VB0BNqQShqIAJBKGopAwA3AwAgBUHQE2pBIGogAkEgaikDADcDACAFQdATakEYaiACQRhqKQMANwMA\
IAVB0BNqQRBqIAJBEGopAwA3AwAgBUHQE2pBCGogAkEIaikDADcDACAFIAIpAwA3A9ATIAIpA0AhFi\
AFQdATakHIAGogAkHIAGoQYiAFIBY3A5AUIAYgBUHQE2pB0AEQlAEaDBcLQdABEBkiBkUNFyAFQdAT\
akE4aiACQThqKQMANwMAIAVB0BNqQTBqIAJBMGopAwA3AwAgBUHQE2pBKGogAkEoaikDADcDACAFQd\
ATakEgaiACQSBqKQMANwMAIAVB0BNqQRhqIAJBGGopAwA3AwAgBUHQE2pBEGogAkEQaikDADcDACAF\
QdATakEIaiACQQhqKQMANwMAIAUgAikDADcD0BMgAikDQCEWIAVB0BNqQcgAaiACQcgAahBiIAUgFj\
cDkBQgBiAFQdATakHQARCUARoMFgtB0AEQGSIGRQ0WIAVB0BNqQThqIAJBOGopAwA3AwAgBUHQE2pB\
MGogAkEwaikDADcDACAFQdATakEoaiACQShqKQMANwMAIAVB0BNqQSBqIAJBIGopAwA3AwAgBUHQE2\
pBGGogAkEYaikDADcDACAFQdATakEQaiACQRBqKQMANwMAIAVB0BNqQQhqIAJBCGopAwA3AwAgBSAC\
KQMANwPQEyACKQNAIRYgBUHQE2pByABqIAJByABqEGIgBSAWNwOQFCAGIAVB0BNqQdABEJQBGgwVC0\
HwABAZIgZFDRUgBUHQE2pBIGogAkEgaikDADcDACAFQdATakEYaiACQRhqKQMANwMAIAVB0BNqQRBq\
IAJBEGopAwA3AwAgBSACKQMINwPYEyACKQMAIRYgBUHQE2pBKGogAkEoahBRIAUgFjcD0BMgBiAFQd\
ATakHwABCUARoMFAtB+A4QGSIGRQ0UIAVB0BNqQYgBaiACQYgBaikDADcDACAFQdATakGAAWogAkGA\
AWopAwA3AwAgBUHQE2pB+ABqIAJB+ABqKQMANwMAIAVB0BNqQRBqIAJBEGopAwA3AwAgBUHQE2pBGG\
ogAkEYaikDADcDACAFQdATakEgaiACQSBqKQMANwMAIAVB0BNqQTBqIAJBMGopAwA3AwAgBUHQE2pB\
OGogAkE4aikDADcDACAFQdATakHAAGogAkHAAGopAwA3AwAgBUHQE2pByABqIAJByABqKQMANwMAIA\
VB0BNqQdAAaiACQdAAaikDADcDACAFQdATakHYAGogAkHYAGopAwA3AwAgBUHQE2pB4ABqIAJB4ABq\
KQMANwMAIAUgAikDcDcDwBQgBSACKQMINwPYEyAFIAIpAyg3A/gTIAIpAwAhFkEAIQcgBUEANgLgFC\
ACKAKQASIIQf///z9xIglBNyAJQTdJGyEKIAJBlAFqIgkgCEEFdCILaiEMIAVBxCJqIQ0gAi0AaiEO\
IAItAGkhDyACLQBoIRACQANAIAsgB0YNASAFQdATaiAHakGUAWoiAiAJKQAANwAAIAJBGGogCUEYai\
kAADcAACACQRBqIAlBEGopAAA3AAAgAkEIaiAJQQhqKQAANwAAIAlBIGoiCCAMRg0BIAJBIGogCCkA\
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\
GGoiDCAEQdATakEcaikCADcDACAEQfgmakEQaiILIARB0BNqQRRqKQIANwMAIARB+CZqQQhqIg0gBE\
HQE2pBDGopAgA3AwAgBCAEKQLUEzcD+CYgBEHQE2ogBEHQARCUARogBCAEKQOQFCAEQZgVai0AACIC\
rXw3A5AUIARBmBRqIQECQCACQYABRg0AIAEgAmpBAEGAASACaxCTARoLIARBADoAmBUgBEHQE2ogAU\
J/EBIgBEH4DmpBCGoiAiAEQdATakEIaikDADcDACAEQfgOakEQaiIBIARB0BNqQRBqKQMANwMAIARB\
+A5qQRhqIgogBEHQE2pBGGopAwA3AwAgBEH4DmpBIGoiDiAEKQPwEzcDACAEQfgOakEoaiIPIARB0B\
NqQShqKQMANwMAIARB+A5qQTBqIhAgBEHQE2pBMGopAwA3AwAgBEH4DmpBOGoiESAEQdATakE4aikD\
ADcDACAEIAQpA9ATNwP4DiANIAIpAwA3AwAgCyABKQMANwMAIAwgCikDADcDACAHIA4pAwA3AwAgCC\
APKQMANwMAIAMgECkDADcDACAJIBEpAwA3AwAgBCAEKQP4DjcD+CZBwAAQGSICRQ0cIAIgBCkD+CY3\
AAAgAkE4aiAEQfgmakE4aikDADcAACACQTBqIARB+CZqQTBqKQMANwAAIAJBKGogBEH4JmpBKGopAw\
A3AAAgAkEgaiAEQfgmakEgaikDADcAACACQRhqIARB+CZqQRhqKQMANwAAIAJBEGogBEH4JmpBEGop\
AwA3AAAgAkEIaiAEQfgmakEIaikDADcAACAGECJBwAAhBAweCyAFIAZB0AEQlAEiBEH4DmpBDGpCAD\
cCACAEQfgOakEUakIANwIAIARB+A5qQRxqQgA3AgAgBEIANwL8DiAEQQA2AvgOIARB+A5qIARB+A5q\
QQRyQX9zakEkakEHSRogBEEgNgL4DiAEQdATakEQaiIHIARB+A5qQRBqIgIpAwA3AwAgBEHQE2pBCG\
oiDCAEQfgOakEIaiIBKQMANwMAIARB0BNqQRhqIgsgBEH4DmpBGGoiCSkDADcDACAEQdATakEgaiAE\
QfgOakEgaiINKAIANgIAIARB+CZqQQhqIgogBEHQE2pBDGopAgA3AwAgBEH4JmpBEGoiDiAEQdATak\
EUaikCADcDACAEQfgmakEYaiIPIARB0BNqQRxqKQIANwMAIAQgBCkD+A43A9ATIAQgBCkC1BM3A/gm\
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\
AgAgAUGUD2pBADYCACABQgA3AvwOIAFBADYC+A5BBCECIAFB+A5qIAFB+A5qQQRyQX9zakEgaiEEA0\
AgAkF/aiICDQALAkAgBEEHSQ0AQRghAgNAIAJBeGoiAg0ACwtBHCEEIAFBHDYC+A4gAUHQE2pBEGog\
AUH4DmpBEGopAwA3AwAgAUHQE2pBCGogAUH4DmpBCGopAwA3AwAgAUHQE2pBGGogAUH4DmpBGGopAw\
A3AwAgAUH4JmpBCGoiCSABQdwTaikCADcDACABQfgmakEQaiIDIAFB5BNqKQIANwMAIAFB+CZqQRhq\
IgggAUHQE2pBHGooAgA2AgAgASABKQP4DjcD0BMgASABKQLUEzcD+CYgAUHQE2ogAUHgAhCUARogAU\
HQE2ogAUGYFWogAUH4JmoQOEEcEBkiAkUNFyACIAEpA/gmNwAAIAJBGGogCCgCADYAACACQRBqIAMp\
AwA3AAAgAkEIaiAJKQMANwAADBYLIAUgBkHYAhCUASIBQfgOakEMakIANwIAIAFB+A5qQRRqQgA3Ag\
AgAUH4DmpBHGpCADcCACABQgA3AvwOIAFBADYC+A4gAUH4DmogAUH4DmpBBHJBf3NqQSRqQQdJGkEg\
IQQgAUEgNgL4DiABQdATakEQaiABQfgOakEQaikDADcDACABQdATakEIaiABQfgOakEIaikDADcDAC\
ABQdATakEYaiABQfgOakEYaikDADcDACABQdATakEgaiABQfgOakEgaigCADYCACABQfgmakEIaiIJ\
IAFB0BNqQQxqKQIANwMAIAFB+CZqQRBqIgMgAUHQE2pBFGopAgA3AwAgAUH4JmpBGGoiCCABQdATak\
EcaikCADcDACABIAEpA/gONwPQEyABIAEpAtQTNwP4JiABQdATaiABQdgCEJQBGiABQdATaiABQZgV\
aiABQfgmahBBQSAQGSICRQ0WIAIgASkD+CY3AAAgAkEYaiAIKQMANwAAIAJBEGogAykDADcAACACQQ\
hqIAkpAwA3AAAMFQsgBSAGQbgCEJQBIgFB+A5qQQxqQgA3AgAgAUH4DmpBFGpCADcCACABQfgOakEc\
akIANwIAIAFB+A5qQSRqQgA3AgAgAUH4DmpBLGpCADcCACABQgA3AvwOIAFBADYC+A4gAUH4DmogAU\
H4DmpBBHJBf3NqQTRqQQdJGkEwIQQgAUEwNgL4DiABQdATakEQaiABQfgOakEQaikDADcDACABQdAT\
akEIaiABQfgOakEIaikDADcDACABQdATakEYaiABQfgOakEYaikDADcDACABQdATakEgaiABQfgOak\
EgaikDADcDACABQdATakEoaiABQfgOakEoaikDADcDACABQdATakEwaiABQfgOakEwaigCADYCACAB\
QfgmakEIaiIJIAFB0BNqQQxqKQIANwMAIAFB+CZqQRBqIgMgAUHQE2pBFGopAgA3AwAgAUH4JmpBGG\
oiCCABQdATakEcaikCADcDACABQfgmakEgaiIHIAFB0BNqQSRqKQIANwMAIAFB+CZqQShqIgwgAUHQ\
E2pBLGopAgA3AwAgASABKQP4DjcD0BMgASABKQLUEzcD+CYgAUHQE2ogAUG4AhCUARogAUHQE2ogAU\
GYFWogAUH4JmoQSUEwEBkiAkUNFSACIAEpA/gmNwAAIAJBKGogDCkDADcAACACQSBqIAcpAwA3AAAg\
AkEYaiAIKQMANwAAIAJBEGogAykDADcAACACQQhqIAkpAwA3AAAMFAsgBSAGQZgCEJQBIgFB+A5qQQ\
xqQgA3AgAgAUH4DmpBFGpCADcCACABQfgOakEcakIANwIAIAFB+A5qQSRqQgA3AgAgAUH4DmpBLGpC\
ADcCACABQfgOakE0akIANwIAIAFB+A5qQTxqQgA3AgAgAUIANwL8DiABQQA2AvgOIAFB+A5qIAFB+A\
5qQQRyQX9zakHEAGpBB0kaQcAAIQQgAUHAADYC+A4gAUHQE2ogAUH4DmpBxAAQlAEaIAFB+CZqQThq\
IgkgAUHQE2pBPGopAgA3AwAgAUH4JmpBMGoiAyABQdATakE0aikCADcDACABQfgmakEoaiIIIAFB0B\
NqQSxqKQIANwMAIAFB+CZqQSBqIgcgAUHQE2pBJGopAgA3AwAgAUH4JmpBGGoiDCABQdATakEcaikC\
ADcDACABQfgmakEQaiILIAFB0BNqQRRqKQIANwMAIAFB+CZqQQhqIg0gAUHQE2pBDGopAgA3AwAgAS\
ABKQLUEzcD+CYgAUHQE2ogAUGYAhCUARogAUHQE2ogAUGYFWogAUH4JmoQS0HAABAZIgJFDRQgAiAB\
KQP4JjcAACACQThqIAkpAwA3AAAgAkEwaiADKQMANwAAIAJBKGogCCkDADcAACACQSBqIAcpAwA3AA\
AgAkEYaiAMKQMANwAAIAJBEGogCykDADcAACACQQhqIA0pAwA3AAAMEwsgBSAGQeAAEJQBIgFB+A5q\
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\
aiABQfgmahBCQSAQGSICRQ0OIAIgASkD+CY3AAAgAkEYaiAIKQMANwAAIAJBEGogAykDADcAACACQQ\
hqIAkpAwA3AAAMDQsgBSAGQbgCEJQBIgFB+A5qQQxqQgA3AgAgAUH4DmpBFGpCADcCACABQfgOakEc\
akIANwIAIAFB+A5qQSRqQgA3AgAgAUH4DmpBLGpCADcCACABQgA3AvwOIAFBADYC+A4gAUH4DmogAU\
H4DmpBBHJBf3NqQTRqQQdJGkEwIQQgAUEwNgL4DiABQdATakEQaiABQfgOakEQaikDADcDACABQdAT\
akEIaiABQfgOakEIaikDADcDACABQdATakEYaiABQfgOakEYaikDADcDACABQdATakEgaiABQfgOak\
EgaikDADcDACABQdATakEoaiABQfgOakEoaikDADcDACABQdATakEwaiABQfgOakEwaigCADYCACAB\
QfgmakEIaiIJIAFB0BNqQQxqKQIANwMAIAFB+CZqQRBqIgMgAUHQE2pBFGopAgA3AwAgAUH4JmpBGG\
oiCCABQdATakEcaikCADcDACABQfgmakEgaiIHIAFB0BNqQSRqKQIANwMAIAFB+CZqQShqIgwgAUHQ\
E2pBLGopAgA3AwAgASABKQP4DjcD0BMgASABKQLUEzcD+CYgAUHQE2ogAUG4AhCUARogAUHQE2ogAU\
GYFWogAUH4JmoQSkEwEBkiAkUNDSACIAEpA/gmNwAAIAJBKGogDCkDADcAACACQSBqIAcpAwA3AAAg\
AkEYaiAIKQMANwAAIAJBEGogAykDADcAACACQQhqIAkpAwA3AAAMDAsgBSAGQZgCEJQBIgFB+A5qQQ\
xqQgA3AgAgAUH4DmpBFGpCADcCACABQfgOakEcakIANwIAIAFB+A5qQSRqQgA3AgAgAUH4DmpBLGpC\
ADcCACABQfgOakE0akIANwIAIAFB+A5qQTxqQgA3AgAgAUIANwL8DiABQQA2AvgOIAFB+A5qIAFB+A\
5qQQRyQX9zakHEAGpBB0kaQcAAIQQgAUHAADYC+A4gAUHQE2ogAUH4DmpBxAAQlAEaIAFB+CZqQThq\
IgkgAUHQE2pBPGopAgA3AwAgAUH4JmpBMGoiAyABQdATakE0aikCADcDACABQfgmakEoaiIIIAFB0B\
NqQSxqKQIANwMAIAFB+CZqQSBqIgcgAUHQE2pBJGopAgA3AwAgAUH4JmpBGGoiDCABQdATakEcaikC\
ADcDACABQfgmakEQaiILIAFB0BNqQRRqKQIANwMAIAFB+CZqQQhqIg0gAUHQE2pBDGopAgA3AwAgAS\
ABKQLUEzcD+CYgAUHQE2ogAUGYAhCUARogAUHQE2ogAUGYFWogAUH4JmoQTEHAABAZIgJFDQwgAiAB\
KQP4JjcAACACQThqIAkpAwA3AAAgAkEwaiADKQMANwAAIAJBKGogCCkDADcAACACQSBqIAcpAwA3AA\
AgAkEYaiAMKQMANwAAIAJBEGogCykDADcAACACQQhqIA0pAwA3AAAMCwsgBSAGQfAAEJQBIQRBBCEC\
A0AgAkF/aiICDQALAkBBG0EHSQ0AQRghAgNAIAJBeGoiAg0ACwsgBEHQE2ogBEHwABCUARogBEH4Jm\
pBDGpCADcCACAEQfgmakEUakIANwIAIARB+CZqQRxqQgA3AgAgBEIANwL8JiAEQQA2AvgmIARB+CZq\
IARB+CZqQQRyQX9zakEkakEHSRogBEEgNgL4JiAEQfgOakEQaiIBIARB+CZqQRBqKQMANwMAIARB+A\
5qQQhqIgkgBEH4JmpBCGopAwA3AwAgBEH4DmpBGGoiAyAEQfgmakEYaikDADcDACAEQfgOakEgaiAE\
QfgmakEgaigCADYCACAEQcglakEIaiICIARB+A5qQQxqKQIANwMAIARByCVqQRBqIgggBEH4DmpBFG\
opAgA3AwAgBEHIJWpBGGoiByAEQfgOakEcaikCADcDACAEIAQpA/gmNwP4DiAEIAQpAvwONwPIJSAE\
QdATaiAEQfgTaiAEQcglahAnIAMgBygCADYCACABIAgpAwA3AwAgCSACKQMANwMAIAQgBCkDyCU3A/\
gOQRwQGSICRQ0LIAIgBCkD+A43AAAgAkEYaiADKAIANgAAIAJBEGogASkDADcAACACQQhqIAkpAwA3\
AAAgBhAiQRwhBAwNCyAFIAZB8AAQlAEiAUHQE2ogAUHwABCUARogAUH4JmpBDGpCADcCACABQfgmak\
EUakIANwIAIAFB+CZqQRxqQgA3AgAgAUIANwL8JiABQQA2AvgmIAFB+CZqIAFB+CZqQQRyQX9zakEk\
akEHSRpBICEEIAFBIDYC+CYgAUH4DmpBEGoiCSABQfgmakEQaikDADcDACABQfgOakEIaiIDIAFB+C\
ZqQQhqKQMANwMAIAFB+A5qQRhqIgggAUH4JmpBGGopAwA3AwAgAUH4DmpBIGogAUH4JmpBIGooAgA2\
AgAgAUHIJWpBCGoiAiABQfgOakEMaikCADcDACABQcglakEQaiIHIAFB+A5qQRRqKQIANwMAIAFByC\
VqQRhqIgwgAUH4DmpBHGopAgA3AwAgASABKQP4JjcD+A4gASABKQL8DjcDyCUgAUHQE2ogAUH4E2og\
AUHIJWoQJyAIIAwpAwA3AwAgCSAHKQMANwMAIAMgAikDADcDACABIAEpA8glNwP4DkEgEBkiAkUNCi\
ACIAEpA/gONwAAIAJBGGogCCkDADcAACACQRBqIAkpAwA3AAAgAkEIaiADKQMANwAADAkLIAUgBkHY\
ARCUASIBQdATaiABQdgBEJQBGiABQfgmakEMakIANwIAIAFB+CZqQRRqQgA3AgAgAUH4JmpBHGpCAD\
cCACABQfgmakEkakIANwIAIAFB+CZqQSxqQgA3AgAgAUH4JmpBNGpCADcCACABQfgmakE8akIANwIA\
IAFCADcC/CYgAUEANgL4JiABQfgmaiABQfgmakEEckF/c2pBxABqQQdJGiABQcAANgL4JiABQfgOai\
ABQfgmakHEABCUARogAUGAJmogAUH4DmpBPGopAgA3AwBBMCEEIAFByCVqQTBqIAFB+A5qQTRqKQIA\
NwMAIAFByCVqQShqIgIgAUH4DmpBLGopAgA3AwAgAUHIJWpBIGoiCSABQfgOakEkaikCADcDACABQc\
glakEYaiIDIAFB+A5qQRxqKQIANwMAIAFByCVqQRBqIgggAUH4DmpBFGopAgA3AwAgAUHIJWpBCGoi\
ByABQfgOakEMaikCADcDACABIAEpAvwONwPIJSABQdATaiABQaAUaiABQcglahAjIAFB+A5qQShqIg\
wgAikDADcDACABQfgOakEgaiILIAkpAwA3AwAgAUH4DmpBGGoiCSADKQMANwMAIAFB+A5qQRBqIgMg\
CCkDADcDACABQfgOakEIaiIIIAcpAwA3AwAgASABKQPIJTcD+A5BMBAZIgJFDQkgAiABKQP4DjcAAC\
ACQShqIAwpAwA3AAAgAkEgaiALKQMANwAAIAJBGGogCSkDADcAACACQRBqIAMpAwA3AAAgAkEIaiAI\
KQMANwAADAgLIAUgBkHYARCUASIBQdATaiABQdgBEJQBGiABQfgmakEMakIANwIAIAFB+CZqQRRqQg\
A3AgAgAUH4JmpBHGpCADcCACABQfgmakEkakIANwIAIAFB+CZqQSxqQgA3AgAgAUH4JmpBNGpCADcC\
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\
ADcCACAFQdgHakE8akIANwIAIAVCADcC3AcgBUEANgLYByAFQdgHaiAFQdgHakEEckF/c2pBxABqQQ\
dJGiAFQcAANgLYByAFQYACaiAFQdgHakHEABCUARogBUGoBmpBOGogBUGAAmpBPGopAgA3AwBBMCEE\
IAVBqAZqQTBqIAVBgAJqQTRqKQIANwMAIAVBqAZqQShqIgEgBUGAAmpBLGopAgA3AwAgBUGoBmpBIG\
oiAyAFQYACakEkaikCADcDACAFQagGakEYaiIGIAVBgAJqQRxqKQIANwMAIAVBqAZqQRBqIgcgBUGA\
AmpBFGopAgA3AwAgBUGoBmpBCGoiCCAFQYACakEMaikCADcDACAFIAUpAoQCNwOoBiACIAJB0ABqIA\
VBqAZqECMgBUGAAmpBKGoiCSABKQMANwMAIAVBgAJqQSBqIgogAykDADcDACAFQYACakEYaiIDIAYp\
AwA3AwAgBUGAAmpBEGoiBiAHKQMANwMAIAVBgAJqQQhqIgcgCCkDADcDACAFIAUpA6gGNwOAAiACQc\
gAakIANwMAIAJCADcDQCACQThqQQApA+COQDcDACACQTBqQQApA9iOQDcDACACQShqQQApA9COQDcD\
ACACQSBqQQApA8iOQDcDACACQRhqQQApA8COQDcDACACQRBqQQApA7iOQDcDACACQQhqQQApA7COQD\
cDACACQQApA6iOQDcDACACQdABakEAOgAAQTAQGSIBRQ0LIAEgBSkDgAI3AAAgAUEoaiAJKQMANwAA\
IAFBIGogCikDADcAACABQRhqIAMpAwA3AAAgAUEQaiAGKQMANwAAIAFBCGogBykDADcAAAwKCyAFQd\
gHakEMakIANwIAIAVB2AdqQRRqQgA3AgAgBUHYB2pBHGpCADcCACAFQdgHakEkakIANwIAIAVB2Adq\
QSxqQgA3AgAgBUHYB2pBNGpCADcCACAFQdgHakE8akIANwIAIAVCADcC3AcgBUEANgLYByAFQdgHai\
AFQdgHakEEckF/c2pBxABqQQdJGkHAACEEIAVBwAA2AtgHIAVBgAJqIAVB2AdqQcQAEJQBGiAFQagG\
akE4aiIBIAVBgAJqQTxqKQIANwMAIAVBqAZqQTBqIgMgBUGAAmpBNGopAgA3AwAgBUGoBmpBKGoiBi\
AFQYACakEsaikCADcDACAFQagGakEgaiIHIAVBgAJqQSRqKQIANwMAIAVBqAZqQRhqIgggBUGAAmpB\
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\
cyAjQR53ICNBE3dzICNBCndzaiACIBtBGXcgG0EOd3MgG0EDdnNqIBlqIBJBD3cgEkENd3MgEkEKdn\
NqICJqIBAgHGoiAiAhIB5zcSAec2ogAkEadyACQRV3cyACQQd3c2pB98fm93tqIiJqIhwgIyAgc3Eg\
E3MgC2ogHEEedyAcQRN3cyAcQQp3c2ogGyAfQRl3IB9BDndzIB9BA3ZzaiARaiAkQQ93ICRBDXdzIC\
RBCnZzaiAeaiAiICVqIhsgAiAhc3EgIXNqIBtBGncgG0EVd3MgG0EHd3NqQfLxxbN8aiIeaiELIBwg\
CmohCiAjIAlqIQkgICAIaiEIIB0gB2ogHmohByAbIAZqIQYgAiAFaiEFICEgBGohBCABQcAAaiIBIA\
xHDQALCyAAIAQ2AhwgACAFNgIYIAAgBjYCFCAAIAc2AhAgACAINgIMIAAgCTYCCCAAIAo2AgQgACAL\
NgIAC71AAgp/BH4jAEGAD2siASQAAkACQAJAAkAgAEUNACAAKAIAIgJBf0YNASAAIAJBAWo2AgAgAE\
EIaigCACECAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAg\
AEEEaigCACIDDhgAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcAC0HQARAZIgRFDRogAUEIakE4aiACQT\
hqKQMANwMAIAFBCGpBMGogAkEwaikDADcDACABQQhqQShqIAJBKGopAwA3AwAgAUEIakEgaiACQSBq\
KQMANwMAIAFBCGpBGGogAkEYaikDADcDACABQQhqQRBqIAJBEGopAwA3AwAgAUEIakEIaiACQQhqKQ\
MANwMAIAEgAikDADcDCCACKQNAIQsgAUEIakHIAGogAkHIAGoQYiABIAs3A0ggBCABQQhqQdABEJQB\
GgwXC0HQARAZIgRFDRkgAUEIakE4aiACQThqKQMANwMAIAFBCGpBMGogAkEwaikDADcDACABQQhqQS\
hqIAJBKGopAwA3AwAgAUEIakEgaiACQSBqKQMANwMAIAFBCGpBGGogAkEYaikDADcDACABQQhqQRBq\
IAJBEGopAwA3AwAgAUEIakEIaiACQQhqKQMANwMAIAEgAikDADcDCCACKQNAIQsgAUEIakHIAGogAk\
HIAGoQYiABIAs3A0ggBCABQQhqQdABEJQBGgwWC0HQARAZIgRFDRggAUEIakE4aiACQThqKQMANwMA\
IAFBCGpBMGogAkEwaikDADcDACABQQhqQShqIAJBKGopAwA3AwAgAUEIakEgaiACQSBqKQMANwMAIA\
FBCGpBGGogAkEYaikDADcDACABQQhqQRBqIAJBEGopAwA3AwAgAUEIakEIaiACQQhqKQMANwMAIAEg\
AikDADcDCCACKQNAIQsgAUEIakHIAGogAkHIAGoQYiABIAs3A0ggBCABQQhqQdABEJQBGgwVC0HwAB\
AZIgRFDRcgAUEIakEgaiACQSBqKQMANwMAIAFBCGpBGGogAkEYaikDADcDACABQQhqQRBqIAJBEGop\
AwA3AwAgASACKQMINwMQIAIpAwAhCyABQQhqQShqIAJBKGoQUSABIAs3AwggBCABQQhqQfAAEJQBGg\
wUC0H4DhAZIgRFDRYgAUEIakGIAWogAkGIAWopAwA3AwAgAUEIakGAAWogAkGAAWopAwA3AwAgAUEI\
akH4AGogAkH4AGopAwA3AwAgASACKQNwNwN4IAFBCGpBEGogAkEQaikDADcDACABQQhqQRhqIAJBGG\
opAwA3AwAgAUEIakEgaiACQSBqKQMANwMAIAEgAikDCDcDECACKQMAIQsgAUEIakHgAGogAkHgAGop\
AwA3AwAgAUEIakHYAGogAkHYAGopAwA3AwAgAUEIakHQAGogAkHQAGopAwA3AwAgAUEIakHIAGogAk\
HIAGopAwA3AwAgAUEIakHAAGogAkHAAGopAwA3AwAgAUEIakE4aiACQThqKQMANwMAIAFBCGpBMGog\
AkEwaikDADcDACABIAIpAyg3AzAgAi0AaiEFIAItAGkhBiACLQBoIQcgAUEANgKYAQJAIAIoApABIg\
hFDQAgAkGUAWoiCUEIaikAACEMIAlBEGopAAAhDSAJKQAAIQ4gAUG0AWogCUEYaikAADcCACABQawB\
aiANNwIAIAFBpAFqIAw3AgAgAUEIakGUAWogDjcCACACQbQBaiIKIAkgCEEFdGoiCUYNACAKQQhqKQ\
AAIQwgCkEQaikAACENIAopAAAhDiABQdQBaiAKQRhqKQAANwIAIAFBzAFqIA03AgAgAUHEAWogDDcC\
ACABQQhqQbQBaiAONwIAIAJB1AFqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQf\
QBaiAKQRhqKQAANwIAIAFB7AFqIA03AgAgAUHkAWogDDcCACABQQhqQdQBaiAONwIAIAJB9AFqIgog\
CUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQCaiAKQRhqKQAANwIAIAFBjAJqIA03Ag\
AgAUGEAmogDDcCACABQQhqQfQBaiAONwIAIAJBlAJqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACEN\
IAopAAAhDiABQbQCaiAKQRhqKQAANwIAIAFBrAJqIA03AgAgAUGkAmogDDcCACABQQhqQZQCaiAONw\
IAIAJBtAJqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQCaiAKQRhqKQAANwIA\
IAFBzAJqIA03AgAgAUHEAmogDDcCACABQQhqQbQCaiAONwIAIAJB1AJqIgogCUYNACAKQQhqKQAAIQ\
wgCkEQaikAACENIAopAAAhDiABQfQCaiAKQRhqKQAANwIAIAFB7AJqIA03AgAgAUHkAmogDDcCACAB\
QQhqQdQCaiAONwIAIAJB9AJqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQDai\
AKQRhqKQAANwIAIAFBjANqIA03AgAgAUGEA2ogDDcCACABQQhqQfQCaiAONwIAIAJBlANqIgogCUYN\
ACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQDaiAKQRhqKQAANwIAIAFBrANqIA03AgAgAU\
GkA2ogDDcCACABQQhqQZQDaiAONwIAIAJBtANqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAop\
AAAhDiABQdQDaiAKQRhqKQAANwIAIAFBzANqIA03AgAgAUHEA2ogDDcCACABQQhqQbQDaiAONwIAIA\
JB1ANqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQDaiAKQRhqKQAANwIAIAFB\
7ANqIA03AgAgAUHkA2ogDDcCACABQQhqQdQDaiAONwIAIAJB9ANqIgogCUYNACAKQQhqKQAAIQwgCk\
EQaikAACENIAopAAAhDiABQZQEaiAKQRhqKQAANwIAIAFBjARqIA03AgAgAUGEBGogDDcCACABQQhq\
QfQDaiAONwIAIAJBlARqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQEaiAKQR\
hqKQAANwIAIAFBrARqIA03AgAgAUGkBGogDDcCACABQQhqQZQEaiAONwIAIAJBtARqIgogCUYNACAK\
QQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQEaiAKQRhqKQAANwIAIAFBzARqIA03AgAgAUHEBG\
ogDDcCACABQQhqQbQEaiAONwIAIAJB1ARqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAh\
DiABQfQEaiAKQRhqKQAANwIAIAFB7ARqIA03AgAgAUHkBGogDDcCACABQQhqQdQEaiAONwIAIAJB9A\
RqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQFaiAKQRhqKQAANwIAIAFBjAVq\
IA03AgAgAUGEBWogDDcCACABQQhqQfQEaiAONwIAIAJBlAVqIgogCUYNACAKQQhqKQAAIQwgCkEQai\
kAACENIAopAAAhDiABQbQFaiAKQRhqKQAANwIAIAFBrAVqIA03AgAgAUGkBWogDDcCACABQQhqQZQF\
aiAONwIAIAJBtAVqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQFaiAKQRhqKQ\
AANwIAIAFBzAVqIA03AgAgAUHEBWogDDcCACABQQhqQbQFaiAONwIAIAJB1AVqIgogCUYNACAKQQhq\
KQAAIQwgCkEQaikAACENIAopAAAhDiABQfQFaiAKQRhqKQAANwIAIAFB7AVqIA03AgAgAUHkBWogDD\
cCACABQQhqQdQFaiAONwIAIAJB9AVqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiAB\
QZQGaiAKQRhqKQAANwIAIAFBjAZqIA03AgAgAUGEBmogDDcCACABQQhqQfQFaiAONwIAIAJBlAZqIg\
ogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQGaiAKQRhqKQAANwIAIAFBrAZqIA03\
AgAgAUGkBmogDDcCACABQQhqQZQGaiAONwIAIAJBtAZqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAAC\
ENIAopAAAhDiABQdQGaiAKQRhqKQAANwIAIAFBzAZqIA03AgAgAUHEBmogDDcCACABQQhqQbQGaiAO\
NwIAIAJB1AZqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQGaiAKQRhqKQAANw\
IAIAFB7AZqIA03AgAgAUHkBmogDDcCACABQQhqQdQGaiAONwIAIAJB9AZqIgogCUYNACAKQQhqKQAA\
IQwgCkEQaikAACENIAopAAAhDiABQZQHaiAKQRhqKQAANwIAIAFBjAdqIA03AgAgAUGEB2ogDDcCAC\
ABQQhqQfQGaiAONwIAIAJBlAdqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQH\
aiAKQRhqKQAANwIAIAFBrAdqIA03AgAgAUGkB2ogDDcCACABQQhqQZQHaiAONwIAIAJBtAdqIgogCU\
YNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQHaiAKQRhqKQAANwIAIAFBzAdqIA03AgAg\
AUHEB2ogDDcCACABQQhqQbQHaiAONwIAIAJB1AdqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIA\
opAAAhDiABQfQHaiAKQRhqKQAANwIAIAFB7AdqIA03AgAgAUHkB2ogDDcCACABQQhqQdQHaiAONwIA\
IAJB9AdqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQIaiAKQRhqKQAANwIAIA\
FBjAhqIA03AgAgAUGECGogDDcCACABQQhqQfQHaiAONwIAIAJBlAhqIgogCUYNACAKQQhqKQAAIQwg\
CkEQaikAACENIAopAAAhDiABQbQIaiAKQRhqKQAANwIAIAFBrAhqIA03AgAgAUGkCGogDDcCACABQQ\
hqQZQIaiAONwIAIAJBtAhqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQIaiAK\
QRhqKQAANwIAIAFBzAhqIA03AgAgAUHECGogDDcCACABQQhqQbQIaiAONwIAIAJB1AhqIgogCUYNAC\
AKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQIaiAKQRhqKQAANwIAIAFB7AhqIA03AgAgAUHk\
CGogDDcCACABQQhqQdQIaiAONwIAIAJB9AhqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAA\
AhDiABQZQJaiAKQRhqKQAANwIAIAFBjAlqIA03AgAgAUGECWogDDcCACABQQhqQfQIaiAONwIAIAJB\
lAlqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQJaiAKQRhqKQAANwIAIAFBrA\
lqIA03AgAgAUGkCWogDDcCACABQQhqQZQJaiAONwIAIAJBtAlqIgogCUYNACAKQQhqKQAAIQwgCkEQ\
aikAACENIAopAAAhDiABQdQJaiAKQRhqKQAANwIAIAFBzAlqIA03AgAgAUHECWogDDcCACABQQhqQb\
QJaiAONwIAIAJB1AlqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQJaiAKQRhq\
KQAANwIAIAFB7AlqIA03AgAgAUHkCWogDDcCACABQQhqQdQJaiAONwIAIAJB9AlqIgogCUYNACAKQQ\
hqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQKaiAKQRhqKQAANwIAIAFBjApqIA03AgAgAUGECmog\
DDcCACABQQhqQfQJaiAONwIAIAJBlApqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDi\
ABQbQKaiAKQRhqKQAANwIAIAFBrApqIA03AgAgAUGkCmogDDcCACABQQhqQZQKaiAONwIAIAJBtApq\
IgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQKaiAKQRhqKQAANwIAIAFBzApqIA\
03AgAgAUHECmogDDcCACABQQhqQbQKaiAONwIAIAJB1ApqIgogCUYNACAKQQhqKQAAIQwgCkEQaikA\
ACENIAopAAAhDiABQfQKaiAKQRhqKQAANwIAIAFB7ApqIA03AgAgAUHkCmogDDcCACABQQhqQdQKai\
AONwIAIAJB9ApqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQLaiAKQRhqKQAA\
NwIAIAFBjAtqIA03AgAgAUGEC2ogDDcCACABQQhqQfQKaiAONwIAIAJBlAtqIgogCUYNACAKQQhqKQ\
AAIQwgCkEQaikAACENIAopAAAhDiABQbQLaiAKQRhqKQAANwIAIAFBrAtqIA03AgAgAUGkC2ogDDcC\
ACABQQhqQZQLaiAONwIAIAJBtAtqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQd\
QLaiAKQRhqKQAANwIAIAFBzAtqIA03AgAgAUHEC2ogDDcCACABQQhqQbQLaiAONwIAIAJB1AtqIgog\
CUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQLaiAKQRhqKQAANwIAIAFB7AtqIA03Ag\
AgAUHkC2ogDDcCACABQQhqQdQLaiAONwIAIAJB9AtqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACEN\
IAopAAAhDiABQZQMaiAKQRhqKQAANwIAIAFBjAxqIA03AgAgAUGEDGogDDcCACABQQhqQfQLaiAONw\
IAIAJBlAxqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQMaiAKQRhqKQAANwIA\
IAFBrAxqIA03AgAgAUGkDGogDDcCACABQQhqQZQMaiAONwIAIAJBtAxqIgogCUYNACAKQQhqKQAAIQ\
wgCkEQaikAACENIAopAAAhDiABQdQMaiAKQRhqKQAANwIAIAFBzAxqIA03AgAgAUHEDGogDDcCACAB\
QQhqQbQMaiAONwIAIAJB1AxqIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQMai\
AKQRhqKQAANwIAIAFB7AxqIA03AgAgAUHkDGogDDcCACABQQhqQdQMaiAONwIAIAJB9AxqIgogCUYN\
ACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQNaiAKQRhqKQAANwIAIAFBjA1qIA03AgAgAU\
GEDWogDDcCACABQQhqQfQMaiAONwIAIAJBlA1qIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAop\
AAAhDiABQbQNaiAKQRhqKQAANwIAIAFBrA1qIA03AgAgAUGkDWogDDcCACABQQhqQZQNaiAONwIAIA\
JBtA1qIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQdQNaiAKQRhqKQAANwIAIAFB\
zA1qIA03AgAgAUHEDWogDDcCACABQQhqQbQNaiAONwIAIAJB1A1qIgogCUYNACAKQQhqKQAAIQwgCk\
EQaikAACENIAopAAAhDiABQfQNaiAKQRhqKQAANwIAIAFB7A1qIA03AgAgAUHkDWogDDcCACABQQhq\
QdQNaiAONwIAIAJB9A1qIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQZQOaiAKQR\
hqKQAANwIAIAFBjA5qIA03AgAgAUGEDmogDDcCACABQQhqQfQNaiAONwIAIAJBlA5qIgogCUYNACAK\
QQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQbQOaiAKQRhqKQAANwIAIAFBrA5qIA03AgAgAUGkDm\
ogDDcCACABQQhqQZQOaiAONwIAIAJBtA5qIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAh\
DiABQdQOaiAKQRhqKQAANwIAIAFBzA5qIA03AgAgAUHEDmogDDcCACABQQhqQbQOaiAONwIAIAJB1A\
5qIgogCUYNACAKQQhqKQAAIQwgCkEQaikAACENIAopAAAhDiABQfQOaiAKQRhqKQAANwIAIAFB7A5q\
IA03AgAgAUHkDmogDDcCACABQQhqQdQOaiAONwIAIAJB9A5qIAlHDRgLIAEgBToAciABIAY6AHEgAS\
AHOgBwIAEgCzcDCCABIAhB////P3EiAkE3IAJBN0kbNgKYASAEIAFBCGpB+A4QlAEaDBMLQeACEBki\
BEUNFSABQQhqIAJByAEQlAEaIAFBCGpByAFqIAJByAFqEGMgBCABQQhqQeACEJQBGgwSC0HYAhAZIg\
RFDRQgAUEIaiACQcgBEJQBGiABQQhqQcgBaiACQcgBahBkIAQgAUEIakHYAhCUARoMEQtBuAIQGSIE\
RQ0TIAFBCGogAkHIARCUARogAUEIakHIAWogAkHIAWoQZSAEIAFBCGpBuAIQlAEaDBALQZgCEBkiBE\
UNEiABQQhqIAJByAEQlAEaIAFBCGpByAFqIAJByAFqEGYgBCABQQhqQZgCEJQBGgwPC0HgABAZIgRF\
DREgAUEIakEQaiACQRBqKQMANwMAIAEgAikDCDcDECACKQMAIQsgAUEIakEYaiACQRhqEFEgASALNw\
MIIAQgAUEIakHgABCUARoMDgtB4AAQGSIERQ0QIAFBCGpBEGogAkEQaikDADcDACABIAIpAwg3AxAg\
AikDACELIAFBCGpBGGogAkEYahBRIAEgCzcDCCAEIAFBCGpB4AAQlAEaDA0LQegAEBkiBEUNDyABQQ\
hqQRhqIAJBGGooAgA2AgAgAUEIakEQaiACQRBqKQMANwMAIAEgAikDCDcDECACKQMAIQsgAUEIakEg\
aiACQSBqEFEgASALNwMIIAQgAUEIakHoABCUARoMDAtB6AAQGSIERQ0OIAFBCGpBGGogAkEYaigCAD\
YCACABQQhqQRBqIAJBEGopAwA3AwAgASACKQMINwMQIAIpAwAhCyABQQhqQSBqIAJBIGoQUSABIAs3\
AwggBCABQQhqQegAEJQBGgwLC0HgAhAZIgRFDQ0gAUEIaiACQcgBEJQBGiABQQhqQcgBaiACQcgBah\
BjIAQgAUEIakHgAhCUARoMCgtB2AIQGSIERQ0MIAFBCGogAkHIARCUARogAUEIakHIAWogAkHIAWoQ\
ZCAEIAFBCGpB2AIQlAEaDAkLQbgCEBkiBEUNCyABQQhqIAJByAEQlAEaIAFBCGpByAFqIAJByAFqEG\
UgBCABQQhqQbgCEJQBGgwIC0GYAhAZIgRFDQogAUEIaiACQcgBEJQBGiABQQhqQcgBaiACQcgBahBm\
IAQgAUEIakGYAhCUARoMBwtB8AAQGSIERQ0JIAFBCGpBIGogAkEgaikDADcDACABQQhqQRhqIAJBGG\
opAwA3AwAgAUEIakEQaiACQRBqKQMANwMAIAEgAikDCDcDECACKQMAIQsgAUEIakEoaiACQShqEFEg\
ASALNwMIIAQgAUEIakHwABCUARoMBgtB8AAQGSIERQ0IIAFBCGpBIGogAkEgaikDADcDACABQQhqQR\
hqIAJBGGopAwA3AwAgAUEIakEQaiACQRBqKQMANwMAIAEgAikDCDcDECACKQMAIQsgAUEIakEoaiAC\
QShqEFEgASALNwMIIAQgAUEIakHwABCUARoMBQtB2AEQGSIERQ0HIAFBCGpBOGogAkE4aikDADcDAC\
ABQQhqQTBqIAJBMGopAwA3AwAgAUEIakEoaiACQShqKQMANwMAIAFBCGpBIGogAkEgaikDADcDACAB\
QQhqQRhqIAJBGGopAwA3AwAgAUEIakEQaiACQRBqKQMANwMAIAFBCGpBCGogAkEIaikDADcDACABIA\
IpAwA3AwggAkHIAGopAwAhCyACKQNAIQwgAUEIakHQAGogAkHQAGoQYiABQQhqQcgAaiALNwMAIAEg\
DDcDSCAEIAFBCGpB2AEQlAEaDAQLQdgBEBkiBEUNBiABQQhqQThqIAJBOGopAwA3AwAgAUEIakEwai\
ACQTBqKQMANwMAIAFBCGpBKGogAkEoaikDADcDACABQQhqQSBqIAJBIGopAwA3AwAgAUEIakEYaiAC\
QRhqKQMANwMAIAFBCGpBEGogAkEQaikDADcDACABQQhqQQhqIAJBCGopAwA3AwAgASACKQMANwMIIA\
JByABqKQMAIQsgAikDQCEMIAFBCGpB0ABqIAJB0ABqEGIgAUEIakHIAGogCzcDACABIAw3A0ggBCAB\
QQhqQdgBEJQBGgwDC0H4AhAZIgRFDQUgAUEIaiACQcgBEJQBGiABQQhqQcgBaiACQcgBahBnIAQgAU\
EIakH4AhCUARoMAgtB2AIQGSIERQ0EIAFBCGogAkHIARCUARogAUEIakHIAWogAkHIAWoQZCAEIAFB\
CGpB2AIQlAEaDAELQegAEBkiBEUNAyABQQhqQRBqIAJBEGopAwA3AwAgAUEIakEYaiACQRhqKQMANw\
MAIAEgAikDCDcDECACKQMAIQsgAUEIakEgaiACQSBqEFEgASALNwMIIAQgAUEIakHoABCUARoLIAAg\
ACgCAEF/ajYCAEEMEBkiAEUNAiAAIAQ2AgggACADNgIEIABBADYCACABQYAPaiQAIAAPCxCQAQALEJ\
EBAAsACxCNAQAL1TwCE38CfiMAQYACayIEJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC\
QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAk\
ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJA\
IAAOGAABAgMEBQYHCAkKCwwNDg8QERITFBUWFwALIAFByABqIQVBgAEgAUHIAWotAAAiAGsiBiADTw\
0XAkAgAEUNACAFIABqIAIgBhCUARogASABKQNAQoABfDcDQCABIAVCABASIAMgBmshAyACIAZqIQIL\
IAMgA0EHdiADQQBHIANB/wBxRXFrIgBBB3QiB2shAyAARQ1GIAchBiACIQADQCABIAEpA0BCgAF8Nw\
NAIAEgAEIAEBIgAEGAAWohACAGQYB/aiIGDQAMRwsLIAFByABqIQVBgAEgAUHIAWotAAAiAGsiBiAD\
Tw0XAkAgAEUNACAFIABqIAIgBhCUARogASABKQNAQoABfDcDQCABIAVCABASIAMgBmshAyACIAZqIQ\
ILIAMgA0EHdiADQQBHIANB/wBxRXFrIgBBB3QiB2shAyAARQ1EIAchBiACIQADQCABIAEpA0BCgAF8\
NwNAIAEgAEIAEBIgAEGAAWohACAGQYB/aiIGDQAMRQsLIAFByABqIQVBgAEgAUHIAWotAAAiAGsiBi\
ADTw0XAkAgAEUNACAFIABqIAIgBhCUARogASABKQNAQoABfDcDQCABIAVCABASIAMgBmshAyACIAZq\
IQILIAMgA0EHdiADQQBHIANB/wBxRXFrIgBBB3QiB2shAyAARQ1CIAchBiACIQADQCABIAEpA0BCgA\
F8NwNAIAEgAEIAEBIgAEGAAWohACAGQYB/aiIGDQAMQwsLIAFBKGohBUHAACABQegAai0AACIAayIG\
IANPDRcCQCAARQ0AIAUgAGogAiAGEJQBGiABIAEpAwBCwAB8NwMAIAEgBUEAEBQgAyAGayEDIAIgBm\
ohAgsgAyADQQZ2IANBAEcgA0E/cUVxayIAQQZ0IgdrIQMgAEUNQCAHIQYgAiEAA0AgASABKQMAQsAA\
fDcDACABIABBABAUIABBwABqIQAgBkFAaiIGDQAMQQsLIAFB6QBqLQAAQQZ0IAEtAGhqIgBFDT4gAS\
ACQYAIIABrIgAgAyAAIANJGyIFEDchACADIAVrIgNFDUMgBEHwAGpBEGogAEEQaiIGKQMANwMAIARB\
8ABqQRhqIABBGGoiBykDADcDACAEQfAAakEgaiAAQSBqIggpAwA3AwAgBEHwAGpBMGogAEEwaikDAD\
cDACAEQfAAakE4aiAAQThqKQMANwMAIARB8ABqQcAAaiAAQcAAaikDADcDACAEQfAAakHIAGogAEHI\
AGopAwA3AwAgBEHwAGpB0ABqIABB0ABqKQMANwMAIARB8ABqQdgAaiAAQdgAaikDADcDACAEQfAAak\
HgAGogAEHgAGopAwA3AwAgBCAAKQMINwN4IAQgACkDKDcDmAEgAUHpAGotAAAhCSAALQBqIQogBCAB\
LQBoIgs6ANgBIAQgACkDACIXNwNwIAQgCiAJRXJBAnIiCToA2QEgBEEYaiIKIAgpAgA3AwAgBEEQai\
IIIAcpAgA3AwAgBEEIaiIHIAYpAgA3AwAgBCAAKQIINwMAIAQgBEHwAGpBKGogCyAXIAkQGCAKKAIA\
IQkgCCgCACEIIAcoAgAhCiAEKAIcIQsgBCgCFCEMIAQoAgwhDSAEKAIEIQ4gBCgCACEPIAAgFxAqIA\
AoApABIgdBN08NFyAAQZABaiAHQQV0aiIGQSBqIAs2AgAgBkEcaiAJNgIAIAZBGGogDDYCACAGQRRq\
IAg2AgAgBkEQaiANNgIAIAZBDGogCjYCACAGQQhqIA42AgAgBkEEaiAPNgIAIABBKGoiBkEYakIANw\
MAIAZBIGpCADcDACAGQShqQgA3AwAgBkEwakIANwMAIAZBOGpCADcDACAGQgA3AwAgACAHQQFqNgKQ\
ASAGQQhqQgA3AwAgBkEQakIANwMAIABBCGoiBkEYaiAAQYgBaikDADcDACAGQRBqIABBgAFqKQMANw\
MAIAZBCGogAEH4AGopAwA3AwAgBiAAKQNwNwMAIAAgACkDAEIBfDcDACABQQA7AWggAiAFaiECDD4L\
IAQgATYCcCABQcgBaiEGQZABIAFB2AJqLQAAIgBrIgUgA0sNFwJAIABFDQAgBiAAaiACIAUQlAEaIA\
RB8ABqIAZBARBEIAMgBWshAyACIAVqIQILIAMgA0GQAW4iB0GQAWwiBWshACADQY8BTQ08IARB8ABq\
IAIgBxBEDDwLIAQgATYCcCABQcgBaiEGQYgBIAFB0AJqLQAAIgBrIgUgA0sNFwJAIABFDQAgBiAAai\
ACIAUQlAEaIARB8ABqIAZBARBIIAMgBWshAyACIAVqIQILIAMgA0GIAW4iB0GIAWwiBWshACADQYcB\
TQ06IARB8ABqIAIgBxBIDDoLIAQgATYCcCABQcgBaiEGQegAIAFBsAJqLQAAIgBrIgUgA0sNFwJAIA\
BFDQAgBiAAaiACIAUQlAEaIARB8ABqIAZBARBPIAMgBWshAyACIAVqIQILIAMgA0HoAG4iB0HoAGwi\
BWshACADQecATQ04IARB8ABqIAIgBxBPDDgLIAQgATYCcCABQcgBaiEGQcgAIAFBkAJqLQAAIgBrIg\
UgA0sNFwJAIABFDQAgBiAAaiACIAUQlAEaIARB8ABqIAZBARBUIAMgBWshAyACIAVqIQILIAMgA0HI\
AG4iB0HIAGwiBWshACADQccATQ02IARB8ABqIAIgBxBUDDYLIAFBGGohBUHAACABQdgAai0AACIAay\
IGIANLDRcCQCAARQ0AIAUgAGogAiAGEJQBGiABIAEpAwBCAXw3AwAgAUEIaiAFEB0gAyAGayEDIAIg\
BmohAgsgA0E/cSEHIAIgA0FAcSIAaiEIIANBP00NNCABIAEpAwAgA0EGdq18NwMAIAFBCGohBgNAIA\
YgAhAdIAJBwABqIQIgAEFAaiIADQAMNQsLIAQgATYCcCABQRhqIQZBwAAgAUHYAGotAAAiAGsiBSAD\
Sw0XAkAgAEUNACAGIABqIAIgBRCUARogBEHwAGogBkEBEBogAyAFayEDIAIgBWohAgsgA0E/cSEAIA\
IgA0FAcWohBSADQT9NDTIgBEHwAGogAiADQQZ2EBoMMgsgAUEgaiEFQcAAIAFB4ABqLQAAIgBrIgYg\
A0sNFwJAIABFDQAgBSAAaiACIAYQlAEaIAEgASkDAEIBfDcDACABQQhqIAUQEyADIAZrIQMgAiAGai\
ECCyADQT9xIQcgAiADQUBxIgBqIQggA0E/TQ0wIAEgASkDACADQQZ2rXw3AwAgAUEIaiEGA0AgBiAC\
EBMgAkHAAGohAiAAQUBqIgANAAwxCwsgAUEgaiEGQcAAIAFB4ABqLQAAIgBrIgUgA0sNFwJAIABFDQ\
AgBiAAaiACIAUQlAEaIAEgASkDAEIBfDcDACABQQhqIAZBARAVIAMgBWshAyACIAVqIQILIANBP3Eh\
ACACIANBQHFqIQUgA0E/TQ0uIAEgASkDACADQQZ2IgOtfDcDACABQQhqIAIgAxAVDC4LIAQgATYCcC\
ABQcgBaiEGQZABIAFB2AJqLQAAIgBrIgUgA0sNFwJAIABFDQAgBiAAaiACIAUQlAEaIARB8ABqIAZB\
ARBEIAMgBWshAyACIAVqIQILIAMgA0GQAW4iB0GQAWwiBWshACADQY8BTQ0sIARB8ABqIAIgBxBEDC\
wLIAQgATYCcCABQcgBaiEGQYgBIAFB0AJqLQAAIgBrIgUgA0sNFwJAIABFDQAgBiAAaiACIAUQlAEa\
IARB8ABqIAZBARBIIAMgBWshAyACIAVqIQILIAMgA0GIAW4iB0GIAWwiBWshACADQYcBTQ0qIARB8A\
BqIAIgBxBIDCoLIAQgATYCcCABQcgBaiEGQegAIAFBsAJqLQAAIgBrIgUgA0sNFwJAIABFDQAgBiAA\
aiACIAUQlAEaIARB8ABqIAZBARBPIAMgBWshAyACIAVqIQILIAMgA0HoAG4iB0HoAGwiBWshACADQe\
cATQ0oIARB8ABqIAIgBxBPDCgLIAQgATYCcCABQcgBaiEGQcgAIAFBkAJqLQAAIgBrIgUgA0sNFwJA\
IABFDQAgBiAAaiACIAUQlAEaIARB8ABqIAZBARBUIAMgBWshAyACIAVqIQILIAMgA0HIAG4iB0HIAG\
wiBWshACADQccATQ0mIARB8ABqIAIgBxBUDCYLIAFBKGohBkHAACABQegAai0AACIAayIFIANLDRcC\
QCAARQ0AIAYgAGogAiAFEJQBGiABIAEpAwBCAXw3AwAgAUEIaiAGQQEQDyADIAVrIQMgAiAFaiECCy\
ADQT9xIQAgAiADQUBxaiEFIANBP00NJCABIAEpAwAgA0EGdiIDrXw3AwAgAUEIaiACIAMQDwwkCyAB\
QShqIQZBwAAgAUHoAGotAAAiAGsiBSADSw0XAkAgAEUNACAGIABqIAIgBRCUARogASABKQMAQgF8Nw\
MAIAFBCGogBkEBEA8gAyAFayEDIAIgBWohAgsgA0E/cSEAIAIgA0FAcWohBSADQT9NDSIgASABKQMA\
IANBBnYiA618NwMAIAFBCGogAiADEA8MIgsgAUHQAGohBkGAASABQdABai0AACIAayIFIANLDRcCQC\
AARQ0AIAYgAGogAiAFEJQBGiABIAEpA0AiF0IBfCIYNwNAIAFByABqIgAgACkDACAYIBdUrXw3AwAg\
ASAGQQEQDSADIAVrIQMgAiAFaiECCyADQf8AcSEAIAIgA0GAf3FqIQUgA0H/AE0NICABIAEpA0AiFy\
ADQQd2IgOtfCIYNwNAIAFByABqIgcgBykDACAYIBdUrXw3AwAgASACIAMQDQwgCyABQdAAaiEGQYAB\
IAFB0AFqLQAAIgBrIgUgA0sNFwJAIABFDQAgBiAAaiACIAUQlAEaIAEgASkDQCIXQgF8Ihg3A0AgAU\
HIAGoiACAAKQMAIBggF1StfDcDACABIAZBARANIAMgBWshAyACIAVqIQILIANB/wBxIQAgAiADQYB/\
cWohBSADQf8ATQ0eIAEgASkDQCIXIANBB3YiA618Ihg3A0AgAUHIAGoiByAHKQMAIBggF1StfDcDAC\
ABIAIgAxANDB4LIAQgATYCcCABQcgBaiEGQagBIAFB8AJqLQAAIgBrIgUgA0sNFwJAIABFDQAgBiAA\
aiACIAUQlAEaIARB8ABqIAZBARA+IAMgBWshAyACIAVqIQILIAMgA0GoAW4iB0GoAWwiBWshACADQa\
cBTQ0cIARB8ABqIAIgBxA+DBwLIAQgATYCcCABQcgBaiEGQYgBIAFB0AJqLQAAIgBrIgUgA0sNFwJA\
IABFDQAgBiAAaiACIAUQlAEaIARB8ABqIAZBARBIIAMgBWshAyACIAVqIQILIAMgA0GIAW4iB0GIAW\
wiBWshACADQYcBTQ0aIARB8ABqIAIgBxBIDBoLIAFBIGohBQJAQcAAIAFB4ABqLQAAIgBrIgYgA0sN\
AAJAIABFDQAgBSAAaiACIAYQlAEaIAEgASkDAEIBfDcDACABQQhqIAUQFiADIAZrIQMgAiAGaiECCy\
ADQT9xIQcgAiADQUBxIgBqIQggA0E/TQ0YIAEgASkDACADQQZ2rXw3AwAgAUEIaiEGA0AgBiACEBYg\
AkHAAGohAiAAQUBqIgANAAwZCwsgBSAAaiACIAMQlAEaIAAgA2ohBwwYCyAFIABqIAIgAxCUARogAS\
AAIANqOgDIAQwvCyAFIABqIAIgAxCUARogASAAIANqOgDIAQwuCyAFIABqIAIgAxCUARogASAAIANq\
OgDIAQwtCyAFIABqIAIgAxCUARogASAAIANqOgBoDCwLIAQgCzYCjAEgBCAJNgKIASAEIAw2AoQBIA\
QgCDYCgAEgBCANNgJ8IAQgCjYCeCAEIA42AnQgBCAPNgJwQbCRwAAgBEHwAGpBpIfAAEGUh8AAEGEA\
CyAGIABqIAIgAxCUARogASAAIANqOgDYAgwqCyAGIABqIAIgAxCUARogASAAIANqOgDQAgwpCyAGIA\
BqIAIgAxCUARogASAAIANqOgCwAgwoCyAGIABqIAIgAxCUARogASAAIANqOgCQAgwnCyAFIABqIAIg\
AxCUARogASAAIANqOgBYDCYLIAYgAGogAiADEJQBGiABIAAgA2o6AFgMJQsgBSAAaiACIAMQlAEaIA\
EgACADajoAYAwkCyAGIABqIAIgAxCUARogASAAIANqOgBgDCMLIAYgAGogAiADEJQBGiABIAAgA2o6\
ANgCDCILIAYgAGogAiADEJQBGiABIAAgA2o6ANACDCELIAYgAGogAiADEJQBGiABIAAgA2o6ALACDC\
ALIAYgAGogAiADEJQBGiABIAAgA2o6AJACDB8LIAYgAGogAiADEJQBGiABIAAgA2o6AGgMHgsgBiAA\
aiACIAMQlAEaIAEgACADajoAaAwdCyAGIABqIAIgAxCUARogASAAIANqOgDQAQwcCyAGIABqIAIgAx\
CUARogASAAIANqOgDQAQwbCyAGIABqIAIgAxCUARogASAAIANqOgDwAgwaCyAGIABqIAIgAxCUARog\
ASAAIANqOgDQAgwZCyAFIAggBxCUARoLIAEgBzoAYAwXCwJAIABBiQFPDQAgBiACIAVqIAAQlAEaIA\
EgADoA0AIMFwsgAEGIAUGAgMAAEIsBAAsCQCAAQakBTw0AIAYgAiAFaiAAEJQBGiABIAA6APACDBYL\
IABBqAFBgIDAABCLAQALIAYgBSAAEJQBGiABIAA6ANABDBQLIAYgBSAAEJQBGiABIAA6ANABDBMLIA\
YgBSAAEJQBGiABIAA6AGgMEgsgBiAFIAAQlAEaIAEgADoAaAwRCwJAIABByQBPDQAgBiACIAVqIAAQ\
lAEaIAEgADoAkAIMEQsgAEHIAEGAgMAAEIsBAAsCQCAAQekATw0AIAYgAiAFaiAAEJQBGiABIAA6AL\
ACDBALIABB6ABBgIDAABCLAQALAkAgAEGJAU8NACAGIAIgBWogABCUARogASAAOgDQAgwPCyAAQYgB\
QYCAwAAQiwEACwJAIABBkQFPDQAgBiACIAVqIAAQlAEaIAEgADoA2AIMDgsgAEGQAUGAgMAAEIsBAA\
sgBiAFIAAQlAEaIAEgADoAYAwMCyAFIAggBxCUARogASAHOgBgDAsLIAYgBSAAEJQBGiABIAA6AFgM\
CgsgBSAIIAcQlAEaIAEgBzoAWAwJCwJAIABByQBPDQAgBiACIAVqIAAQlAEaIAEgADoAkAIMCQsgAE\
HIAEGAgMAAEIsBAAsCQCAAQekATw0AIAYgAiAFaiAAEJQBGiABIAA6ALACDAgLIABB6ABBgIDAABCL\
AQALAkAgAEGJAU8NACAGIAIgBWogABCUARogASAAOgDQAgwHCyAAQYgBQYCAwAAQiwEACwJAIABBkQ\
FPDQAgBiACIAVqIAAQlAEaIAEgADoA2AIMBgsgAEGQAUGAgMAAEIsBAAsCQAJAAkACQAJAAkACQAJA\
AkAgA0GBCEkNACABQZQBaiEOIAFB8ABqIQcgASkDACEYIARBKGohCiAEQQhqIQwgBEHwAGpBKGohCS\
AEQfAAakEIaiELIARBIGohDQNAIBhCCoYhF0F/IANBAXZndkEBaiEGA0AgBiIAQQF2IQYgFyAAQX9q\
rYNCAFINAAsgAEEKdq0hFwJAAkAgAEGBCEkNACADIABJDQQgAS0AaiEIIARB8ABqQThqIg9CADcDAC\
AEQfAAakEwaiIQQgA3AwAgCUIANwMAIARB8ABqQSBqIhFCADcDACAEQfAAakEYaiISQgA3AwAgBEHw\
AGpBEGoiE0IANwMAIAtCADcDACAEQgA3A3AgAiAAIAcgGCAIIARB8ABqQcAAEB4hBiAEQeABakEYak\
IANwMAIARB4AFqQRBqQgA3AwAgBEHgAWpBCGpCADcDACAEQgA3A+ABAkAgBkEDSQ0AA0AgBkEFdCIG\
QcEATw0HIARB8ABqIAYgByAIIARB4AFqQSAQLSIGQQV0IgVBwQBPDQggBUEhTw0JIARB8ABqIARB4A\
FqIAUQlAEaIAZBAksNAAsLIARBOGogDykDADcDACAEQTBqIBApAwA3AwAgCiAJKQMANwMAIA0gESkD\
ADcDACAEQRhqIgggEikDADcDACAEQRBqIg8gEykDADcDACAMIAspAwA3AwAgBCAEKQNwNwMAIAEgAS\
kDABAqIAEoApABIgVBN08NCCAOIAVBBXRqIgZBGGogCCkDADcAACAGQRBqIA8pAwA3AAAgBkEIaiAM\
KQMANwAAIAYgBCkDADcAACABIAVBAWo2ApABIAEgASkDACAXQgGIfBAqIAEoApABIgVBN08NCSAOIA\
VBBXRqIgZBGGogDUEYaikAADcAACAGIA0pAAA3AAAgBkEQaiANQRBqKQAANwAAIAZBCGogDUEIaikA\
ADcAACABIAVBAWo2ApABDAELIAlCADcDACAJQQhqIg9CADcDACAJQRBqIhBCADcDACAJQRhqIhFCAD\
cDACAJQSBqIhJCADcDACAJQShqIhNCADcDACAJQTBqIhRCADcDACAJQThqIhVCADcDACALIAcpAwA3\
AwAgC0EIaiIGIAdBCGopAwA3AwAgC0EQaiIFIAdBEGopAwA3AwAgC0EYaiIIIAdBGGopAwA3AwAgBE\
EAOwHYASAEIBg3A3AgBCABLQBqOgDaASAEQfAAaiACIAAQNyEWIAwgCykDADcDACAMQQhqIAYpAwA3\
AwAgDEEQaiAFKQMANwMAIAxBGGogCCkDADcDACAKIAkpAwA3AwAgCkEIaiAPKQMANwMAIApBEGogEC\
kDADcDACAKQRhqIBEpAwA3AwAgCkEgaiASKQMANwMAIApBKGogEykDADcDACAKQTBqIBQpAwA3AwAg\
CkE4aiAVKQMANwMAIAQtANoBIQ8gBC0A2QEhECAEIAQtANgBIhE6AGggBCAWKQMAIhg3AwAgBCAPIB\
BFckECciIPOgBpIARB4AFqQRhqIhAgCCkCADcDACAEQeABakEQaiIIIAUpAgA3AwAgBEHgAWpBCGoi\
BSAGKQIANwMAIAQgCykCADcD4AEgBEHgAWogCiARIBggDxAYIBAoAgAhDyAIKAIAIQggBSgCACEQIA\
QoAvwBIREgBCgC9AEhEiAEKALsASETIAQoAuQBIRQgBCgC4AEhFSABIAEpAwAQKiABKAKQASIFQTdP\
DQkgDiAFQQV0aiIGIBE2AhwgBiAPNgIYIAYgEjYCFCAGIAg2AhAgBiATNgIMIAYgEDYCCCAGIBQ2Ag\
QgBiAVNgIAIAEgBUEBajYCkAELIAEgASkDACAXfCIYNwMAIAMgAEkNCSACIABqIQIgAyAAayIDQYAI\
Sw0ACwsgA0UNDCABIAIgAxA3IgAgACkDABAqDAwLIAAgA0HQhcAAEIsBAAsgBkHAAEGQhcAAEIsBAA\
sgBUHAAEGghcAAEIsBAAsgBUEgQbCFwAAQiwEACyAEQfAAakEYaiAEQRhqKQMANwMAIARB8ABqQRBq\
IARBEGopAwA3AwAgBEHwAGpBCGogBEEIaikDADcDACAEIAQpAwA3A3BBsJHAACAEQfAAakGkh8AAQZ\
SHwAAQYQALIARB8ABqQRhqIA1BGGopAAA3AwAgBEHwAGpBEGogDUEQaikAADcDACAEQfAAakEIaiAN\
QQhqKQAANwMAIAQgDSkAADcDcEGwkcAAIARB8ABqQaSHwABBlIfAABBhAAsgBCARNgL8ASAEIA82Av\
gBIAQgEjYC9AEgBCAINgLwASAEIBM2AuwBIAQgEDYC6AEgBCAUNgLkASAEIBU2AuABQbCRwAAgBEHg\
AWpBpIfAAEGUh8AAEGEACyAAIANB4IXAABCMAQALAkAgA0HBAE8NACAFIAIgB2ogAxCUARogASADOg\
BoDAQLIANBwABBgIDAABCLAQALAkAgA0GBAU8NACAFIAIgB2ogAxCUARogASADOgDIAQwDCyADQYAB\
QYCAwAAQiwEACwJAIANBgQFPDQAgBSACIAdqIAMQlAEaIAEgAzoAyAEMAgsgA0GAAUGAgMAAEIsBAA\
sgA0GBAU8NASAFIAIgB2ogAxCUARogASADOgDIAQsgBEGAAmokAA8LIANBgAFBgIDAABCLAQALmi8C\
A38qfiMAQYABayIDJAAgA0EAQYABEJMBIgMgASkAADcDACADIAEpAAg3AwggAyABKQAQNwMQIAMgAS\
kAGDcDGCADIAEpACA3AyAgAyABKQAoNwMoIAMgASkAMCIGNwMwIAMgASkAOCIHNwM4IAMgASkAQCII\
NwNAIAMgASkASCIJNwNIIAMgASkAUCIKNwNQIAMgASkAWCILNwNYIAMgASkAYCIMNwNgIAMgASkAaC\
INNwNoIAMgASkAcCIONwNwIAMgASkAeCIPNwN4IAAgCCALIAogCyAPIAggByANIAsgBiAIIAkgCSAK\
IA4gDyAIIAggBiAPIAogDiALIAcgDSAPIAcgCyAGIA0gDSAMIAcgBiAAQThqIgEpAwAiECAAKQMYIh\
F8fCISQvnC+JuRo7Pw2wCFQiCJIhNC8e30+KWn/aelf3wiFCAQhUIoiSIVIBJ8fCIWIBOFQjCJIhcg\
FHwiGCAVhUIBiSIZIABBMGoiBCkDACIaIAApAxAiG3wgAykDICISfCITIAKFQuv6htq/tfbBH4VCII\
kiHEKr8NP0r+68tzx8Ih0gGoVCKIkiHiATfCADKQMoIgJ8Ih98fCIgIABBKGoiBSkDACIhIAApAwgi\
InwgAykDECITfCIUQp/Y+dnCkdqCm3+FQiCJIhVCu86qptjQ67O7f3wiIyAhhUIoiSIkIBR8IAMpAx\
giFHwiJSAVhUIwiSImhUIgiSInIAApA0AgACkDICIoIAApAwAiKXwgAykDACIVfCIqhULRhZrv+s+U\
h9EAhUIgiSIrQoiS853/zPmE6gB8IiwgKIVCKIkiLSAqfCADKQMIIip8Ii4gK4VCMIkiKyAsfCIsfC\
IvIBmFQiiJIhkgIHx8IiAgJ4VCMIkiJyAvfCIvIBmFQgGJIhkgDyAOIBYgLCAthUIBiSIsfHwiFiAf\
IByFQjCJIhyFQiCJIh8gJiAjfCIjfCImICyFQiiJIiwgFnx8IhZ8fCItIAkgCCAjICSFQgGJIiMgLn\
x8IiQgF4VCIIkiFyAcIB18Ihx8Ih0gI4VCKIkiIyAkfHwiJCAXhUIwiSIXhUIgiSIuIAsgCiAcIB6F\
QgGJIhwgJXx8Ih4gK4VCIIkiJSAYfCIYIByFQiiJIhwgHnx8Ih4gJYVCMIkiJSAYfCIYfCIrIBmFQi\
iJIhkgLXx8Ii0gLoVCMIkiLiArfCIrIBmFQgGJIhkgDyAJICAgGCAchUIBiSIYfHwiHCAWIB+FQjCJ\
IhaFQiCJIh8gFyAdfCIXfCIdIBiFQiiJIhggHHx8Ihx8fCIgIAggHiAXICOFQgGJIhd8IBJ8Ih4gJ4\
VCIIkiIyAWICZ8IhZ8IiYgF4VCKIkiFyAefHwiHiAjhUIwiSIjhUIgiSInIAogDiAWICyFQgGJIhYg\
JHx8IiQgJYVCIIkiJSAvfCIsIBaFQiiJIhYgJHx8IiQgJYVCMIkiJSAsfCIsfCIvIBmFQiiJIhkgIH\
x8IiAgJ4VCMIkiJyAvfCIvIBmFQgGJIhkgLSAsIBaFQgGJIhZ8IAJ8IiwgHCAfhUIwiSIchUIgiSIf\
ICMgJnwiI3wiJiAWhUIoiSIWICx8IBR8Iix8fCItIAwgIyAXhUIBiSIXICR8ICp8IiMgLoVCIIkiJC\
AcIB18Ihx8Ih0gF4VCKIkiFyAjfHwiIyAkhUIwiSIkhUIgiSIuIBwgGIVCAYkiGCAefCAVfCIcICWF\
QiCJIh4gK3wiJSAYhUIoiSIYIBx8IBN8IhwgHoVCMIkiHiAlfCIlfCIrIBmFQiiJIhkgLXx8Ii0gLo\
VCMIkiLiArfCIrIBmFQgGJIhkgICAlIBiFQgGJIhh8IAJ8IiAgLCAfhUIwiSIfhUIgiSIlICQgHXwi\
HXwiJCAYhUIoiSIYICB8IBN8IiB8fCIsIAwgHCAdIBeFQgGJIhd8fCIcICeFQiCJIh0gHyAmfCIffC\
ImIBeFQiiJIhcgHHwgFXwiHCAdhUIwiSIdhUIgiSInIAggCyAfIBaFQgGJIhYgI3x8Ih8gHoVCIIki\
HiAvfCIjIBaFQiiJIhYgH3x8Ih8gHoVCMIkiHiAjfCIjfCIvIBmFQiiJIhkgLHwgKnwiLCAnhUIwiS\
InIC98Ii8gGYVCAYkiGSAJIC0gIyAWhUIBiSIWfHwiIyAgICWFQjCJIiCFQiCJIiUgHSAmfCIdfCIm\
IBaFQiiJIhYgI3wgEnwiI3x8Ii0gDiAKIB0gF4VCAYkiFyAffHwiHSAuhUIgiSIfICAgJHwiIHwiJC\
AXhUIoiSIXIB18fCIdIB+FQjCJIh+FQiCJIi4gBiAgIBiFQgGJIhggHHwgFHwiHCAehUIgiSIeICt8\
IiAgGIVCKIkiGCAcfHwiHCAehUIwiSIeICB8IiB8IisgGYVCKIkiGSAtfHwiLSAuhUIwiSIuICt8Ii\
sgGYVCAYkiGSAMIA0gLCAgIBiFQgGJIhh8fCIgICMgJYVCMIkiI4VCIIkiJSAfICR8Ih98IiQgGIVC\
KIkiGCAgfHwiIHwgEnwiLCAcIB8gF4VCAYkiF3wgFHwiHCAnhUIgiSIfICMgJnwiI3wiJiAXhUIoiS\
IXIBx8ICp8IhwgH4VCMIkiH4VCIIkiJyAJIAcgIyAWhUIBiSIWIB18fCIdIB6FQiCJIh4gL3wiIyAW\
hUIoiSIWIB18fCIdIB6FQjCJIh4gI3wiI3wiLyAZhUIoiSIZICx8IBV8IiwgJ4VCMIkiJyAvfCIvIB\
mFQgGJIhkgCCAPIC0gIyAWhUIBiSIWfHwiIyAgICWFQjCJIiCFQiCJIiUgHyAmfCIffCImIBaFQiiJ\
IhYgI3x8IiN8fCItIAYgHyAXhUIBiSIXIB18IBN8Ih0gLoVCIIkiHyAgICR8IiB8IiQgF4VCKIkiFy\
AdfHwiHSAfhUIwiSIfhUIgiSIuIAogICAYhUIBiSIYIBx8IAJ8IhwgHoVCIIkiHiArfCIgIBiFQiiJ\
IhggHHx8IhwgHoVCMIkiHiAgfCIgfCIrIBmFQiiJIhkgLXx8Ii0gLoVCMIkiLiArfCIrIBmFQgGJIh\
kgLCAgIBiFQgGJIhh8IBN8IiAgIyAlhUIwiSIjhUIgiSIlIB8gJHwiH3wiJCAYhUIoiSIYICB8IBJ8\
IiB8fCIsIAcgHCAfIBeFQgGJIhd8IAJ8IhwgJ4VCIIkiHyAjICZ8IiN8IiYgF4VCKIkiFyAcfHwiHC\
AfhUIwiSIfhUIgiSInIAkgIyAWhUIBiSIWIB18fCIdIB6FQiCJIh4gL3wiIyAWhUIoiSIWIB18IBV8\
Ih0gHoVCMIkiHiAjfCIjfCIvIBmFQiiJIhkgLHx8IiwgJ4VCMIkiJyAvfCIvIBmFQgGJIhkgDSAtIC\
MgFoVCAYkiFnwgFHwiIyAgICWFQjCJIiCFQiCJIiUgHyAmfCIffCImIBaFQiiJIhYgI3x8IiN8fCIt\
IA4gHyAXhUIBiSIXIB18fCIdIC6FQiCJIh8gICAkfCIgfCIkIBeFQiiJIhcgHXwgKnwiHSAfhUIwiS\
IfhUIgiSIuIAwgCyAgIBiFQgGJIhggHHx8IhwgHoVCIIkiHiArfCIgIBiFQiiJIhggHHx8IhwgHoVC\
MIkiHiAgfCIgfCIrIBmFQiiJIhkgLXwgFHwiLSAuhUIwiSIuICt8IisgGYVCAYkiGSALICwgICAYhU\
IBiSIYfCAVfCIgICMgJYVCMIkiI4VCIIkiJSAfICR8Ih98IiQgGIVCKIkiGCAgfHwiIHx8IiwgCiAG\
IBwgHyAXhUIBiSIXfHwiHCAnhUIgiSIfICMgJnwiI3wiJiAXhUIoiSIXIBx8fCIcIB+FQjCJIh+FQi\
CJIicgDCAjIBaFQgGJIhYgHXwgE3wiHSAehUIgiSIeIC98IiMgFoVCKIkiFiAdfHwiHSAehUIwiSIe\
ICN8IiN8Ii8gGYVCKIkiGSAsfHwiLCAnhUIwiSInIC98Ii8gGYVCAYkiGSAJIC0gIyAWhUIBiSIWfC\
AqfCIjICAgJYVCMIkiIIVCIIkiJSAfICZ8Ih98IiYgFoVCKIkiFiAjfHwiI3wgEnwiLSANIB8gF4VC\
AYkiFyAdfCASfCIdIC6FQiCJIh8gICAkfCIgfCIkIBeFQiiJIhcgHXx8Ih0gH4VCMIkiH4VCIIkiLi\
AHICAgGIVCAYkiGCAcfHwiHCAehUIgiSIeICt8IiAgGIVCKIkiGCAcfCACfCIcIB6FQjCJIh4gIHwi\
IHwiKyAZhUIoiSIZIC18fCItIC6FQjCJIi4gK3wiKyAZhUIBiSIZIA0gDiAsICAgGIVCAYkiGHx8Ii\
AgIyAlhUIwiSIjhUIgiSIlIB8gJHwiH3wiJCAYhUIoiSIYICB8fCIgfHwiLCAPIBwgHyAXhUIBiSIX\
fCAqfCIcICeFQiCJIh8gIyAmfCIjfCImIBeFQiiJIhcgHHx8IhwgH4VCMIkiH4VCIIkiJyAMICMgFo\
VCAYkiFiAdfHwiHSAehUIgiSIeIC98IiMgFoVCKIkiFiAdfCACfCIdIB6FQjCJIh4gI3wiI3wiLyAZ\
hUIoiSIZICx8IBN8IiwgJ4VCMIkiJyAvfCIvIBmFQgGJIhkgCyAIIC0gIyAWhUIBiSIWfHwiIyAgIC\
WFQjCJIiCFQiCJIiUgHyAmfCIffCImIBaFQiiJIhYgI3x8IiN8IBR8Ii0gByAfIBeFQgGJIhcgHXwg\
FXwiHSAuhUIgiSIfICAgJHwiIHwiJCAXhUIoiSIXIB18fCIdIB+FQjCJIh+FQiCJIi4gBiAgIBiFQg\
GJIhggHHx8IhwgHoVCIIkiHiArfCIgIBiFQiiJIhggHHwgFHwiHCAehUIwiSIeICB8IiB8IisgGYVC\
KIkiGSAtfHwiLSAuhUIwiSIuICt8IisgGYVCAYkiGSAMICwgICAYhUIBiSIYfHwiICAjICWFQjCJIi\
OFQiCJIiUgHyAkfCIffCIkIBiFQiiJIhggIHwgKnwiIHx8IiwgDiAHIBwgHyAXhUIBiSIXfHwiHCAn\
hUIgiSIfICMgJnwiI3wiJiAXhUIoiSIXIBx8fCIcIB+FQjCJIh+FQiCJIicgCyANICMgFoVCAYkiFi\
AdfHwiHSAehUIgiSIeIC98IiMgFoVCKIkiFiAdfHwiHSAehUIwiSIeICN8IiN8Ii8gGYVCKIkiGSAs\
fHwiLCAPICAgJYVCMIkiICAkfCIkIBiFQgGJIhggHHx8IhwgHoVCIIkiHiArfCIlIBiFQiiJIhggHH\
wgEnwiHCAehUIwiSIeICV8IiUgGIVCAYkiGHx8IisgCiAtICMgFoVCAYkiFnwgE3wiIyAghUIgiSIg\
IB8gJnwiH3wiJiAWhUIoiSIWICN8fCIjICCFQjCJIiCFQiCJIi0gHyAXhUIBiSIXIB18IAJ8Ih0gLo\
VCIIkiHyAkfCIkIBeFQiiJIhcgHXwgFXwiHSAfhUIwiSIfICR8IiR8Ii4gGIVCKIkiGCArfCAUfCIr\
IC2FQjCJIi0gLnwiLiAYhUIBiSIYIAkgDiAcICQgF4VCAYkiF3x8IhwgLCAnhUIwiSIkhUIgiSInIC\
AgJnwiIHwiJiAXhUIoiSIXIBx8fCIcfHwiLCAPIAYgICAWhUIBiSIWIB18fCIdIB6FQiCJIh4gJCAv\
fCIgfCIkIBaFQiiJIhYgHXx8Ih0gHoVCMIkiHoVCIIkiLyAIICAgGYVCAYkiGSAjfCAVfCIgIB+FQi\
CJIh8gJXwiIyAZhUIoiSIZICB8fCIgIB+FQjCJIh8gI3wiI3wiJSAYhUIoiSIYICx8fCIsIAwgHCAn\
hUIwiSIcICZ8IiYgF4VCAYkiFyAdfHwiHSAfhUIgiSIfIC58IicgF4VCKIkiFyAdfCATfCIdIB+FQj\
CJIh8gJ3wiJyAXhUIBiSIXfHwiLiAjIBmFQgGJIhkgK3wgKnwiIyAchUIgiSIcIB4gJHwiHnwiJCAZ\
hUIoiSIZICN8IBJ8IiMgHIVCMIkiHIVCIIkiKyAKICAgHiAWhUIBiSIWfHwiHiAthUIgiSIgICZ8Ii\
YgFoVCKIkiFiAefCACfCIeICCFQjCJIiAgJnwiJnwiLSAXhUIoiSIXIC58IBJ8Ii4gK4VCMIkiKyAt\
fCItIBeFQgGJIhcgCiAmIBaFQgGJIhYgHXx8Ih0gLCAvhUIwiSImhUIgiSIsIBwgJHwiHHwiJCAWhU\
IoiSIWIB18IBN8Ih18fCIvIBwgGYVCAYkiGSAefCAqfCIcIB+FQiCJIh4gJiAlfCIffCIlIBmFQiiJ\
IhkgHHwgAnwiHCAehUIwiSIehUIgiSImIAYgByAjIB8gGIVCAYkiGHx8Ih8gIIVCIIkiICAnfCIjIB\
iFQiiJIhggH3x8Ih8gIIVCMIkiICAjfCIjfCInIBeFQiiJIhcgL3x8Ii8gJoVCMIkiJiAnfCInIBeF\
QgGJIhcgE3wgDiAJICMgGIVCAYkiGCAufHwiIyAdICyFQjCJIh2FQiCJIiwgHiAlfCIefCIlIBiFQi\
iJIhggI3x8IiN8Ii4gFHwgDSAcIB0gJHwiHSAWhUIBiSIWfHwiHCAghUIgiSIgIC18IiQgFoVCKIki\
FiAcfCAVfCIcICCFQjCJIiAgJHwiJCAMIB4gGYVCAYkiGSAffCAUfCIeICuFQiCJIh8gHXwiHSAZhU\
IoiSIZIB58fCIeIB+FQjCJIh8gLoVCIIkiK3wiLSAXhUIoiSIXfCIufCAjICyFQjCJIiMgJXwiJSAY\
hUIBiSIYIBJ8IB58Ih4gAnwgICAehUIgiSIeICd8IiAgGIVCKIkiGHwiJyAehUIwiSIeICB8IiAgGI\
VCAYkiGHwiLHwgLyAVfCAkIBaFQgGJIhZ8IiQgKnwgJCAjhUIgiSIjIB8gHXwiHXwiHyAWhUIoiSIW\
fCIkICOFQjCJIiMgLIVCIIkiLCAHIBwgBnwgHSAZhUIBiSIZfCIcfCAcICaFQiCJIhwgJXwiHSAZhU\
IoiSIZfCIlIByFQjCJIhwgHXwiHXwiJiAYhUIoiSIYfCIvIBJ8IAkgCCAuICuFQjCJIhIgLXwiKyAX\
hUIBiSIXfCAkfCIkfCAkIByFQiCJIhwgIHwiICAXhUIoiSIXfCIkIByFQjCJIhwgIHwiICAXhUIBiS\
IXfCItfCAtIA0gJyAMfCAdIBmFQgGJIgh8Ihl8IBkgEoVCIIkiEiAjIB98Ihl8Ih0gCIVCKIkiCHwi\
HyAShUIwiSIShUIgiSIjIA8gJSAOfCAZIBaFQgGJIhZ8Ihl8IBkgHoVCIIkiGSArfCIeIBaFQiiJIh\
Z8IiUgGYVCMIkiGSAefCIefCInIBeFQiiJIhd8IisgFXwgDyAfIAl8IC8gLIVCMIkiCSAmfCIVIBiF\
QgGJIhh8Ih98IBkgH4VCIIkiDyAgfCIZIBiFQiiJIhh8Ih8gD4VCMIkiDyAZfCIZIBiFQgGJIhh8Ii\
AgE3wgCiAkIA58IB4gFoVCAYkiDnwiE3wgEyAJhUIgiSIJIBIgHXwiCnwiEiAOhUIoiSIOfCITIAmF\
QjCJIgkgIIVCIIkiFiAGICUgDXwgCiAIhUIBiSIIfCIKfCAKIByFQiCJIgYgFXwiCiAIhUIoiSIIfC\
INIAaFQjCJIgYgCnwiCnwiFSAYhUIoiSIYfCIcICKFIA0gAnwgCSASfCIJIA6FQgGJIg18Ig4gFHwg\
DiAPhUIgiSIOICsgI4VCMIkiDyAnfCISfCICIA2FQiiJIg18IhQgDoVCMIkiDiACfCIChTcDCCAAIC\
kgDCAqIBIgF4VCAYkiEnwgE3wiE3wgEyAGhUIgiSIGIBl8IgwgEoVCKIkiEnwiE4UgByAfIAt8IAog\
CIVCAYkiCHwiCnwgCiAPhUIgiSIHIAl8IgkgCIVCKIkiCHwiCiAHhUIwiSIHIAl8IgmFNwMAIAEgEC\
ATIAaFQjCJIgaFIAkgCIVCAYmFNwMAIAAgKCAcIBaFQjCJIgiFIAIgDYVCAYmFNwMgIAAgESAIIBV8\
IgiFIBSFNwMYIAAgGyAGIAx8IgaFIAqFNwMQIAQgGiAIIBiFQgGJhSAOhTcDACAFICEgBiAShUIBiY\
UgB4U3AwAgA0GAAWokAAu1LQEgfyMAQcAAayICQRhqIgNCADcDACACQSBqIgRCADcDACACQThqIgVC\
ADcDACACQTBqIgZCADcDACACQShqIgdCADcDACACQQhqIgggASkACDcDACACQRBqIgkgASkAEDcDAC\
ADIAEoABgiCjYCACAEIAEoACAiAzYCACACIAEpAAA3AwAgAiABKAAcIgQ2AhwgAiABKAAkIgs2AiQg\
ByABKAAoIgw2AgAgAiABKAAsIgc2AiwgBiABKAAwIg02AgAgAiABKAA0IgY2AjQgBSABKAA4Ig42Ag\
AgAiABKAA8IgE2AjwgACAHIAwgAigCFCIFIAUgBiAMIAUgBCALIAMgCyAKIAQgByAKIAIoAgQiDyAA\
KAIQIhBqIAAoAggiEUEKdyISIAAoAgQiE3MgESATcyAAKAIMIhRzIAAoAgAiFWogAigCACIWakELdy\
AQaiIXc2pBDncgFGoiGEEKdyIZaiAJKAIAIgkgE0EKdyIaaiAIKAIAIgggFGogFyAacyAYc2pBD3cg\
EmoiGyAZcyACKAIMIgIgEmogGCAXQQp3IhdzIBtzakEMdyAaaiIYc2pBBXcgF2oiHCAYQQp3Ih1zIA\
UgF2ogGCAbQQp3IhdzIBxzakEIdyAZaiIYc2pBB3cgF2oiGUEKdyIbaiALIBxBCnciHGogFyAEaiAY\
IBxzIBlzakEJdyAdaiIXIBtzIB0gA2ogGSAYQQp3IhhzIBdzakELdyAcaiIZc2pBDXcgGGoiHCAZQQ\
p3Ih1zIBggDGogGSAXQQp3IhdzIBxzakEOdyAbaiIYc2pBD3cgF2oiGUEKdyIbaiAdIAZqIBkgGEEK\
dyIecyAXIA1qIBggHEEKdyIXcyAZc2pBBncgHWoiGHNqQQd3IBdqIhlBCnciHCAeIAFqIBkgGEEKdy\
IdcyAXIA5qIBggG3MgGXNqQQl3IB5qIhlzakEIdyAbaiIXQX9zcWogFyAZcWpBmfOJ1AVqQQd3IB1q\
IhhBCnciG2ogBiAcaiAXQQp3Ih4gCSAdaiAZQQp3IhkgGEF/c3FqIBggF3FqQZnzidQFakEGdyAcai\
IXQX9zcWogFyAYcWpBmfOJ1AVqQQh3IBlqIhhBCnciHCAMIB5qIBdBCnciHSAPIBlqIBsgGEF/c3Fq\
IBggF3FqQZnzidQFakENdyAeaiIXQX9zcWogFyAYcWpBmfOJ1AVqQQt3IBtqIhhBf3NxaiAYIBdxak\
GZ84nUBWpBCXcgHWoiGUEKdyIbaiACIBxqIBhBCnciHiABIB1qIBdBCnciHSAZQX9zcWogGSAYcWpB\
mfOJ1AVqQQd3IBxqIhdBf3NxaiAXIBlxakGZ84nUBWpBD3cgHWoiGEEKdyIcIBYgHmogF0EKdyIfIA\
0gHWogGyAYQX9zcWogGCAXcWpBmfOJ1AVqQQd3IB5qIhdBf3NxaiAXIBhxakGZ84nUBWpBDHcgG2oi\
GEF/c3FqIBggF3FqQZnzidQFakEPdyAfaiIZQQp3IhtqIAggHGogGEEKdyIdIAUgH2ogF0EKdyIeIB\
lBf3NxaiAZIBhxakGZ84nUBWpBCXcgHGoiF0F/c3FqIBcgGXFqQZnzidQFakELdyAeaiIYQQp3Ihkg\
ByAdaiAXQQp3IhwgDiAeaiAbIBhBf3NxaiAYIBdxakGZ84nUBWpBB3cgHWoiF0F/c3FqIBcgGHFqQZ\
nzidQFakENdyAbaiIYQX9zIh5xaiAYIBdxakGZ84nUBWpBDHcgHGoiG0EKdyIdaiAJIBhBCnciGGog\
DiAXQQp3IhdqIAwgGWogAiAcaiAbIB5yIBdzakGh1+f2BmpBC3cgGWoiGSAbQX9zciAYc2pBodfn9g\
ZqQQ13IBdqIhcgGUF/c3IgHXNqQaHX5/YGakEGdyAYaiIYIBdBf3NyIBlBCnciGXNqQaHX5/YGakEH\
dyAdaiIbIBhBf3NyIBdBCnciF3NqQaHX5/YGakEOdyAZaiIcQQp3Ih1qIAggG0EKdyIeaiAPIBhBCn\
ciGGogAyAXaiABIBlqIBwgG0F/c3IgGHNqQaHX5/YGakEJdyAXaiIXIBxBf3NyIB5zakGh1+f2BmpB\
DXcgGGoiGCAXQX9zciAdc2pBodfn9gZqQQ93IB5qIhkgGEF/c3IgF0EKdyIXc2pBodfn9gZqQQ53IB\
1qIhsgGUF/c3IgGEEKdyIYc2pBodfn9gZqQQh3IBdqIhxBCnciHWogByAbQQp3Ih5qIAYgGUEKdyIZ\
aiAKIBhqIBYgF2ogHCAbQX9zciAZc2pBodfn9gZqQQ13IBhqIhcgHEF/c3IgHnNqQaHX5/YGakEGdy\
AZaiIYIBdBf3NyIB1zakGh1+f2BmpBBXcgHmoiGSAYQX9zciAXQQp3IhtzakGh1+f2BmpBDHcgHWoi\
HCAZQX9zciAYQQp3IhhzakGh1+f2BmpBB3cgG2oiHUEKdyIXaiALIBlBCnciGWogDSAbaiAdIBxBf3\
NyIBlzakGh1+f2BmpBBXcgGGoiGyAXQX9zcWogDyAYaiAdIBxBCnciGEF/c3FqIBsgGHFqQdz57vh4\
akELdyAZaiIcIBdxakHc+e74eGpBDHcgGGoiHSAcQQp3IhlBf3NxaiAHIBhqIBwgG0EKdyIYQX9zcW\
ogHSAYcWpB3Pnu+HhqQQ53IBdqIhwgGXFqQdz57vh4akEPdyAYaiIeQQp3IhdqIA0gHUEKdyIbaiAW\
IBhqIBwgG0F/c3FqIB4gG3FqQdz57vh4akEOdyAZaiIdIBdBf3NxaiADIBlqIB4gHEEKdyIYQX9zcW\
ogHSAYcWpB3Pnu+HhqQQ93IBtqIhsgF3FqQdz57vh4akEJdyAYaiIcIBtBCnciGUF/c3FqIAkgGGog\
GyAdQQp3IhhBf3NxaiAcIBhxakHc+e74eGpBCHcgF2oiHSAZcWpB3Pnu+HhqQQl3IBhqIh5BCnciF2\
ogASAcQQp3IhtqIAIgGGogHSAbQX9zcWogHiAbcWpB3Pnu+HhqQQ53IBlqIhwgF0F/c3FqIAQgGWog\
HiAdQQp3IhhBf3NxaiAcIBhxakHc+e74eGpBBXcgG2oiGyAXcWpB3Pnu+HhqQQZ3IBhqIh0gG0EKdy\
IZQX9zcWogDiAYaiAbIBxBCnciGEF/c3FqIB0gGHFqQdz57vh4akEIdyAXaiIcIBlxakHc+e74eGpB\
BncgGGoiHkEKdyIfaiAWIBxBCnciF2ogCSAdQQp3IhtqIAggGWogHiAXQX9zcWogCiAYaiAcIBtBf3\
NxaiAeIBtxakHc+e74eGpBBXcgGWoiGCAXcWpB3Pnu+HhqQQx3IBtqIhkgGCAfQX9zcnNqQc76z8p6\
akEJdyAXaiIXIBkgGEEKdyIYQX9zcnNqQc76z8p6akEPdyAfaiIbIBcgGUEKdyIZQX9zcnNqQc76z8\
p6akEFdyAYaiIcQQp3Ih1qIAggG0EKdyIeaiANIBdBCnciF2ogBCAZaiALIBhqIBwgGyAXQX9zcnNq\
Qc76z8p6akELdyAZaiIYIBwgHkF/c3JzakHO+s/KempBBncgF2oiFyAYIB1Bf3Nyc2pBzvrPynpqQQ\
h3IB5qIhkgFyAYQQp3IhhBf3Nyc2pBzvrPynpqQQ13IB1qIhsgGSAXQQp3IhdBf3Nyc2pBzvrPynpq\
QQx3IBhqIhxBCnciHWogAyAbQQp3Ih5qIAIgGUEKdyIZaiAPIBdqIA4gGGogHCAbIBlBf3Nyc2pBzv\
rPynpqQQV3IBdqIhcgHCAeQX9zcnNqQc76z8p6akEMdyAZaiIYIBcgHUF/c3JzakHO+s/KempBDXcg\
HmoiGSAYIBdBCnciF0F/c3JzakHO+s/KempBDncgHWoiGyAZIBhBCnciGEF/c3JzakHO+s/KempBC3\
cgF2oiHEEKdyIgIAAoAgxqIA4gAyABIAsgFiAJIBYgByACIA8gASAWIA0gASAIIBUgESAUQX9zciAT\
c2ogBWpB5peKhQVqQQh3IBBqIh1BCnciHmogGiALaiASIBZqIBQgBGogDiAQIB0gEyASQX9zcnNqak\
Hml4qFBWpBCXcgFGoiFCAdIBpBf3Nyc2pB5peKhQVqQQl3IBJqIhIgFCAeQX9zcnNqQeaXioUFakEL\
dyAaaiIaIBIgFEEKdyIUQX9zcnNqQeaXioUFakENdyAeaiIQIBogEkEKdyISQX9zcnNqQeaXioUFak\
EPdyAUaiIdQQp3Ih5qIAogEEEKdyIfaiAGIBpBCnciGmogCSASaiAHIBRqIB0gECAaQX9zcnNqQeaX\
ioUFakEPdyASaiISIB0gH0F/c3JzakHml4qFBWpBBXcgGmoiFCASIB5Bf3Nyc2pB5peKhQVqQQd3IB\
9qIhogFCASQQp3IhJBf3Nyc2pB5peKhQVqQQd3IB5qIhAgGiAUQQp3IhRBf3Nyc2pB5peKhQVqQQh3\
IBJqIh1BCnciHmogAiAQQQp3Ih9qIAwgGkEKdyIaaiAPIBRqIAMgEmogHSAQIBpBf3Nyc2pB5peKhQ\
VqQQt3IBRqIhIgHSAfQX9zcnNqQeaXioUFakEOdyAaaiIUIBIgHkF/c3JzakHml4qFBWpBDncgH2oi\
GiAUIBJBCnciEEF/c3JzakHml4qFBWpBDHcgHmoiHSAaIBRBCnciHkF/c3JzakHml4qFBWpBBncgEG\
oiH0EKdyISaiACIBpBCnciFGogCiAQaiAdIBRBf3NxaiAfIBRxakGkorfiBWpBCXcgHmoiECASQX9z\
cWogByAeaiAfIB1BCnciGkF/c3FqIBAgGnFqQaSit+IFakENdyAUaiIdIBJxakGkorfiBWpBD3cgGm\
oiHiAdQQp3IhRBf3NxaiAEIBpqIB0gEEEKdyIaQX9zcWogHiAacWpBpKK34gVqQQd3IBJqIh0gFHFq\
QaSit+IFakEMdyAaaiIfQQp3IhJqIAwgHkEKdyIQaiAGIBpqIB0gEEF/c3FqIB8gEHFqQaSit+IFak\
EIdyAUaiIeIBJBf3NxaiAFIBRqIB8gHUEKdyIUQX9zcWogHiAUcWpBpKK34gVqQQl3IBBqIhAgEnFq\
QaSit+IFakELdyAUaiIdIBBBCnciGkF/c3FqIA4gFGogECAeQQp3IhRBf3NxaiAdIBRxakGkorfiBW\
pBB3cgEmoiHiAacWpBpKK34gVqQQd3IBRqIh9BCnciEmogCSAdQQp3IhBqIAMgFGogHiAQQX9zcWog\
HyAQcWpBpKK34gVqQQx3IBpqIh0gEkF/c3FqIA0gGmogHyAeQQp3IhRBf3NxaiAdIBRxakGkorfiBW\
pBB3cgEGoiECAScWpBpKK34gVqQQZ3IBRqIh4gEEEKdyIaQX9zcWogCyAUaiAQIB1BCnciFEF/c3Fq\
IB4gFHFqQaSit+IFakEPdyASaiIQIBpxakGkorfiBWpBDXcgFGoiHUEKdyIfaiAPIBBBCnciIWogBS\
AeQQp3IhJqIAEgGmogCCAUaiAQIBJBf3NxaiAdIBJxakGkorfiBWpBC3cgGmoiFCAdQX9zciAhc2pB\
8/3A6wZqQQl3IBJqIhIgFEF/c3IgH3NqQfP9wOsGakEHdyAhaiIaIBJBf3NyIBRBCnciFHNqQfP9wO\
sGakEPdyAfaiIQIBpBf3NyIBJBCnciEnNqQfP9wOsGakELdyAUaiIdQQp3Ih5qIAsgEEEKdyIfaiAK\
IBpBCnciGmogDiASaiAEIBRqIB0gEEF/c3IgGnNqQfP9wOsGakEIdyASaiISIB1Bf3NyIB9zakHz/c\
DrBmpBBncgGmoiFCASQX9zciAec2pB8/3A6wZqQQZ3IB9qIhogFEF/c3IgEkEKdyISc2pB8/3A6wZq\
QQ53IB5qIhAgGkF/c3IgFEEKdyIUc2pB8/3A6wZqQQx3IBJqIh1BCnciHmogDCAQQQp3Ih9qIAggGk\
EKdyIaaiANIBRqIAMgEmogHSAQQX9zciAac2pB8/3A6wZqQQ13IBRqIhIgHUF/c3IgH3NqQfP9wOsG\
akEFdyAaaiIUIBJBf3NyIB5zakHz/cDrBmpBDncgH2oiGiAUQX9zciASQQp3IhJzakHz/cDrBmpBDX\
cgHmoiECAaQX9zciAUQQp3IhRzakHz/cDrBmpBDXcgEmoiHUEKdyIeaiAGIBRqIAkgEmogHSAQQX9z\
ciAaQQp3IhpzakHz/cDrBmpBB3cgFGoiFCAdQX9zciAQQQp3IhBzakHz/cDrBmpBBXcgGmoiEkEKdy\
IdIAogEGogFEEKdyIfIAMgGmogHiASQX9zcWogEiAUcWpB6e210wdqQQ93IBBqIhRBf3NxaiAUIBJx\
akHp7bXTB2pBBXcgHmoiEkF/c3FqIBIgFHFqQenttdMHakEIdyAfaiIaQQp3IhBqIAIgHWogEkEKdy\
IeIA8gH2ogFEEKdyIfIBpBf3NxaiAaIBJxakHp7bXTB2pBC3cgHWoiEkF/c3FqIBIgGnFqQenttdMH\
akEOdyAfaiIUQQp3Ih0gASAeaiASQQp3IiEgByAfaiAQIBRBf3NxaiAUIBJxakHp7bXTB2pBDncgHm\
oiEkF/c3FqIBIgFHFqQenttdMHakEGdyAQaiIUQX9zcWogFCAScWpB6e210wdqQQ53ICFqIhpBCnci\
EGogDSAdaiAUQQp3Ih4gBSAhaiASQQp3Ih8gGkF/c3FqIBogFHFqQenttdMHakEGdyAdaiISQX9zcW\
ogEiAacWpB6e210wdqQQl3IB9qIhRBCnciHSAGIB5qIBJBCnciISAIIB9qIBAgFEF/c3FqIBQgEnFq\
QenttdMHakEMdyAeaiISQX9zcWogEiAUcWpB6e210wdqQQl3IBBqIhRBf3NxaiAUIBJxakHp7bXTB2\
pBDHcgIWoiGkEKdyIQaiAOIBJBCnciHmogECAMIB1qIBRBCnciHyAEICFqIB4gGkF/c3FqIBogFHFq\
QenttdMHakEFdyAdaiISQX9zcWogEiAacWpB6e210wdqQQ93IB5qIhRBf3NxaiAUIBJxakHp7bXTB2\
pBCHcgH2oiGiAUQQp3Ih1zIB8gDWogFCASQQp3Ig1zIBpzakEIdyAQaiISc2pBBXcgDWoiFEEKdyIQ\
aiAaQQp3IgMgD2ogDSAMaiASIANzIBRzakEMdyAdaiIMIBBzIB0gCWogFCASQQp3Ig1zIAxzakEJdy\
ADaiIDc2pBDHcgDWoiDyADQQp3IglzIA0gBWogAyAMQQp3IgxzIA9zakEFdyAQaiIDc2pBDncgDGoi\
DUEKdyIFaiAPQQp3Ig4gCGogDCAEaiADIA5zIA1zakEGdyAJaiIEIAVzIAkgCmogDSADQQp3IgNzIA\
RzakEIdyAOaiIMc2pBDXcgA2oiDSAMQQp3Ig5zIAMgBmogDCAEQQp3IgNzIA1zakEGdyAFaiIEc2pB\
BXcgA2oiDEEKdyIFajYCCCAAIBEgCiAXaiAcIBsgGUEKdyIKQX9zcnNqQc76z8p6akEIdyAYaiIPQQ\
p3aiADIBZqIAQgDUEKdyIDcyAMc2pBD3cgDmoiDUEKdyIWajYCBCAAIBMgASAYaiAPIBwgG0EKdyIB\
QX9zcnNqQc76z8p6akEFdyAKaiIJaiAOIAJqIAwgBEEKdyICcyANc2pBDXcgA2oiBEEKd2o2AgAgAC\
gCECEMIAAgASAVaiAGIApqIAkgDyAgQX9zcnNqQc76z8p6akEGd2ogAyALaiANIAVzIARzakELdyAC\
aiIKajYCECAAIAEgDGogBWogAiAHaiAEIBZzIApzakELd2o2AgwLhCgCMH8BfiMAQcAAayIDQRhqIg\
RCADcDACADQSBqIgVCADcDACADQThqIgZCADcDACADQTBqIgdCADcDACADQShqIghCADcDACADQQhq\
IgkgASkACDcDACADQRBqIgogASkAEDcDACAEIAEoABgiCzYCACAFIAEoACAiBDYCACADIAEpAAA3Aw\
AgAyABKAAcIgU2AhwgAyABKAAkIgw2AiQgCCABKAAoIg02AgAgAyABKAAsIgg2AiwgByABKAAwIg42\
AgAgAyABKAA0Igc2AjQgBiABKAA4Ig82AgAgAyABKAA8IgE2AjwgACAIIAEgBCAFIAcgCCALIAQgDC\
AMIA0gDyABIAQgBCALIAEgDSAPIAggBSAHIAEgBSAIIAsgByAHIA4gBSALIABBJGoiECgCACIRIABB\
FGoiEigCACITamoiBkGZmoPfBXNBEHciFEG66r+qemoiFSARc0EUdyIWIAZqaiIXIBRzQRh3IhggFW\
oiGSAWc0EZdyIaIABBIGoiGygCACIVIABBEGoiHCgCACIdaiAKKAIAIgZqIgogAnNBq7OP/AFzQRB3\
Ih5B8ua74wNqIh8gFXNBFHciICAKaiADKAIUIgJqIiFqaiIiIABBHGoiIygCACIWIABBDGoiJCgCAC\
IlaiAJKAIAIglqIgogACkDACIzQiCIp3NBjNGV2HlzQRB3IhRBhd2e23tqIiYgFnNBFHciJyAKaiAD\
KAIMIgpqIiggFHNBGHciKXNBEHciKiAAQRhqIisoAgAiLCAAKAIIIi1qIAMoAgAiFGoiLiAzp3NB/6\
S5iAVzQRB3Ii9B58yn0AZqIjAgLHNBFHciMSAuaiADKAIEIgNqIi4gL3NBGHciLyAwaiIwaiIyIBpz\
QRR3IhogImpqIiIgKnNBGHciKiAyaiIyIBpzQRl3IhogASAPIBcgMCAxc0EZdyIwamoiFyAhIB5zQR\
h3Ih5zQRB3IiEgKSAmaiImaiIpIDBzQRR3IjAgF2pqIhdqaiIxIAwgBCAmICdzQRl3IiYgLmpqIicg\
GHNBEHciGCAeIB9qIh5qIh8gJnNBFHciJiAnamoiJyAYc0EYdyIYc0EQdyIuIAggDSAeICBzQRl3Ih\
4gKGpqIiAgL3NBEHciKCAZaiIZIB5zQRR3Ih4gIGpqIiAgKHNBGHciKCAZaiIZaiIvIBpzQRR3Ihog\
MWpqIjEgLnNBGHciLiAvaiIvIBpzQRl3IhogASAMICIgGSAec0EZdyIZamoiHiAXICFzQRh3IhdzQR\
B3IiEgGCAfaiIYaiIfIBlzQRR3IhkgHmpqIh5qaiIiIAQgICAYICZzQRl3IhhqIAZqIiAgKnNBEHci\
JiAXIClqIhdqIikgGHNBFHciGCAgamoiICAmc0EYdyImc0EQdyIqIA0gDyAXIDBzQRl3IhcgJ2pqIi\
cgKHNBEHciKCAyaiIwIBdzQRR3IhcgJ2pqIicgKHNBGHciKCAwaiIwaiIyIBpzQRR3IhogImpqIiIg\
KnNBGHciKiAyaiIyIBpzQRl3IhogMSAwIBdzQRl3IhdqIAJqIjAgHiAhc0EYdyIec0EQdyIhICYgKW\
oiJmoiKSAXc0EUdyIXIDBqIApqIjBqaiIxIA4gJiAYc0EZdyIYICdqIANqIiYgLnNBEHciJyAeIB9q\
Ih5qIh8gGHNBFHciGCAmamoiJiAnc0EYdyInc0EQdyIuIB4gGXNBGXciGSAgaiAUaiIeIChzQRB3Ii\
AgL2oiKCAZc0EUdyIZIB5qIAlqIh4gIHNBGHciICAoaiIoaiIvIBpzQRR3IhogMWpqIjEgLnNBGHci\
LiAvaiIvIBpzQRl3IhogIiAoIBlzQRl3IhlqIAJqIiIgMCAhc0EYdyIhc0EQdyIoICcgH2oiH2oiJy\
AZc0EUdyIZICJqIAlqIiJqaiIwIA4gHiAfIBhzQRl3IhhqaiIeICpzQRB3Ih8gISApaiIhaiIpIBhz\
QRR3IhggHmogFGoiHiAfc0EYdyIfc0EQdyIqIAQgCCAhIBdzQRl3IhcgJmpqIiEgIHNBEHciICAyai\
ImIBdzQRR3IhcgIWpqIiEgIHNBGHciICAmaiImaiIyIBpzQRR3IhogMGogA2oiMCAqc0EYdyIqIDJq\
IjIgGnNBGXciGiAMIDEgJiAXc0EZdyIXamoiJiAiIChzQRh3IiJzQRB3IiggHyApaiIfaiIpIBdzQR\
R3IhcgJmogBmoiJmpqIjEgDyANIB8gGHNBGXciGCAhamoiHyAuc0EQdyIhICIgJ2oiImoiJyAYc0EU\
dyIYIB9qaiIfICFzQRh3IiFzQRB3Ii4gCyAiIBlzQRl3IhkgHmogCmoiHiAgc0EQdyIgIC9qIiIgGX\
NBFHciGSAeamoiHiAgc0EYdyIgICJqIiJqIi8gGnNBFHciGiAxamoiMSAuc0EYdyIuIC9qIi8gGnNB\
GXciGiAOIAcgMCAiIBlzQRl3IhlqaiIiICYgKHNBGHciJnNBEHciKCAhICdqIiFqIicgGXNBFHciGS\
AiamoiImogBmoiMCAeICEgGHNBGXciGGogCmoiHiAqc0EQdyIhICYgKWoiJmoiKSAYc0EUdyIYIB5q\
IANqIh4gIXNBGHciIXNBEHciKiAMIAUgJiAXc0EZdyIXIB9qaiIfICBzQRB3IiAgMmoiJiAXc0EUdy\
IXIB9qaiIfICBzQRh3IiAgJmoiJmoiMiAac0EUdyIaIDBqIBRqIjAgKnNBGHciKiAyaiIyIBpzQRl3\
IhogBCABIDEgJiAXc0EZdyIXamoiJiAiIChzQRh3IiJzQRB3IiggISApaiIhaiIpIBdzQRR3IhcgJm\
pqIiZqaiIxIAsgISAYc0EZdyIYIB9qIAlqIh8gLnNBEHciISAiICdqIiJqIicgGHNBFHciGCAfamoi\
HyAhc0EYdyIhc0EQdyIuIA0gIiAZc0EZdyIZIB5qIAJqIh4gIHNBEHciICAvaiIiIBlzQRR3IhkgHm\
pqIh4gIHNBGHciICAiaiIiaiIvIBpzQRR3IhogMWpqIjEgLnNBGHciLiAvaiIvIBpzQRl3IhogMCAi\
IBlzQRl3IhlqIAlqIiIgJiAoc0EYdyImc0EQdyIoICEgJ2oiIWoiJyAZc0EUdyIZICJqIAZqIiJqai\
IwIAUgHiAhIBhzQRl3IhhqIAJqIh4gKnNBEHciISAmIClqIiZqIikgGHNBFHciGCAeamoiHiAhc0EY\
dyIhc0EQdyIqIAwgJiAXc0EZdyIXIB9qaiIfICBzQRB3IiAgMmoiJiAXc0EUdyIXIB9qIBRqIh8gIH\
NBGHciICAmaiImaiIyIBpzQRR3IhogMGpqIjAgKnNBGHciKiAyaiIyIBpzQRl3IhogByAxICYgF3NB\
GXciF2ogCmoiJiAiIChzQRh3IiJzQRB3IiggISApaiIhaiIpIBdzQRR3IhcgJmpqIiZqaiIxIA8gIS\
AYc0EZdyIYIB9qaiIfIC5zQRB3IiEgIiAnaiIiaiInIBhzQRR3IhggH2ogA2oiHyAhc0EYdyIhc0EQ\
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\
ciAJQQh2QYD+A3EgCUEYdnJyNgIQIAMgASgAFCIJQRh0IAlBCHRBgID8B3FyIAlBCHZBgP4DcSAJQR\
h2cnI2AhQgAyABKAAcIglBGHQgCUEIdEGAgPwHcXIgCUEIdkGA/gNxIAlBGHZyciIKNgIcIAMgASgA\
ICIJQRh0IAlBCHRBgID8B3FyIAlBCHZBgP4DcSAJQRh2cnIiCzYCICADIAEoABgiCUEYdCAJQQh0QY\
CA/AdxciAJQQh2QYD+A3EgCUEYdnJyIgw2AhggAygCACENIAMoAgQhDiADKAIIIQ8gAygCECEQIAMo\
AgwhESADKAIUIRIgAyABKAAkIglBGHQgCUEIdEGAgPwHcXIgCUEIdkGA/gNxIAlBGHZyciITNgIkIA\
MgASgAKCIJQRh0IAlBCHRBgID8B3FyIAlBCHZBgP4DcSAJQRh2cnIiFDYCKCADIAEoADAiCUEYdCAJ\
QQh0QYCA/AdxciAJQQh2QYD+A3EgCUEYdnJyIhU2AjAgAyABKAAsIglBGHQgCUEIdEGAgPwHcXIgCU\
EIdkGA/gNxIAlBGHZyciIWNgIsIAMgASgANCIJQRh0IAlBCHRBgID8B3FyIAlBCHZBgP4DcSAJQRh2\
cnIiCTYCNCADIAEoADgiF0EYdCAXQQh0QYCA/AdxciAXQQh2QYD+A3EgF0EYdnJyIhc2AjggAyABKA\
A8IhhBGHQgGEEIdEGAgPwHcXIgGEEIdkGA/gNxIBhBGHZyciIYNgI8IAUgEyAKcyAYcyAMIBBzIBVz\
IBEgDnMgE3MgF3NBAXciGXNBAXciGnNBAXciGyAKIBJzIAlzIBAgD3MgFHMgGHNBAXciHHNBAXciHX\
MgGCAJcyAdcyAVIBRzIBxzIBtzQQF3Ih5zQQF3Ih9zIBogHHMgHnMgGSAYcyAbcyAXIBVzIBpzIBYg\
E3MgGXMgCyAMcyAXcyASIBFzIBZzIA8gDXMgC3MgCXNBAXciIHNBAXciIXNBAXciInNBAXciI3NBAX\
ciJHNBAXciJXNBAXciJnNBAXciJyAdICFzIAkgFnMgIXMgFCALcyAgcyAdc0EBdyIoc0EBdyIpcyAc\
ICBzIChzIB9zQQF3IipzQQF3IitzIB8gKXMgK3MgHiAocyAqcyAnc0EBdyIsc0EBdyItcyAmICpzIC\
xzICUgH3MgJ3MgJCAecyAmcyAjIBtzICVzICIgGnMgJHMgISAZcyAjcyAgIBdzICJzIClzQQF3Ii5z\
QQF3Ii9zQQF3IjBzQQF3IjFzQQF3IjJzQQF3IjNzQQF3IjRzQQF3IjUgKyAvcyApICNzIC9zICggIn\
MgLnMgK3NBAXciNnNBAXciN3MgKiAucyA2cyAtc0EBdyI4c0EBdyI5cyAtIDdzIDlzICwgNnMgOHMg\
NXNBAXciOnNBAXciO3MgNCA4cyA6cyAzIC1zIDVzIDIgLHMgNHMgMSAncyAzcyAwICZzIDJzIC8gJX\
MgMXMgLiAkcyAwcyA3c0EBdyI8c0EBdyI9c0EBdyI+c0EBdyI/c0EBdyJAc0EBdyJBc0EBdyJCc0EB\
dyJDIDkgPXMgNyAxcyA9cyA2IDBzIDxzIDlzQQF3IkRzQQF3IkVzIDggPHMgRHMgO3NBAXciRnNBAX\
ciR3MgOyBFcyBHcyA6IERzIEZzIENzQQF3IkhzQQF3IklzIEIgRnMgSHMgQSA7cyBDcyBAIDpzIEJz\
ID8gNXMgQXMgPiA0cyBAcyA9IDNzID9zIDwgMnMgPnMgRXNBAXciSnNBAXciS3NBAXciTHNBAXciTX\
NBAXciTnNBAXciT3NBAXciUHNBAXdqIEYgSnMgRCA+cyBKcyBHc0EBdyJRcyBJc0EBdyJSIEUgP3Mg\
S3MgUXNBAXciUyBMIEEgOiA5IDwgMSAmIB8gKCAhIBcgEyAQIAVBHnciVGogDiAHIAZBHnciECACcy\
AFcSACc2pqIA0gCCAFQQV3aiACIAdzIAZxIAdzampBmfOJ1AVqIg5BBXdqQZnzidQFaiJVQR53IgUg\
DkEedyINcyACIA9qIA4gVCAQc3EgEHNqIFVBBXdqQZnzidQFaiIOcSANc2ogECARaiBVIA0gVHNxIF\
RzaiAOQQV3akGZ84nUBWoiEEEFd2pBmfOJ1AVqIhFBHnciD2ogBSAMaiARIBBBHnciEyAOQR53Igxz\
cSAMc2ogDSASaiAMIAVzIBBxIAVzaiARQQV3akGZ84nUBWoiEUEFd2pBmfOJ1AVqIhJBHnciBSARQR\
53IhBzIAogDGogESAPIBNzcSATc2ogEkEFd2pBmfOJ1AVqIgpxIBBzaiALIBNqIBAgD3MgEnEgD3Nq\
IApBBXdqQZnzidQFaiIMQQV3akGZ84nUBWoiD0EedyILaiAVIApBHnciF2ogCyAMQR53IhNzIBQgEG\
ogDCAXIAVzcSAFc2ogD0EFd2pBmfOJ1AVqIhRxIBNzaiAWIAVqIA8gEyAXc3EgF3NqIBRBBXdqQZnz\
idQFaiIVQQV3akGZ84nUBWoiFiAVQR53IhcgFEEedyIFc3EgBXNqIAkgE2ogBSALcyAVcSALc2ogFk\
EFd2pBmfOJ1AVqIhRBBXdqQZnzidQFaiIVQR53IglqIBkgFkEedyILaiAJIBRBHnciE3MgGCAFaiAU\
IAsgF3NxIBdzaiAVQQV3akGZ84nUBWoiGHEgE3NqICAgF2ogEyALcyAVcSALc2ogGEEFd2pBmfOJ1A\
VqIgVBBXdqQZnzidQFaiILIAVBHnciFCAYQR53IhdzcSAXc2ogHCATaiAFIBcgCXNxIAlzaiALQQV3\
akGZ84nUBWoiCUEFd2pBmfOJ1AVqIhhBHnciBWogHSAUaiAJQR53IhMgC0EedyILcyAYc2ogGiAXai\
ALIBRzIAlzaiAYQQV3akGh1+f2BmoiCUEFd2pBodfn9gZqIhdBHnciGCAJQR53IhRzICIgC2ogBSAT\
cyAJc2ogF0EFd2pBodfn9gZqIglzaiAbIBNqIBQgBXMgF3NqIAlBBXdqQaHX5/YGaiIXQQV3akGh1+\
f2BmoiBUEedyILaiAeIBhqIBdBHnciEyAJQR53IglzIAVzaiAjIBRqIAkgGHMgF3NqIAVBBXdqQaHX\
5/YGaiIXQQV3akGh1+f2BmoiGEEedyIFIBdBHnciFHMgKSAJaiALIBNzIBdzaiAYQQV3akGh1+f2Bm\
oiCXNqICQgE2ogFCALcyAYc2ogCUEFd2pBodfn9gZqIhdBBXdqQaHX5/YGaiIYQR53IgtqICUgBWog\
F0EedyITIAlBHnciCXMgGHNqIC4gFGogCSAFcyAXc2ogGEEFd2pBodfn9gZqIhdBBXdqQaHX5/YGai\
IYQR53IgUgF0EedyIUcyAqIAlqIAsgE3MgF3NqIBhBBXdqQaHX5/YGaiIJc2ogLyATaiAUIAtzIBhz\
aiAJQQV3akGh1+f2BmoiF0EFd2pBodfn9gZqIhhBHnciC2ogMCAFaiAXQR53IhMgCUEedyIJcyAYc2\
ogKyAUaiAJIAVzIBdzaiAYQQV3akGh1+f2BmoiF0EFd2pBodfn9gZqIhhBHnciBSAXQR53IhRzICcg\
CWogCyATcyAXc2ogGEEFd2pBodfn9gZqIhVzaiA2IBNqIBQgC3MgGHNqIBVBBXdqQaHX5/YGaiILQQ\
V3akGh1+f2BmoiE0EedyIJaiA3IAVqIAtBHnciFyAVQR53IhhzIBNxIBcgGHFzaiAsIBRqIBggBXMg\
C3EgGCAFcXNqIBNBBXdqQdz57vh4aiITQQV3akHc+e74eGoiFEEedyIFIBNBHnciC3MgMiAYaiATIA\
kgF3NxIAkgF3FzaiAUQQV3akHc+e74eGoiGHEgBSALcXNqIC0gF2ogFCALIAlzcSALIAlxc2ogGEEF\
d2pB3Pnu+HhqIhNBBXdqQdz57vh4aiIUQR53IglqIDggBWogFCATQR53IhcgGEEedyIYc3EgFyAYcX\
NqIDMgC2ogGCAFcyATcSAYIAVxc2ogFEEFd2pB3Pnu+HhqIhNBBXdqQdz57vh4aiIUQR53IgUgE0Ee\
dyILcyA9IBhqIBMgCSAXc3EgCSAXcXNqIBRBBXdqQdz57vh4aiIYcSAFIAtxc2ogNCAXaiALIAlzIB\
RxIAsgCXFzaiAYQQV3akHc+e74eGoiE0EFd2pB3Pnu+HhqIhRBHnciCWogRCAYQR53IhdqIAkgE0Ee\
dyIYcyA+IAtqIBMgFyAFc3EgFyAFcXNqIBRBBXdqQdz57vh4aiILcSAJIBhxc2ogNSAFaiAUIBggF3\
NxIBggF3FzaiALQQV3akHc+e74eGoiE0EFd2pB3Pnu+HhqIhQgE0EedyIXIAtBHnciBXNxIBcgBXFz\
aiA/IBhqIAUgCXMgE3EgBSAJcXNqIBRBBXdqQdz57vh4aiITQQV3akHc+e74eGoiFUEedyIJaiA7IB\
RBHnciGGogCSATQR53IgtzIEUgBWogEyAYIBdzcSAYIBdxc2ogFUEFd2pB3Pnu+HhqIgVxIAkgC3Fz\
aiBAIBdqIAsgGHMgFXEgCyAYcXNqIAVBBXdqQdz57vh4aiITQQV3akHc+e74eGoiFCATQR53IhggBU\
EedyIXc3EgGCAXcXNqIEogC2ogEyAXIAlzcSAXIAlxc2ogFEEFd2pB3Pnu+HhqIglBBXdqQdz57vh4\
aiIFQR53IgtqIEsgGGogCUEedyITIBRBHnciFHMgBXNqIEYgF2ogFCAYcyAJc2ogBUEFd2pB1oOL03\
xqIglBBXdqQdaDi9N8aiIXQR53IhggCUEedyIFcyBCIBRqIAsgE3MgCXNqIBdBBXdqQdaDi9N8aiIJ\
c2ogRyATaiAFIAtzIBdzaiAJQQV3akHWg4vTfGoiF0EFd2pB1oOL03xqIgtBHnciE2ogUSAYaiAXQR\
53IhQgCUEedyIJcyALc2ogQyAFaiAJIBhzIBdzaiALQQV3akHWg4vTfGoiF0EFd2pB1oOL03xqIhhB\
HnciBSAXQR53IgtzIE0gCWogEyAUcyAXc2ogGEEFd2pB1oOL03xqIglzaiBIIBRqIAsgE3MgGHNqIA\
lBBXdqQdaDi9N8aiIXQQV3akHWg4vTfGoiGEEedyITaiBJIAVqIBdBHnciFCAJQR53IglzIBhzaiBO\
IAtqIAkgBXMgF3NqIBhBBXdqQdaDi9N8aiIXQQV3akHWg4vTfGoiGEEedyIFIBdBHnciC3MgSiBAcy\
BMcyBTc0EBdyIVIAlqIBMgFHMgF3NqIBhBBXdqQdaDi9N8aiIJc2ogTyAUaiALIBNzIBhzaiAJQQV3\
akHWg4vTfGoiF0EFd2pB1oOL03xqIhhBHnciE2ogUCAFaiAXQR53IhQgCUEedyIJcyAYc2ogSyBBcy\
BNcyAVc0EBdyIVIAtqIAkgBXMgF3NqIBhBBXdqQdaDi9N8aiIXQQV3akHWg4vTfGoiGEEedyIWIBdB\
HnciC3MgRyBLcyBTcyBSc0EBdyAJaiATIBRzIBdzaiAYQQV3akHWg4vTfGoiCXNqIEwgQnMgTnMgFX\
NBAXcgFGogCyATcyAYc2ogCUEFd2pB1oOL03xqIhdBBXdqQdaDi9N8aiEFIBcgBmohBiAWIAdqIQcg\
CUEedyACaiECIAsgCGohCCABQcAAaiIBIARHDQALIAAgCDYCECAAIAc2AgwgACACNgIIIAAgBjYCBC\
AAIAU2AgALtiQCAX8SfiMAQcAAayICQQhqIAEpAAgiAzcDACACQRBqIAEpABAiBDcDACACQRhqIAEp\
ABgiBTcDACACQSBqIAEpACAiBjcDACACQShqIAEpACgiBzcDACACQTBqIAEpADAiCDcDACACQThqIA\
EpADgiCTcDACACIAEpAAAiCjcDACAAIAkgByAFIAMgACkDACILIAogACkDECIMhSINpyIBQQ12QfgP\
cUHgocAAaikDACABQf8BcUEDdEHgkcAAaikDAIUgDUIgiKdB/wFxQQN0QeCxwABqKQMAhSANQjCIp0\
H/AXFBA3RB4MHAAGopAwCFfYUiDqciAkEVdkH4D3FB4LHAAGopAwAgAkEFdkH4D3FB4MHAAGopAwCF\
IA5CKIinQf8BcUEDdEHgocAAaikDAIUgDkI4iKdBA3RB4JHAAGopAwCFIA18QgV+IAQgAUEVdkH4D3\
FB4LHAAGopAwAgAUEFdkH4D3FB4MHAAGopAwCFIA1CKIinQf8BcUEDdEHgocAAaikDAIUgDUI4iKdB\
A3RB4JHAAGopAwCFIAApAwgiD3xCBX4gAkENdkH4D3FB4KHAAGopAwAgAkH/AXFBA3RB4JHAAGopAw\
CFIA5CIIinQf8BcUEDdEHgscAAaikDAIUgDkIwiKdB/wFxQQN0QeDBwABqKQMAhX2FIg2nIgFBDXZB\
+A9xQeChwABqKQMAIAFB/wFxQQN0QeCRwABqKQMAhSANQiCIp0H/AXFBA3RB4LHAAGopAwCFIA1CMI\
inQf8BcUEDdEHgwcAAaikDAIV9hSIQpyICQRV2QfgPcUHgscAAaikDACACQQV2QfgPcUHgwcAAaikD\
AIUgEEIoiKdB/wFxQQN0QeChwABqKQMAhSAQQjiIp0EDdEHgkcAAaikDAIUgDXxCBX4gBiABQRV2Qf\
gPcUHgscAAaikDACABQQV2QfgPcUHgwcAAaikDAIUgDUIoiKdB/wFxQQN0QeChwABqKQMAhSANQjiI\
p0EDdEHgkcAAaikDAIUgDnxCBX4gAkENdkH4D3FB4KHAAGopAwAgAkH/AXFBA3RB4JHAAGopAwCFIB\
BCIIinQf8BcUEDdEHgscAAaikDAIUgEEIwiKdB/wFxQQN0QeDBwABqKQMAhX2FIg2nIgFBDXZB+A9x\
QeChwABqKQMAIAFB/wFxQQN0QeCRwABqKQMAhSANQiCIp0H/AXFBA3RB4LHAAGopAwCFIA1CMIinQf\
8BcUEDdEHgwcAAaikDAIV9hSIOpyICQRV2QfgPcUHgscAAaikDACACQQV2QfgPcUHgwcAAaikDAIUg\
DkIoiKdB/wFxQQN0QeChwABqKQMAhSAOQjiIp0EDdEHgkcAAaikDAIUgDXxCBX4gCCABQRV2QfgPcU\
HgscAAaikDACABQQV2QfgPcUHgwcAAaikDAIUgDUIoiKdB/wFxQQN0QeChwABqKQMAhSANQjiIp0ED\
dEHgkcAAaikDAIUgEHxCBX4gAkENdkH4D3FB4KHAAGopAwAgAkH/AXFBA3RB4JHAAGopAwCFIA5CII\
inQf8BcUEDdEHgscAAaikDAIUgDkIwiKdB/wFxQQN0QeDBwABqKQMAhX2FIg2nIgFBDXZB+A9xQeCh\
wABqKQMAIAFB/wFxQQN0QeCRwABqKQMAhSANQiCIp0H/AXFBA3RB4LHAAGopAwCFIA1CMIinQf8BcU\
EDdEHgwcAAaikDAIV9hSIQpyICQRV2QfgPcUHgscAAaikDACACQQV2QfgPcUHgwcAAaikDAIUgEEIo\
iKdB/wFxQQN0QeChwABqKQMAhSAQQjiIp0EDdEHgkcAAaikDAIUgDXxCBX4gCSAIIAcgBiAFIAQgAy\
AKIAlC2rTp0qXLlq3aAIV8QgF8IgqFIgN8IhEgA0J/hUIThoV9IhKFIgR8IhMgBEJ/hUIXiIV9IhSF\
IgUgCnwiBiABQRV2QfgPcUHgscAAaikDACABQQV2QfgPcUHgwcAAaikDAIUgDUIoiKdB/wFxQQN0Qe\
ChwABqKQMAhSANQjiIp0EDdEHgkcAAaikDAIUgDnxCBX4gAkENdkH4D3FB4KHAAGopAwAgAkH/AXFB\
A3RB4JHAAGopAwCFIBBCIIinQf8BcUEDdEHgscAAaikDAIUgEEIwiKdB/wFxQQN0QeDBwABqKQMAhX\
2FIg2nIgFBDXZB+A9xQeChwABqKQMAIAFB/wFxQQN0QeCRwABqKQMAhSANQiCIp0H/AXFBA3RB4LHA\
AGopAwCFIA1CMIinQf8BcUEDdEHgwcAAaikDAIV9IAMgBiAFQn+FQhOGhX0iA4UiDqciAkEVdkH4D3\
FB4LHAAGopAwAgAkEFdkH4D3FB4MHAAGopAwCFIA5CKIinQf8BcUEDdEHgocAAaikDAIUgDkI4iKdB\
A3RB4JHAAGopAwCFIA18Qgd+IAFBFXZB+A9xQeCxwABqKQMAIAFBBXZB+A9xQeDBwABqKQMAhSANQi\
iIp0H/AXFBA3RB4KHAAGopAwCFIA1COIinQQN0QeCRwABqKQMAhSAQfEIHfiACQQ12QfgPcUHgocAA\
aikDACACQf8BcUEDdEHgkcAAaikDAIUgDkIgiKdB/wFxQQN0QeCxwABqKQMAhSAOQjCIp0H/AXFBA3\
RB4MHAAGopAwCFfSADIBGFIgmFIg2nIgFBDXZB+A9xQeChwABqKQMAIAFB/wFxQQN0QeCRwABqKQMA\
hSANQiCIp0H/AXFBA3RB4LHAAGopAwCFIA1CMIinQf8BcUEDdEHgwcAAaikDAIV9IAkgEnwiB4UiEK\
ciAkEVdkH4D3FB4LHAAGopAwAgAkEFdkH4D3FB4MHAAGopAwCFIBBCKIinQf8BcUEDdEHgocAAaikD\
AIUgEEI4iKdBA3RB4JHAAGopAwCFIA18Qgd+IAFBFXZB+A9xQeCxwABqKQMAIAFBBXZB+A9xQeDBwA\
BqKQMAhSANQiiIp0H/AXFBA3RB4KHAAGopAwCFIA1COIinQQN0QeCRwABqKQMAhSAOfEIHfiACQQ12\
QfgPcUHgocAAaikDACACQf8BcUEDdEHgkcAAaikDAIUgEEIgiKdB/wFxQQN0QeCxwABqKQMAhSAQQj\
CIp0H/AXFBA3RB4MHAAGopAwCFfSAEIAcgCUJ/hUIXiIV9IgSFIg2nIgFBDXZB+A9xQeChwABqKQMA\
IAFB/wFxQQN0QeCRwABqKQMAhSANQiCIp0H/AXFBA3RB4LHAAGopAwCFIA1CMIinQf8BcUEDdEHgwc\
AAaikDAIV9IAQgE4UiCIUiDqciAkEVdkH4D3FB4LHAAGopAwAgAkEFdkH4D3FB4MHAAGopAwCFIA5C\
KIinQf8BcUEDdEHgocAAaikDAIUgDkI4iKdBA3RB4JHAAGopAwCFIA18Qgd+IAFBFXZB+A9xQeCxwA\
BqKQMAIAFBBXZB+A9xQeDBwABqKQMAhSANQiiIp0H/AXFBA3RB4KHAAGopAwCFIA1COIinQQN0QeCR\
wABqKQMAhSAQfEIHfiACQQ12QfgPcUHgocAAaikDACACQf8BcUEDdEHgkcAAaikDAIUgDkIgiKdB/w\
FxQQN0QeCxwABqKQMAhSAOQjCIp0H/AXFBA3RB4MHAAGopAwCFfSAIIBR8IgqFIg2nIgFBDXZB+A9x\
QeChwABqKQMAIAFB/wFxQQN0QeCRwABqKQMAhSANQiCIp0H/AXFBA3RB4LHAAGopAwCFIA1CMIinQf\
8BcUEDdEHgwcAAaikDAIV9IAUgCkKQ5NCyh9Ou7n6FfEIBfCIFhSIQpyICQRV2QfgPcUHgscAAaikD\
ACACQQV2QfgPcUHgwcAAaikDAIUgEEIoiKdB/wFxQQN0QeChwABqKQMAhSAQQjiIp0EDdEHgkcAAai\
kDAIUgDXxCB34gAUEVdkH4D3FB4LHAAGopAwAgAUEFdkH4D3FB4MHAAGopAwCFIA1CKIinQf8BcUED\
dEHgocAAaikDAIUgDUI4iKdBA3RB4JHAAGopAwCFIA58Qgd+IAJBDXZB+A9xQeChwABqKQMAIAJB/w\
FxQQN0QeCRwABqKQMAhSAQQiCIp0H/AXFBA3RB4LHAAGopAwCFIBBCMIinQf8BcUEDdEHgwcAAaikD\
AIV9IAogByAGIAVC2rTp0qXLlq3aAIV8QgF8Ig0gA4UiDiAJfCIGIA5Cf4VCE4aFfSIHIASFIgkgCH\
wiCCAJQn+FQheIhX0iCiAFhSIDIA18IgSFIg2nIgFBDXZB+A9xQeChwABqKQMAIAFB/wFxQQN0QeCR\
wABqKQMAhSANQiCIp0H/AXFBA3RB4LHAAGopAwCFIA1CMIinQf8BcUEDdEHgwcAAaikDAIV9IA4gBC\
ADQn+FQhOGhX0iBIUiDqciAkEVdkH4D3FB4LHAAGopAwAgAkEFdkH4D3FB4MHAAGopAwCFIA5CKIin\
Qf8BcUEDdEHgocAAaikDAIUgDkI4iKdBA3RB4JHAAGopAwCFIA18Qgl+IAFBFXZB+A9xQeCxwABqKQ\
MAIAFBBXZB+A9xQeDBwABqKQMAhSANQiiIp0H/AXFBA3RB4KHAAGopAwCFIA1COIinQQN0QeCRwABq\
KQMAhSAQfEIJfiACQQ12QfgPcUHgocAAaikDACACQf8BcUEDdEHgkcAAaikDAIUgDkIgiKdB/wFxQQ\
N0QeCxwABqKQMAhSAOQjCIp0H/AXFBA3RB4MHAAGopAwCFfSAEIAaFIgSFIg2nIgFBDXZB+A9xQeCh\
wABqKQMAIAFB/wFxQQN0QeCRwABqKQMAhSANQiCIp0H/AXFBA3RB4LHAAGopAwCFIA1CMIinQf8BcU\
EDdEHgwcAAaikDAIV9IAQgB3wiBYUiEKciAkEVdkH4D3FB4LHAAGopAwAgAkEFdkH4D3FB4MHAAGop\
AwCFIBBCKIinQf8BcUEDdEHgocAAaikDAIUgEEI4iKdBA3RB4JHAAGopAwCFIA18Qgl+IAFBFXZB+A\
9xQeCxwABqKQMAIAFBBXZB+A9xQeDBwABqKQMAhSANQiiIp0H/AXFBA3RB4KHAAGopAwCFIA1COIin\
QQN0QeCRwABqKQMAhSAOfEIJfiACQQ12QfgPcUHgocAAaikDACACQf8BcUEDdEHgkcAAaikDAIUgEE\
IgiKdB/wFxQQN0QeCxwABqKQMAhSAQQjCIp0H/AXFBA3RB4MHAAGopAwCFfSAJIAUgBEJ/hUIXiIV9\
Ig6FIg2nIgFBDXZB+A9xQeChwABqKQMAIAFB/wFxQQN0QeCRwABqKQMAhSANQiCIp0H/AXFBA3RB4L\
HAAGopAwCFIA1CMIinQf8BcUEDdEHgwcAAaikDAIV9IA4gCIUiCYUiDqciAkEVdkH4D3FB4LHAAGop\
AwAgAkEFdkH4D3FB4MHAAGopAwCFIA5CKIinQf8BcUEDdEHgocAAaikDAIUgDkI4iKdBA3RB4JHAAG\
opAwCFIA18Qgl+IAFBFXZB+A9xQeCxwABqKQMAIAFBBXZB+A9xQeDBwABqKQMAhSANQiiIp0H/AXFB\
A3RB4KHAAGopAwCFIA1COIinQQN0QeCRwABqKQMAhSAQfEIJfiACQQ12QfgPcUHgocAAaikDACACQf\
8BcUEDdEHgkcAAaikDAIUgDkIgiKdB/wFxQQN0QeCxwABqKQMAhSAOQjCIp0H/AXFBA3RB4MHAAGop\
AwCFfSAJIAp8IhCFIg2nIgFBDXZB+A9xQeChwABqKQMAIAFB/wFxQQN0QeCRwABqKQMAhSANQiCIp0\
H/AXFBA3RB4LHAAGopAwCFIA1CMIinQf8BcUEDdEHgwcAAaikDAIV9IAMgEEKQ5NCyh9Ou7n6FfEIB\
fIUiECAPfTcDCCAAIAwgAUEVdkH4D3FB4LHAAGopAwAgAUEFdkH4D3FB4MHAAGopAwCFIA1CKIinQf\
8BcUEDdEHgocAAaikDAIUgDUI4iKdBA3RB4JHAAGopAwCFIA58Qgl+fCAQpyIBQQ12QfgPcUHgocAA\
aikDACABQf8BcUEDdEHgkcAAaikDAIUgEEIgiKdB/wFxQQN0QeCxwABqKQMAhSAQQjCIp0H/AXFBA3\
RB4MHAAGopAwCFfTcDECAAIAsgAUEVdkH4D3FB4LHAAGopAwAgAUEFdkH4D3FB4MHAAGopAwCFIBBC\
KIinQf8BcUEDdEHgocAAaikDAIUgEEI4iKdBA3RB4JHAAGopAwCFIA18Qgl+hTcDAAuGHgI6fwF+Iw\
BBwABrIgMkAAJAIAJFDQAgAEEQaigCACIEIABBOGooAgAiBWogAEEgaigCACIGaiIHIABBPGooAgAi\
CGogByAALQBoc0EQdCAHQRB2ciIHQfLmu+MDaiIJIAZzQRR3IgpqIgsgB3NBGHciDCAJaiINIApzQR\
l3IQ4gCyAAQdgAaigCACIPaiAAQRRqKAIAIhAgAEHAAGooAgAiEWogAEEkaigCACISaiIHIABBxABq\
KAIAIhNqIAcgAC0AaUEIcnNBEHQgB0EQdnIiB0G66r+qemoiCSASc0EUdyIKaiILIAdzQRh3IhQgCW\
oiFSAKc0EZdyIWaiIXIABB3ABqKAIAIhhqIRkgCyAAQeAAaigCACIaaiEbIAAoAggiHCAAKAIoIh1q\
IABBGGooAgAiHmoiHyAAQSxqKAIAIiBqISEgAEEMaigCACIiIABBMGooAgAiI2ogAEEcaigCACIkai\
IlIABBNGooAgAiJmohJyAAQeQAaigCACEHIABB1ABqKAIAIQkgAEHQAGooAgAhCiAAQcwAaigCACEL\
IABByABqKAIAISggAC0AcCEpIAApAwAhPQNAIAMgGSAXICcgJSA9QiCIp3NBEHciKkGF3Z7be2oiKy\
Akc0EUdyIsaiItICpzQRh3IipzQRB3Ii4gISAfID2nc0EQdyIvQefMp9AGaiIwIB5zQRR3IjFqIjIg\
L3NBGHciLyAwaiIwaiIzIBZzQRR3IjRqIjUgE2ogLSAKaiAOaiItIAlqIC0gL3NBEHciLSAVaiIvIA\
5zQRR3IjZqIjcgLXNBGHciLSAvaiIvIDZzQRl3IjZqIjggHWogOCAbIDAgMXNBGXciMGoiMSAHaiAx\
IAxzQRB3IjEgKiAraiIqaiIrIDBzQRR3IjBqIjkgMXNBGHciMXNBEHciOCAyIChqICogLHNBGXciKm\
oiLCALaiAsIBRzQRB3IiwgDWoiMiAqc0EUdyIqaiI6ICxzQRh3IiwgMmoiMmoiOyA2c0EUdyI2aiI8\
IAtqIDkgBWogNSAuc0EYdyIuIDNqIjMgNHNBGXciNGoiNSAYaiA1ICxzQRB3IiwgL2oiLyA0c0EUdy\
I0aiI1ICxzQRh3IiwgL2oiLyA0c0EZdyI0aiI5IBpqIDkgNyAmaiAyICpzQRl3IipqIjIgCmogMiAu\
c0EQdyIuIDEgK2oiK2oiMSAqc0EUdyIqaiIyIC5zQRh3Ii5zQRB3IjcgOiAjaiArIDBzQRl3IitqIj\
AgEWogMCAtc0EQdyItIDNqIjAgK3NBFHciK2oiMyAtc0EYdyItIDBqIjBqIjkgNHNBFHciNGoiOiAY\
aiAyIA9qIDwgOHNBGHciMiA7aiI4IDZzQRl3IjZqIjsgCGogOyAtc0EQdyItIC9qIi8gNnNBFHciNm\
oiOyAtc0EYdyItIC9qIi8gNnNBGXciNmoiPCAjaiA8IDUgB2ogMCArc0EZdyIraiIwIChqIDAgMnNB\
EHciMCAuIDFqIi5qIjEgK3NBFHciK2oiMiAwc0EYdyIwc0EQdyI1IDMgIGogLiAqc0EZdyIqaiIuIA\
lqIC4gLHNBEHciLCA4aiIuICpzQRR3IipqIjMgLHNBGHciLCAuaiIuaiI4IDZzQRR3IjZqIjwgCWog\
MiATaiA6IDdzQRh3IjIgOWoiNyA0c0EZdyI0aiI5IBpqIDkgLHNBEHciLCAvaiIvIDRzQRR3IjRqIj\
kgLHNBGHciLCAvaiIvIDRzQRl3IjRqIjogB2ogOiA7IApqIC4gKnNBGXciKmoiLiAPaiAuIDJzQRB3\
Ii4gMCAxaiIwaiIxICpzQRR3IipqIjIgLnNBGHciLnNBEHciOiAzICZqIDAgK3NBGXciK2oiMCAFai\
AwIC1zQRB3Ii0gN2oiMCArc0EUdyIraiIzIC1zQRh3Ii0gMGoiMGoiNyA0c0EUdyI0aiI7IBpqIDIg\
C2ogPCA1c0EYdyIyIDhqIjUgNnNBGXciNmoiOCAdaiA4IC1zQRB3Ii0gL2oiLyA2c0EUdyI2aiI4IC\
1zQRh3Ii0gL2oiLyA2c0EZdyI2aiI8ICZqIDwgOSAoaiAwICtzQRl3IitqIjAgIGogMCAyc0EQdyIw\
IC4gMWoiLmoiMSArc0EUdyIraiIyIDBzQRh3IjBzQRB3IjkgMyARaiAuICpzQRl3IipqIi4gCGogLi\
Asc0EQdyIsIDVqIi4gKnNBFHciKmoiMyAsc0EYdyIsIC5qIi5qIjUgNnNBFHciNmoiPCAIaiAyIBhq\
IDsgOnNBGHciMiA3aiI3IDRzQRl3IjRqIjogB2ogOiAsc0EQdyIsIC9qIi8gNHNBFHciNGoiOiAsc0\
EYdyIsIC9qIi8gNHNBGXciNGoiOyAoaiA7IDggD2ogLiAqc0EZdyIqaiIuIAtqIC4gMnNBEHciLiAw\
IDFqIjBqIjEgKnNBFHciKmoiMiAuc0EYdyIuc0EQdyI4IDMgCmogMCArc0EZdyIraiIwIBNqIDAgLX\
NBEHciLSA3aiIwICtzQRR3IitqIjMgLXNBGHciLSAwaiIwaiI3IDRzQRR3IjRqIjsgB2ogMiAJaiA8\
IDlzQRh3IjIgNWoiNSA2c0EZdyI2aiI5ICNqIDkgLXNBEHciLSAvaiIvIDZzQRR3IjZqIjkgLXNBGH\
ciLSAvaiIvIDZzQRl3IjZqIjwgCmogPCA6ICBqIDAgK3NBGXciK2oiMCARaiAwIDJzQRB3IjAgLiAx\
aiIuaiIxICtzQRR3IitqIjIgMHNBGHciMHNBEHciOiAzIAVqIC4gKnNBGXciKmoiLiAdaiAuICxzQR\
B3IiwgNWoiLiAqc0EUdyIqaiIzICxzQRh3IiwgLmoiLmoiNSA2c0EUdyI2aiI8IB1qIDIgGmogOyA4\
c0EYdyIyIDdqIjcgNHNBGXciNGoiOCAoaiA4ICxzQRB3IiwgL2oiLyA0c0EUdyI0aiI4ICxzQRh3Ii\
wgL2oiLyA0c0EZdyI0aiI7ICBqIDsgOSALaiAuICpzQRl3IipqIi4gCWogLiAyc0EQdyIuIDAgMWoi\
MGoiMSAqc0EUdyIqaiIyIC5zQRh3Ii5zQRB3IjkgMyAPaiAwICtzQRl3IitqIjAgGGogMCAtc0EQdy\
ItIDdqIjAgK3NBFHciK2oiMyAtc0EYdyItIDBqIjBqIjcgNHNBFHciNGoiOyAoaiAyIAhqIDwgOnNB\
GHciMiA1aiI1IDZzQRl3IjZqIjogJmogOiAtc0EQdyItIC9qIi8gNnNBFHciNmoiOiAtc0EYdyItIC\
9qIi8gNnNBGXciNmoiPCAPaiA8IDggEWogMCArc0EZdyIraiIwIAVqIDAgMnNBEHciMCAuIDFqIi5q\
IjEgK3NBFHciK2oiMiAwc0EYdyIwc0EQdyI4IDMgE2ogLiAqc0EZdyIqaiIuICNqIC4gLHNBEHciLC\
A1aiIuICpzQRR3IipqIjMgLHNBGHciLCAuaiIuaiI1IDZzQRR3IjZqIjwgI2ogMiAHaiA7IDlzQRh3\
IjIgN2oiNyA0c0EZdyI0aiI5ICBqIDkgLHNBEHciLCAvaiIvIDRzQRR3IjRqIjkgLHNBGHciLCAvai\
IvIDRzQRl3IjRqIjsgEWogOyA6IAlqIC4gKnNBGXciKmoiLiAIaiAuIDJzQRB3Ii4gMCAxaiIwaiIx\
ICpzQRR3IipqIjIgLnNBGHciLnNBEHciOiAzIAtqIDAgK3NBGXciK2oiMCAaaiAwIC1zQRB3Ii0gN2\
oiMCArc0EUdyIraiIzIC1zQRh3Ii0gMGoiMGoiNyA0c0EUdyI0aiI7ICBqIDIgHWogPCA4c0EYdyIy\
IDVqIjUgNnNBGXciNmoiOCAKaiA4IC1zQRB3Ii0gL2oiLyA2c0EUdyI2aiI4IC1zQRh3Ii0gL2oiLy\
A2c0EZdyI2aiI8IAtqIDwgOSAFaiAwICtzQRl3IitqIjAgE2ogMCAyc0EQdyIwIC4gMWoiLmoiMSAr\
c0EUdyIraiIyIDBzQRh3IjBzQRB3IjkgMyAYaiAuICpzQRl3IipqIi4gJmogLiAsc0EQdyIsIDVqIi\
4gKnNBFHciKmoiMyAsc0EYdyIsIC5qIi5qIjUgNnNBFHciNmoiPCAmaiAyIChqIDsgOnNBGHciMiA3\
aiI3IDRzQRl3IjRqIjogEWogOiAsc0EQdyIsIC9qIi8gNHNBFHciNGoiOiAsc0EYdyI7IC9qIiwgNH\
NBGXciL2oiNCAFaiA0IDggCGogLiAqc0EZdyIqaiIuIB1qIC4gMnNBEHciLiAwIDFqIjBqIjEgKnNB\
FHciMmoiOCAuc0EYdyIuc0EQdyIqIDMgCWogMCArc0EZdyIraiIwIAdqIDAgLXNBEHciLSA3aiIwIC\
tzQRR3IjNqIjQgLXNBGHciKyAwaiIwaiItIC9zQRR3Ii9qIjcgKnNBGHciKiAkczYCNCADIDggI2og\
PCA5c0EYdyI4IDVqIjUgNnNBGXciNmoiOSAPaiA5ICtzQRB3IisgLGoiLCA2c0EUdyI2aiI5ICtzQR\
h3IisgHnM2AjAgAyArICxqIiwgEHM2AiwgAyAqIC1qIi0gHHM2AiAgAyAsIDogE2ogMCAzc0EZdyIw\
aiIzIBhqIDMgOHNBEHciMyAuIDFqIi5qIjEgMHNBFHciMGoiOHM2AgwgAyAtIDQgGmogLiAyc0EZdy\
IuaiIyIApqIDIgO3NBEHciMiA1aiI0IC5zQRR3IjVqIjpzNgIAIAMgOCAzc0EYdyIuIAZzNgI4IAMg\
LCA2c0EZdyAuczYCGCADIDogMnNBGHciLCASczYCPCADIC4gMWoiLiAiczYCJCADIC0gL3NBGXcgLH\
M2AhwgAyAuIDlzNgIEIAMgLCA0aiIsIARzNgIoIAMgLCA3czYCCCADIC4gMHNBGXcgK3M2AhAgAyAs\
IDVzQRl3ICpzNgIUAkACQCApQf8BcSIqQcEATw0AIAEgAyAqaiACQcAAICprIiogAiAqSRsiKhCUAS\
ErIAAgKSAqaiIpOgBwIAIgKmshAiApQf8BcUHAAEcNAUEAISkgAEEAOgBwIAAgPUIBfCI9NwMADAEL\
ICpBwABBkIbAABCMAQALICsgKmohASACDQALCyADQcAAaiQAC5UbASB/IAAgACgCACABKAAAIgVqIA\
AoAhAiBmoiByABKAAEIghqIAcgA6dzQRB3IglB58yn0AZqIgogBnNBFHciC2oiDCABKAAgIgZqIAAo\
AgQgASgACCIHaiAAKAIUIg1qIg4gASgADCIPaiAOIANCIIinc0EQdyIOQYXdntt7aiIQIA1zQRR3Ig\
1qIhEgDnNBGHciEiAQaiITIA1zQRl3IhRqIhUgASgAJCINaiAVIAAoAgwgASgAGCIOaiAAKAIcIhZq\
IhcgASgAHCIQaiAXIARB/wFxc0EQdCAXQRB2ciIXQbrqv6p6aiIYIBZzQRR3IhZqIhkgF3NBGHciGn\
NBEHciGyAAKAIIIAEoABAiF2ogACgCGCIcaiIVIAEoABQiBGogFSACQf8BcXNBEHQgFUEQdnIiFUHy\
5rvjA2oiAiAcc0EUdyIcaiIdIBVzQRh3Ih4gAmoiH2oiICAUc0EUdyIUaiIhIAdqIBkgASgAOCIVai\
AMIAlzQRh3IgwgCmoiGSALc0EZdyIJaiIKIAEoADwiAmogCiAec0EQdyIKIBNqIgsgCXNBFHciCWoi\
EyAKc0EYdyIeIAtqIiIgCXNBGXciI2oiCyAOaiALIBEgASgAKCIJaiAfIBxzQRl3IhFqIhwgASgALC\
IKaiAcIAxzQRB3IgwgGiAYaiIYaiIaIBFzQRR3IhFqIhwgDHNBGHciDHNBEHciHyAdIAEoADAiC2og\
GCAWc0EZdyIWaiIYIAEoADQiAWogGCASc0EQdyISIBlqIhggFnNBFHciFmoiGSASc0EYdyISIBhqIh\
hqIh0gI3NBFHciI2oiJCAIaiAcIA9qICEgG3NBGHciGyAgaiIcIBRzQRl3IhRqIiAgCWogICASc0EQ\
dyISICJqIiAgFHNBFHciFGoiISASc0EYdyISICBqIiAgFHNBGXciFGoiIiAKaiAiIBMgF2ogGCAWc0\
EZdyITaiIWIAFqIBYgG3NBEHciFiAMIBpqIgxqIhggE3NBFHciE2oiGiAWc0EYdyIWc0EQdyIbIBkg\
EGogDCARc0EZdyIMaiIRIAVqIBEgHnNBEHciESAcaiIZIAxzQRR3IgxqIhwgEXNBGHciESAZaiIZai\
IeIBRzQRR3IhRqIiIgD2ogGiACaiAkIB9zQRh3IhogHWoiHSAjc0EZdyIfaiIjIAZqICMgEXNBEHci\
ESAgaiIgIB9zQRR3Ih9qIiMgEXNBGHciESAgaiIgIB9zQRl3Ih9qIiQgF2ogJCAhIAtqIBkgDHNBGX\
ciDGoiGSAEaiAZIBpzQRB3IhkgFiAYaiIWaiIYIAxzQRR3IgxqIhogGXNBGHciGXNBEHciISAcIA1q\
IBYgE3NBGXciE2oiFiAVaiAWIBJzQRB3IhIgHWoiFiATc0EUdyITaiIcIBJzQRh3IhIgFmoiFmoiHS\
Afc0EUdyIfaiIkIA5qIBogCWogIiAbc0EYdyIaIB5qIhsgFHNBGXciFGoiHiALaiAeIBJzQRB3IhIg\
IGoiHiAUc0EUdyIUaiIgIBJzQRh3IhIgHmoiHiAUc0EZdyIUaiIiIARqICIgIyAQaiAWIBNzQRl3Ih\
NqIhYgFWogFiAac0EQdyIWIBkgGGoiGGoiGSATc0EUdyITaiIaIBZzQRh3IhZzQRB3IiIgHCABaiAY\
IAxzQRl3IgxqIhggB2ogGCARc0EQdyIRIBtqIhggDHNBFHciDGoiGyARc0EYdyIRIBhqIhhqIhwgFH\
NBFHciFGoiIyAJaiAaIAZqICQgIXNBGHciGiAdaiIdIB9zQRl3Ih9qIiEgCGogISARc0EQdyIRIB5q\
Ih4gH3NBFHciH2oiISARc0EYdyIRIB5qIh4gH3NBGXciH2oiJCAQaiAkICAgDWogGCAMc0EZdyIMai\
IYIAVqIBggGnNBEHciGCAWIBlqIhZqIhkgDHNBFHciDGoiGiAYc0EYdyIYc0EQdyIgIBsgCmogFiAT\
c0EZdyITaiIWIAJqIBYgEnNBEHciEiAdaiIWIBNzQRR3IhNqIhsgEnNBGHciEiAWaiIWaiIdIB9zQR\
R3Ih9qIiQgF2ogGiALaiAjICJzQRh3IhogHGoiHCAUc0EZdyIUaiIiIA1qICIgEnNBEHciEiAeaiIe\
IBRzQRR3IhRqIiIgEnNBGHciEiAeaiIeIBRzQRl3IhRqIiMgBWogIyAhIAFqIBYgE3NBGXciE2oiFi\
ACaiAWIBpzQRB3IhYgGCAZaiIYaiIZIBNzQRR3IhNqIhogFnNBGHciFnNBEHciISAbIBVqIBggDHNB\
GXciDGoiGCAPaiAYIBFzQRB3IhEgHGoiGCAMc0EUdyIMaiIbIBFzQRh3IhEgGGoiGGoiHCAUc0EUdy\
IUaiIjIAtqIBogCGogJCAgc0EYdyIaIB1qIh0gH3NBGXciH2oiICAOaiAgIBFzQRB3IhEgHmoiHiAf\
c0EUdyIfaiIgIBFzQRh3IhEgHmoiHiAfc0EZdyIfaiIkIAFqICQgIiAKaiAYIAxzQRl3IgxqIhggB2\
ogGCAac0EQdyIYIBYgGWoiFmoiGSAMc0EUdyIMaiIaIBhzQRh3IhhzQRB3IiIgGyAEaiAWIBNzQRl3\
IhNqIhYgBmogFiASc0EQdyISIB1qIhYgE3NBFHciE2oiGyASc0EYdyISIBZqIhZqIh0gH3NBFHciH2\
oiJCAQaiAaIA1qICMgIXNBGHciGiAcaiIcIBRzQRl3IhRqIiEgCmogISASc0EQdyISIB5qIh4gFHNB\
FHciFGoiISASc0EYdyISIB5qIh4gFHNBGXciFGoiIyAHaiAjICAgFWogFiATc0EZdyITaiIWIAZqIB\
YgGnNBEHciFiAYIBlqIhhqIhkgE3NBFHciE2oiGiAWc0EYdyIWc0EQdyIgIBsgAmogGCAMc0EZdyIM\
aiIYIAlqIBggEXNBEHciESAcaiIYIAxzQRR3IgxqIhsgEXNBGHciESAYaiIYaiIcIBRzQRR3IhRqIi\
MgDWogGiAOaiAkICJzQRh3IhogHWoiHSAfc0EZdyIfaiIiIBdqICIgEXNBEHciESAeaiIeIB9zQRR3\
Ih9qIiIgEXNBGHciESAeaiIeIB9zQRl3Ih9qIiQgFWogJCAhIARqIBggDHNBGXciDGoiGCAPaiAYIB\
pzQRB3IhggFiAZaiIWaiIZIAxzQRR3IgxqIhogGHNBGHciGHNBEHciISAbIAVqIBYgE3NBGXciE2oi\
FiAIaiAWIBJzQRB3IhIgHWoiFiATc0EUdyITaiIbIBJzQRh3IhIgFmoiFmoiHSAfc0EUdyIfaiIkIA\
FqIBogCmogIyAgc0EYdyIaIBxqIhwgFHNBGXciFGoiICAEaiAgIBJzQRB3IhIgHmoiHiAUc0EUdyIU\
aiIgIBJzQRh3IhIgHmoiHiAUc0EZdyIUaiIjIA9qICMgIiACaiAWIBNzQRl3IhNqIhYgCGogFiAac0\
EQdyIWIBggGWoiGGoiGSATc0EUdyITaiIaIBZzQRh3IhZzQRB3IiIgGyAGaiAYIAxzQRl3IgxqIhgg\
C2ogGCARc0EQdyIRIBxqIhggDHNBFHciDGoiGyARc0EYdyIRIBhqIhhqIhwgFHNBFHciFGoiIyAKai\
AaIBdqICQgIXNBGHciCiAdaiIaIB9zQRl3Ih1qIh8gEGogHyARc0EQdyIRIB5qIh4gHXNBFHciHWoi\
HyARc0EYdyIRIB5qIh4gHXNBGXciHWoiISACaiAhICAgBWogGCAMc0EZdyICaiIMIAlqIAwgCnNBEH\
ciCiAWIBlqIgxqIhYgAnNBFHciAmoiGCAKc0EYdyIKc0EQdyIZIBsgB2ogDCATc0EZdyIMaiITIA5q\
IBMgEnNBEHciEiAaaiITIAxzQRR3IgxqIhogEnNBGHciEiATaiITaiIbIB1zQRR3Ih1qIiAgFWogGC\
AEaiAjICJzQRh3IgQgHGoiFSAUc0EZdyIUaiIYIAVqIBggEnNBEHciBSAeaiISIBRzQRR3IhRqIhgg\
BXNBGHciBSASaiISIBRzQRl3IhRqIhwgCWogHCAfIAZqIBMgDHNBGXciBmoiCSAOaiAJIARzQRB3Ig\
4gCiAWaiIEaiIJIAZzQRR3IgZqIgogDnNBGHciDnNBEHciDCAaIAhqIAQgAnNBGXciCGoiBCANaiAE\
IBFzQRB3Ig0gFWoiBCAIc0EUdyIIaiIVIA1zQRh3Ig0gBGoiBGoiAiAUc0EUdyIRaiITIAxzQRh3Ig\
wgAmoiAiAVIA9qIA4gCWoiDyAGc0EZdyIGaiIOIBdqIA4gBXNBEHciBSAgIBlzQRh3Ig4gG2oiF2oi\
FSAGc0EUdyIGaiIJczYCCCAAIAEgCiAQaiAXIB1zQRl3IhBqIhdqIBcgDXNBEHciASASaiINIBBzQR\
R3IhBqIhcgAXNBGHciASANaiINIAsgGCAHaiAEIAhzQRl3IghqIgdqIAcgDnNBEHciByAPaiIPIAhz\
QRR3IghqIg5zNgIEIAAgDiAHc0EYdyIHIA9qIg8gF3M2AgwgACAJIAVzQRh3IgUgFWoiDiATczYCAC\
AAIAIgEXNBGXcgBXM2AhQgACANIBBzQRl3IAdzNgIQIAAgDiAGc0EZdyAMczYCHCAAIA8gCHNBGXcg\
AXM2AhgL2CMCCH8BfgJAAkACQAJAAkAgAEH1AUkNAEEAIQEgAEHN/3tPDQQgAEELaiIAQXhxIQJBAC\
gC8NJAIgNFDQNBACEEAkAgAkGAAkkNAEEfIQQgAkH///8HSw0AIAJBBiAAQQh2ZyIAa3ZBAXEgAEEB\
dGtBPmohBAtBACACayEBAkAgBEECdEH81MAAaigCACIARQ0AQQAhBSACQQBBGSAEQQF2a0EfcSAEQR\
9GG3QhBkEAIQcDQAJAIAAoAgRBeHEiCCACSQ0AIAggAmsiCCABTw0AIAghASAAIQcgCA0AQQAhASAA\
IQcMBAsgAEEUaigCACIIIAUgCCAAIAZBHXZBBHFqQRBqKAIAIgBHGyAFIAgbIQUgBkEBdCEGIAANAA\
sCQCAFRQ0AIAUhAAwDCyAHDQMLQQAhByADQQIgBHQiAEEAIABrcnEiAEUNAyAAQQAgAGtxaEECdEH8\
1MAAaigCACIADQEMAwsCQAJAAkACQAJAQQAoAuzSQCIGQRAgAEELakF4cSAAQQtJGyICQQN2IgF2Ig\
BBA3ENACACQQAoAvzVQE0NByAADQFBACgC8NJAIgBFDQcgAEEAIABrcWhBAnRB/NTAAGooAgAiBygC\
BEF4cSEBAkAgBygCECIADQAgB0EUaigCACEACyABIAJrIQUCQCAARQ0AA0AgACgCBEF4cSACayIIIA\
VJIQYCQCAAKAIQIgENACAAQRRqKAIAIQELIAggBSAGGyEFIAAgByAGGyEHIAEhACABDQALCyAHKAIY\
IQQgBygCDCIBIAdHDQIgB0EUQRAgB0EUaiIBKAIAIgYbaigCACIADQNBACEBDAQLAkACQCAAQX9zQQ\
FxIAFqIgJBA3QiBUH80sAAaigCACIAQQhqIgcoAgAiASAFQfTSwABqIgVGDQAgASAFNgIMIAUgATYC\
CAwBC0EAIAZBfiACd3E2AuzSQAsgACACQQN0IgJBA3I2AgQgACACaiIAIAAoAgRBAXI2AgQgBw8LAk\
ACQEECIAFBH3EiAXQiBUEAIAVrciAAIAF0cSIAQQAgAGtxaCIBQQN0IgdB/NLAAGooAgAiAEEIaiII\
KAIAIgUgB0H00sAAaiIHRg0AIAUgBzYCDCAHIAU2AggMAQtBACAGQX4gAXdxNgLs0kALIAAgAkEDcj\
YCBCAAIAJqIgYgAUEDdCIBIAJrIgJBAXI2AgQgACABaiACNgIAAkBBACgC/NVAIgVFDQAgBUF4cUH0\
0sAAaiEBQQAoAoTWQCEAAkACQEEAKALs0kAiB0EBIAVBA3Z0IgVxRQ0AIAEoAgghBQwBC0EAIAcgBX\
I2AuzSQCABIQULIAEgADYCCCAFIAA2AgwgACABNgIMIAAgBTYCCAtBACAGNgKE1kBBACACNgL81UAg\
CA8LIAcoAggiACABNgIMIAEgADYCCAwBCyABIAdBEGogBhshBgNAIAYhCAJAIAAiAUEUaiIGKAIAIg\
ANACABQRBqIQYgASgCECEACyAADQALIAhBADYCAAsCQCAERQ0AAkACQCAHKAIcQQJ0QfzUwABqIgAo\
AgAgB0YNACAEQRBBFCAEKAIQIAdGG2ogATYCACABRQ0CDAELIAAgATYCACABDQBBAEEAKALw0kBBfi\
AHKAIcd3E2AvDSQAwBCyABIAQ2AhgCQCAHKAIQIgBFDQAgASAANgIQIAAgATYCGAsgB0EUaigCACIA\
RQ0AIAFBFGogADYCACAAIAE2AhgLAkACQCAFQRBJDQAgByACQQNyNgIEIAcgAmoiAiAFQQFyNgIEIA\
IgBWogBTYCAAJAQQAoAvzVQCIGRQ0AIAZBeHFB9NLAAGohAUEAKAKE1kAhAAJAAkBBACgC7NJAIghB\
ASAGQQN2dCIGcUUNACABKAIIIQYMAQtBACAIIAZyNgLs0kAgASEGCyABIAA2AgggBiAANgIMIAAgAT\
YCDCAAIAY2AggLQQAgAjYChNZAQQAgBTYC/NVADAELIAcgBSACaiIAQQNyNgIEIAcgAGoiACAAKAIE\
QQFyNgIECyAHQQhqDwsDQCAAKAIEQXhxIgUgAk8gBSACayIIIAFJcSEGAkAgACgCECIFDQAgAEEUai\
gCACEFCyAAIAcgBhshByAIIAEgBhshASAFIQAgBQ0ACyAHRQ0BCwJAQQAoAvzVQCIAIAJJDQAgASAA\
IAJrTw0BCyAHKAIYIQQCQAJAAkAgBygCDCIFIAdHDQAgB0EUQRAgB0EUaiIFKAIAIgYbaigCACIADQ\
FBACEFDAILIAcoAggiACAFNgIMIAUgADYCCAwBCyAFIAdBEGogBhshBgNAIAYhCAJAIAAiBUEUaiIG\
KAIAIgANACAFQRBqIQYgBSgCECEACyAADQALIAhBADYCAAsCQCAERQ0AAkACQCAHKAIcQQJ0QfzUwA\
BqIgAoAgAgB0YNACAEQRBBFCAEKAIQIAdGG2ogBTYCACAFRQ0CDAELIAAgBTYCACAFDQBBAEEAKALw\
0kBBfiAHKAIcd3E2AvDSQAwBCyAFIAQ2AhgCQCAHKAIQIgBFDQAgBSAANgIQIAAgBTYCGAsgB0EUai\
gCACIARQ0AIAVBFGogADYCACAAIAU2AhgLAkACQCABQRBJDQAgByACQQNyNgIEIAcgAmoiACABQQFy\
NgIEIAAgAWogATYCAAJAIAFBgAJJDQAgACABEEYMAgsgAUF4cUH00sAAaiECAkACQEEAKALs0kAiBU\
EBIAFBA3Z0IgFxRQ0AIAIoAgghAQwBC0EAIAUgAXI2AuzSQCACIQELIAIgADYCCCABIAA2AgwgACAC\
NgIMIAAgATYCCAwBCyAHIAEgAmoiAEEDcjYCBCAHIABqIgAgACgCBEEBcjYCBAsgB0EIag8LAkACQA\
JAAkACQAJAAkACQAJAAkACQAJAQQAoAvzVQCIAIAJPDQBBACgCgNZAIgAgAksNBEEAIQEgAkGvgARq\
IgVBEHZAACIAQX9GIgcNDCAAQRB0IgZFDQxBAEEAKAKM1kBBACAFQYCAfHEgBxsiCGoiADYCjNZAQQ\
BBACgCkNZAIgEgACABIABLGzYCkNZAQQAoAojWQCIBRQ0BQZTWwAAhAANAIAAoAgAiBSAAKAIEIgdq\
IAZGDQMgACgCCCIADQAMBAsLQQAoAoTWQCEBAkACQCAAIAJrIgVBD0sNAEEAQQA2AoTWQEEAQQA2Av\
zVQCABIABBA3I2AgQgASAAaiIAIAAoAgRBAXI2AgQMAQtBACAFNgL81UBBACABIAJqIgY2AoTWQCAG\
IAVBAXI2AgQgASAAaiAFNgIAIAEgAkEDcjYCBAsgAUEIag8LQQAoAqjWQCIARQ0DIAAgBksNAwwICy\
AAKAIMDQAgBSABSw0AIAEgBkkNAwtBAEEAKAKo1kAiACAGIAAgBkkbNgKo1kAgBiAIaiEFQZTWwAAh\
AAJAAkACQANAIAAoAgAgBUYNASAAKAIIIgANAAwCCwsgACgCDEUNAQtBlNbAACEAAkADQAJAIAAoAg\
AiBSABSw0AIAUgACgCBGoiBSABSw0CCyAAKAIIIQAMAAsLQQAgBjYCiNZAQQAgCEFYaiIANgKA1kAg\
BiAAQQFyNgIEIAYgAGpBKDYCBEEAQYCAgAE2AqTWQCABIAVBYGpBeHFBeGoiACAAIAFBEGpJGyIHQR\
s2AgRBACkClNZAIQkgB0EQakEAKQKc1kA3AgAgByAJNwIIQQAgCDYCmNZAQQAgBjYClNZAQQAgB0EI\
ajYCnNZAQQBBADYCoNZAIAdBHGohAANAIABBBzYCACAAQQRqIgAgBUkNAAsgByABRg0IIAcgBygCBE\
F+cTYCBCABIAcgAWsiAEEBcjYCBCAHIAA2AgACQCAAQYACSQ0AIAEgABBGDAkLIABBeHFB9NLAAGoh\
BQJAAkBBACgC7NJAIgZBASAAQQN2dCIAcUUNACAFKAIIIQAMAQtBACAGIAByNgLs0kAgBSEACyAFIA\
E2AgggACABNgIMIAEgBTYCDCABIAA2AggMCAsgACAGNgIAIAAgACgCBCAIajYCBCAGIAJBA3I2AgQg\
BSAGIAJqIgBrIQICQCAFQQAoAojWQEYNACAFQQAoAoTWQEYNBCAFKAIEIgFBA3FBAUcNBQJAAkAgAU\
F4cSIHQYACSQ0AIAUQRwwBCwJAIAVBDGooAgAiCCAFQQhqKAIAIgRGDQAgBCAINgIMIAggBDYCCAwB\
C0EAQQAoAuzSQEF+IAFBA3Z3cTYC7NJACyAHIAJqIQIgBSAHaiIFKAIEIQEMBQtBACAANgKI1kBBAE\
EAKAKA1kAgAmoiAjYCgNZAIAAgAkEBcjYCBAwFC0EAIAAgAmsiATYCgNZAQQBBACgCiNZAIgAgAmoi\
BTYCiNZAIAUgAUEBcjYCBCAAIAJBA3I2AgQgAEEIaiEBDAcLQQAgBjYCqNZADAQLIAAgByAIajYCBE\
EAQQAoAojWQCIAQQ9qQXhxIgFBeGo2AojWQEEAIAAgAWtBACgCgNZAIAhqIgVqQQhqIgY2AoDWQCAB\
QXxqIAZBAXI2AgAgACAFakEoNgIEQQBBgICAATYCpNZADAQLQQAgADYChNZAQQBBACgC/NVAIAJqIg\
I2AvzVQCAAIAJBAXI2AgQgACACaiACNgIADAELIAUgAUF+cTYCBCAAIAJBAXI2AgQgACACaiACNgIA\
AkAgAkGAAkkNACAAIAIQRgwBCyACQXhxQfTSwABqIQECQAJAQQAoAuzSQCIFQQEgAkEDdnQiAnFFDQ\
AgASgCCCECDAELQQAgBSACcjYC7NJAIAEhAgsgASAANgIIIAIgADYCDCAAIAE2AgwgACACNgIICyAG\
QQhqDwtBAEH/HzYCrNZAQQAgCDYCmNZAQQAgBjYClNZAQQBB9NLAADYCgNNAQQBB/NLAADYCiNNAQQ\
BB9NLAADYC/NJAQQBBhNPAADYCkNNAQQBB/NLAADYChNNAQQBBjNPAADYCmNNAQQBBhNPAADYCjNNA\
QQBBlNPAADYCoNNAQQBBjNPAADYClNNAQQBBnNPAADYCqNNAQQBBlNPAADYCnNNAQQBBpNPAADYCsN\
NAQQBBnNPAADYCpNNAQQBBrNPAADYCuNNAQQBBpNPAADYCrNNAQQBBADYCoNZAQQBBtNPAADYCwNNA\
QQBBrNPAADYCtNNAQQBBtNPAADYCvNNAQQBBvNPAADYCyNNAQQBBvNPAADYCxNNAQQBBxNPAADYC0N\
NAQQBBxNPAADYCzNNAQQBBzNPAADYC2NNAQQBBzNPAADYC1NNAQQBB1NPAADYC4NNAQQBB1NPAADYC\
3NNAQQBB3NPAADYC6NNAQQBB3NPAADYC5NNAQQBB5NPAADYC8NNAQQBB5NPAADYC7NNAQQBB7NPAAD\
YC+NNAQQBB7NPAADYC9NNAQQBB9NPAADYCgNRAQQBB/NPAADYCiNRAQQBB9NPAADYC/NNAQQBBhNTA\
ADYCkNRAQQBB/NPAADYChNRAQQBBjNTAADYCmNRAQQBBhNTAADYCjNRAQQBBlNTAADYCoNRAQQBBjN\
TAADYClNRAQQBBnNTAADYCqNRAQQBBlNTAADYCnNRAQQBBpNTAADYCsNRAQQBBnNTAADYCpNRAQQBB\
rNTAADYCuNRAQQBBpNTAADYCrNRAQQBBtNTAADYCwNRAQQBBrNTAADYCtNRAQQBBvNTAADYCyNRAQQ\
BBtNTAADYCvNRAQQBBxNTAADYC0NRAQQBBvNTAADYCxNRAQQBBzNTAADYC2NRAQQBBxNTAADYCzNRA\
QQBB1NTAADYC4NRAQQBBzNTAADYC1NRAQQBB3NTAADYC6NRAQQBB1NTAADYC3NRAQQBB5NTAADYC8N\
RAQQBB3NTAADYC5NRAQQBB7NTAADYC+NRAQQBB5NTAADYC7NRAQQAgBjYCiNZAQQBB7NTAADYC9NRA\
QQAgCEFYaiIANgKA1kAgBiAAQQFyNgIEIAYgAGpBKDYCBEEAQYCAgAE2AqTWQAtBACEBQQAoAoDWQC\
IAIAJNDQBBACAAIAJrIgE2AoDWQEEAQQAoAojWQCIAIAJqIgU2AojWQCAFIAFBAXI2AgQgACACQQNy\
NgIEIABBCGoPCyABC40SASB/IwBBwABrIQMgACgCACIEIAQpAwAgAq18NwMAAkAgAkUNACABIAJBBn\
RqIQUgBEEUaigCACEGIARBEGooAgAhByAEQQxqKAIAIQIgBCgCCCEIIANBGGohCSADQSBqIQogA0E4\
aiELIANBMGohDCADQShqIQ0gA0EIaiEOA0AgCUIANwMAIApCADcDACALQgA3AwAgDEIANwMAIA1CAD\
cDACAOIAEpAAg3AwAgA0EQaiIAIAEpABA3AwAgCSABKAAYIg82AgAgCiABKAAgIhA2AgAgAyABKQAA\
NwMAIAMgASgAHCIRNgIcIAMgASgAJCISNgIkIAQgACgCACITIBAgASgAMCIUIAMoAgAiFSASIAEoAD\
QiFiADKAIEIhcgAygCFCIYIBYgEiAYIBcgFCAQIBMgFSAIIAIgB3FqIAYgAkF/c3FqakH4yKq7fWpB\
B3cgAmoiAGogBiAXaiAHIABBf3NxaiAAIAJxakHW7p7GfmpBDHcgAGoiGSACIAMoAgwiGmogACAZIA\
cgDigCACIbaiACIBlBf3NxaiAZIABxakHb4YGhAmpBEXdqIhxBf3NxaiAcIBlxakHunfeNfGpBFncg\
HGoiAEF/c3FqIAAgHHFqQa+f8Kt/akEHdyAAaiIdaiAYIBlqIBwgHUF/c3FqIB0gAHFqQaqMn7wEak\
EMdyAdaiIZIBEgAGogHSAZIA8gHGogACAZQX9zcWogGSAdcWpBk4zBwXpqQRF3aiIAQX9zcWogACAZ\
cWpBgaqaampBFncgAGoiHEF/c3FqIBwgAHFqQdixgswGakEHdyAcaiIdaiASIBlqIAAgHUF/c3FqIB\
0gHHFqQa/vk9p4akEMdyAdaiIZIAEoACwiHiAcaiAdIBkgASgAKCIfIABqIBwgGUF/c3FqIBkgHXFq\
QbG3fWpBEXdqIgBBf3NxaiAAIBlxakG+r/PKeGpBFncgAGoiHEF/c3FqIBwgAHFqQaKiwNwGakEHdy\
AcaiIdaiABKAA4IiAgAGogHCAWIBlqIAAgHUF/c3FqIB0gHHFqQZPj4WxqQQx3IB1qIgBBf3MiIXFq\
IAAgHXFqQY6H5bN6akERdyAAaiIZICFxaiABKAA8IiEgHGogHSAZQX9zIiJxaiAZIABxakGhkNDNBG\
pBFncgGWoiHCAAcWpB4sr4sH9qQQV3IBxqIh1qIB4gGWogHSAcQX9zcWogDyAAaiAcICJxaiAdIBlx\
akHA5oKCfGpBCXcgHWoiACAccWpB0bT5sgJqQQ53IABqIhkgAEF/c3FqIBUgHGogACAdQX9zcWogGS\
AdcWpBqo/bzX5qQRR3IBlqIhwgAHFqQd2gvLF9akEFdyAcaiIdaiAhIBlqIB0gHEF/c3FqIB8gAGog\
HCAZQX9zcWogHSAZcWpB06iQEmpBCXcgHWoiACAccWpBgc2HxX1qQQ53IABqIhkgAEF/c3FqIBMgHG\
ogACAdQX9zcWogGSAdcWpByPfPvn5qQRR3IBlqIhwgAHFqQeabh48CakEFdyAcaiIdaiAaIBlqIB0g\
HEF/c3FqICAgAGogHCAZQX9zcWogHSAZcWpB1o/cmXxqQQl3IB1qIgAgHHFqQYeb1KZ/akEOdyAAai\
IZIABBf3NxaiAQIBxqIAAgHUF/c3FqIBkgHXFqQe2p6KoEakEUdyAZaiIcIABxakGF0o/PempBBXcg\
HGoiHWogFCAcaiAbIABqIBwgGUF/c3FqIB0gGXFqQfjHvmdqQQl3IB1qIgAgHUF/c3FqIBEgGWogHS\
AcQX9zcWogACAccWpB2YW8uwZqQQ53IABqIhkgHXFqQYqZqel4akEUdyAZaiIcIBlzIiIgAHNqQcLy\
aGpBBHcgHGoiHWogICAcaiAeIBlqIBAgAGogHSAic2pBge3Hu3hqQQt3IB1qIgAgHXMiHSAcc2pBos\
L17AZqQRB3IABqIhkgHXNqQYzwlG9qQRd3IBlqIhwgGXMiIiAAc2pBxNT7pXpqQQR3IBxqIh1qIBEg\
GWogEyAAaiAdICJzakGpn/veBGpBC3cgHWoiEyAdcyIZIBxzakHglu21f2pBEHcgE2oiACATcyAfIB\
xqIBkgAHNqQfD4/vV7akEXdyAAaiIZc2pBxv3txAJqQQR3IBlqIhxqIBogAGogHCAZcyAVIBNqIBkg\
AHMgHHNqQfrPhNV+akELdyAcaiIAc2pBheG8p31qQRB3IABqIh0gAHMgDyAZaiAAIBxzIB1zakGFuq\
AkakEXdyAdaiIZc2pBuaDTzn1qQQR3IBlqIhxqIBsgGWogFCAAaiAZIB1zIBxzakHls+62fmpBC3cg\
HGoiACAccyAhIB1qIBwgGXMgAHNqQfj5if0BakEQdyAAaiIZc2pB5ayxpXxqQRd3IBlqIhwgAEF/c3\
IgGXNqQcTEpKF/akEGdyAcaiIdaiAYIBxqICAgGWogESAAaiAdIBlBf3NyIBxzakGX/6uZBGpBCncg\
HWoiACAcQX9zciAdc2pBp8fQ3HpqQQ93IABqIhkgHUF/c3IgAHNqQbnAzmRqQRV3IBlqIhwgAEF/c3\
IgGXNqQcOz7aoGakEGdyAcaiIdaiAXIBxqIB8gGWogGiAAaiAdIBlBf3NyIBxzakGSmbP4eGpBCncg\
HWoiACAcQX9zciAdc2pB/ei/f2pBD3cgAGoiGSAdQX9zciAAc2pB0buRrHhqQRV3IBlqIhwgAEF/c3\
IgGXNqQc/8of0GakEGdyAcaiIdaiAWIBxqIA8gGWogISAAaiAdIBlBf3NyIBxzakHgzbNxakEKdyAd\
aiIAIBxBf3NyIB1zakGUhoWYempBD3cgAGoiGSAdQX9zciAAc2pBoaOg8ARqQRV3IBlqIhwgAEF/c3\
IgGXNqQYL9zbp/akEGdyAcaiIdIAhqIgg2AgggBCAeIABqIB0gGUF/c3IgHHNqQbXk6+l7akEKdyAd\
aiIAIAZqIgY2AhQgBCAbIBlqIAAgHEF/c3IgHXNqQbul39YCakEPdyAAaiIZIAdqIgc2AhAgBCAZIA\
JqIBIgHGogGSAdQX9zciAAc2pBkaeb3H5qQRV3aiICNgIMIAFBwABqIgEgBUcNAAsLC+gRARh/IwAh\
AiAAKAIAIQMgACgCCCEEIAAoAgwhBSAAKAIEIQYgAkHAAGsiAkEYaiIHQgA3AwAgAkEgaiIIQgA3Aw\
AgAkE4aiIJQgA3AwAgAkEwaiIKQgA3AwAgAkEoaiILQgA3AwAgAkEIaiIMIAEpAAg3AwAgAkEQaiIN\
IAEpABA3AwAgByABKAAYIg42AgAgCCABKAAgIg82AgAgAiABKQAANwMAIAIgASgAHCIQNgIcIAIgAS\
gAJCIRNgIkIAsgASgAKCISNgIAIAIgASgALCILNgIsIAogASgAMCITNgIAIAIgASgANCIKNgI0IAkg\
ASgAOCIUNgIAIAIgASgAPCIJNgI8IAAgAyANKAIAIg0gDyATIAIoAgAiFSARIAogAigCBCIWIAIoAh\
QiFyAKIBEgFyAWIBMgDyANIAYgFSADIAYgBHFqIAUgBkF/c3FqakH4yKq7fWpBB3dqIgFqIAUgFmog\
BCABQX9zcWogASAGcWpB1u6exn5qQQx3IAFqIgcgBiACKAIMIhhqIAEgByAEIAwoAgAiDGogBiAHQX\
9zcWogByABcWpB2+GBoQJqQRF3aiICQX9zcWogAiAHcWpB7p33jXxqQRZ3IAJqIgFBf3NxaiABIAJx\
akGvn/Crf2pBB3cgAWoiCGogFyAHaiACIAhBf3NxaiAIIAFxakGqjJ+8BGpBDHcgCGoiByAQIAFqIA\
ggByAOIAJqIAEgB0F/c3FqIAcgCHFqQZOMwcF6akERd2oiAkF/c3FqIAIgB3FqQYGqmmpqQRZ3IAJq\
IgFBf3NxaiABIAJxakHYsYLMBmpBB3cgAWoiCGogESAHaiACIAhBf3NxaiAIIAFxakGv75PaeGpBDH\
cgCGoiByALIAFqIAggByASIAJqIAEgB0F/c3FqIAcgCHFqQbG3fWpBEXdqIgJBf3NxaiACIAdxakG+\
r/PKeGpBFncgAmoiAUF/c3FqIAEgAnFqQaKiwNwGakEHdyABaiIIaiAUIAJqIAEgCiAHaiACIAhBf3\
NxaiAIIAFxakGT4+FsakEMdyAIaiICQX9zIhlxaiACIAhxakGOh+WzempBEXcgAmoiByAZcWogCSAB\
aiAIIAdBf3MiGXFqIAcgAnFqQaGQ0M0EakEWdyAHaiIBIAJxakHiyviwf2pBBXcgAWoiCGogCyAHai\
AIIAFBf3NxaiAOIAJqIAEgGXFqIAggB3FqQcDmgoJ8akEJdyAIaiICIAFxakHRtPmyAmpBDncgAmoi\
ByACQX9zcWogFSABaiACIAhBf3NxaiAHIAhxakGqj9vNfmpBFHcgB2oiASACcWpB3aC8sX1qQQV3IA\
FqIghqIAkgB2ogCCABQX9zcWogEiACaiABIAdBf3NxaiAIIAdxakHTqJASakEJdyAIaiICIAFxakGB\
zYfFfWpBDncgAmoiByACQX9zcWogDSABaiACIAhBf3NxaiAHIAhxakHI98++fmpBFHcgB2oiASACcW\
pB5puHjwJqQQV3IAFqIghqIBggB2ogCCABQX9zcWogFCACaiABIAdBf3NxaiAIIAdxakHWj9yZfGpB\
CXcgCGoiAiABcWpBh5vUpn9qQQ53IAJqIgcgAkF/c3FqIA8gAWogAiAIQX9zcWogByAIcWpB7anoqg\
RqQRR3IAdqIgEgAnFqQYXSj896akEFdyABaiIIaiATIAFqIAwgAmogASAHQX9zcWogCCAHcWpB+Me+\
Z2pBCXcgCGoiAiAIQX9zcWogECAHaiAIIAFBf3NxaiACIAFxakHZhby7BmpBDncgAmoiASAIcWpBip\
mp6XhqQRR3IAFqIgcgAXMiGSACc2pBwvJoakEEdyAHaiIIaiAUIAdqIAsgAWogDyACaiAIIBlzakGB\
7ce7eGpBC3cgCGoiASAIcyICIAdzakGiwvXsBmpBEHcgAWoiByACc2pBjPCUb2pBF3cgB2oiCCAHcy\
IZIAFzakHE1PulempBBHcgCGoiAmogECAHaiACIAhzIA0gAWogGSACc2pBqZ/73gRqQQt3IAJqIgFz\
akHglu21f2pBEHcgAWoiByABcyASIAhqIAEgAnMgB3NqQfD4/vV7akEXdyAHaiICc2pBxv3txAJqQQ\
R3IAJqIghqIBggB2ogCCACcyAVIAFqIAIgB3MgCHNqQfrPhNV+akELdyAIaiIBc2pBheG8p31qQRB3\
IAFqIgcgAXMgDiACaiABIAhzIAdzakGFuqAkakEXdyAHaiICc2pBuaDTzn1qQQR3IAJqIghqIAwgAm\
ogEyABaiACIAdzIAhzakHls+62fmpBC3cgCGoiASAIcyAJIAdqIAggAnMgAXNqQfj5if0BakEQdyAB\
aiICc2pB5ayxpXxqQRd3IAJqIgcgAUF/c3IgAnNqQcTEpKF/akEGdyAHaiIIaiAXIAdqIBQgAmogEC\
ABaiAIIAJBf3NyIAdzakGX/6uZBGpBCncgCGoiAiAHQX9zciAIc2pBp8fQ3HpqQQ93IAJqIgEgCEF/\
c3IgAnNqQbnAzmRqQRV3IAFqIgcgAkF/c3IgAXNqQcOz7aoGakEGdyAHaiIIaiAWIAdqIBIgAWogGC\
ACaiAIIAFBf3NyIAdzakGSmbP4eGpBCncgCGoiAiAHQX9zciAIc2pB/ei/f2pBD3cgAmoiASAIQX9z\
ciACc2pB0buRrHhqQRV3IAFqIgcgAkF/c3IgAXNqQc/8of0GakEGdyAHaiIIaiAKIAdqIA4gAWogCS\
ACaiAIIAFBf3NyIAdzakHgzbNxakEKdyAIaiICIAdBf3NyIAhzakGUhoWYempBD3cgAmoiASAIQX9z\
ciACc2pBoaOg8ARqQRV3IAFqIgcgAkF/c3IgAXNqQYL9zbp/akEGdyAHaiIIajYCACAAIAUgCyACai\
AIIAFBf3NyIAdzakG15Ovpe2pBCncgCGoiAmo2AgwgACAEIAwgAWogAiAHQX9zciAIc2pBu6Xf1gJq\
QQ93IAJqIgFqNgIIIAAgASAGaiARIAdqIAEgCEF/c3IgAnNqQZGnm9x+akEVd2o2AgQLnw4BDH8gAC\
gCECEDAkACQAJAIAAoAggiBEEBRg0AIANBAUcNAQsCQCADQQFHDQAgASACaiEFIABBFGooAgBBAWoh\
BkEAIQcgASEIAkADQCAIIQMgBkF/aiIGRQ0BIAMgBUYNAgJAAkAgAywAACIJQX9MDQAgA0EBaiEIIA\
lB/wFxIQkMAQsgAy0AAUE/cSEIIAlBH3EhCgJAIAlBX0sNACAKQQZ0IAhyIQkgA0ECaiEIDAELIAhB\
BnQgAy0AAkE/cXIhCAJAIAlBcE8NACAIIApBDHRyIQkgA0EDaiEIDAELIAhBBnQgAy0AA0E/cXIgCk\
ESdEGAgPAAcXIiCUGAgMQARg0DIANBBGohCAsgByADayAIaiEHIAlBgIDEAEcNAAwCCwsgAyAFRg0A\
AkAgAywAACIIQX9KDQAgCEFgSQ0AIAhBcEkNACADLQACQT9xQQZ0IAMtAAFBP3FBDHRyIAMtAANBP3\
FyIAhB/wFxQRJ0QYCA8ABxckGAgMQARg0BCwJAAkAgB0UNAAJAIAcgAkkNAEEAIQMgByACRg0BDAIL\
QQAhAyABIAdqLAAAQUBIDQELIAEhAwsgByACIAMbIQIgAyABIAMbIQELAkAgBA0AIAAoAhggASACIA\
BBHGooAgAoAgwRCAAPCyAAQQxqKAIAIQsCQAJAAkACQCACQRBJDQAgAiABQQNqQXxxIgMgAWsiB0kN\
AiAHQQRLDQIgAiAHayIFQQRJDQIgBUEDcSEEQQAhCkEAIQgCQCADIAFGDQAgB0EDcSEJAkACQCADIA\
FBf3NqQQNPDQBBACEIIAEhAwwBCyAHQXxxIQZBACEIIAEhAwNAIAggAywAAEG/f0pqIAMsAAFBv39K\
aiADLAACQb9/SmogAywAA0G/f0pqIQggA0EEaiEDIAZBfGoiBg0ACwsgCUUNAANAIAggAywAAEG/f0\
pqIQggA0EBaiEDIAlBf2oiCQ0ACwsgASAHaiEDAkAgBEUNACADIAVBfHFqIgksAABBv39KIQogBEEB\
Rg0AIAogCSwAAUG/f0pqIQogBEECRg0AIAogCSwAAkG/f0pqIQoLIAVBAnYhBSAKIAhqIQgDQCADIQ\
QgBUUNBCAFQcABIAVBwAFJGyIKQQNxIQwgCkECdCENAkACQCAKQfwBcSIODQBBACEJDAELIAQgDkEC\
dGohB0EAIQkgBCEDA0AgA0UNASADQQxqKAIAIgZBf3NBB3YgBkEGdnJBgYKECHEgA0EIaigCACIGQX\
9zQQd2IAZBBnZyQYGChAhxIANBBGooAgAiBkF/c0EHdiAGQQZ2ckGBgoQIcSADKAIAIgZBf3NBB3Yg\
BkEGdnJBgYKECHEgCWpqamohCSADQRBqIgMgB0cNAAsLIAUgCmshBSAEIA1qIQMgCUEIdkH/gfwHcS\
AJQf+B/AdxakGBgARsQRB2IAhqIQggDEUNAAsCQCAEDQBBACEDDAILIAQgDkECdGoiCSgCACIDQX9z\
QQd2IANBBnZyQYGChAhxIQMgDEEBRg0BIAkoAgQiBkF/c0EHdiAGQQZ2ckGBgoQIcSADaiEDIAxBAk\
YNASAJKAIIIglBf3NBB3YgCUEGdnJBgYKECHEgA2ohAwwBCwJAIAINAEEAIQgMAwsgAkEDcSEJAkAC\
QCACQX9qQQNPDQBBACEIIAEhAwwBCyACQXxxIQZBACEIIAEhAwNAIAggAywAAEG/f0pqIAMsAAFBv3\
9KaiADLAACQb9/SmogAywAA0G/f0pqIQggA0EEaiEDIAZBfGoiBg0ACwsgCUUNAgNAIAggAywAAEG/\
f0pqIQggA0EBaiEDIAlBf2oiCQ0ADAMLCyADQQh2Qf+BHHEgA0H/gfwHcWpBgYAEbEEQdiAIaiEIDA\
ELIAJBfHEhCUEAIQggASEDA0AgCCADLAAAQb9/SmogAywAAUG/f0pqIAMsAAJBv39KaiADLAADQb9/\
SmohCCADQQRqIQMgCUF8aiIJDQALIAJBA3EiBkUNAEEAIQkDQCAIIAMgCWosAABBv39KaiEIIAYgCU\
EBaiIJRw0ACwsCQCALIAhNDQAgCyAIayIIIQcCQAJAAkBBACAALQAgIgMgA0EDRhtBA3EiAw4DAgAB\
AgtBACEHIAghAwwBCyAIQQF2IQMgCEEBakEBdiEHCyADQQFqIQMgAEEcaigCACEJIABBGGooAgAhBi\
AAKAIEIQgCQANAIANBf2oiA0UNASAGIAggCSgCEBEGAEUNAAtBAQ8LQQEhAyAIQYCAxABGDQIgBiAB\
IAIgCSgCDBEIAA0CQQAhAwNAAkAgByADRw0AIAcgB0kPCyADQQFqIQMgBiAIIAkoAhARBgBFDQALIA\
NBf2ogB0kPCyAAKAIYIAEgAiAAQRxqKAIAKAIMEQgADwsgACgCGCABIAIgAEEcaigCACgCDBEIACED\
CyADC5UMARh/IwAhAiAAKAIAIQMgACgCCCEEIAAoAgwhBSAAKAIEIQYgAkHAAGsiAkEYaiIHQgA3Aw\
AgAkEgaiIIQgA3AwAgAkE4aiIJQgA3AwAgAkEwaiIKQgA3AwAgAkEoaiILQgA3AwAgAkEIaiIMIAEp\
AAg3AwAgAkEQaiINIAEpABA3AwAgByABKAAYIg42AgAgCCABKAAgIg82AgAgAiABKQAANwMAIAIgAS\
gAHCIQNgIcIAIgASgAJCIRNgIkIAsgASgAKCISNgIAIAIgASgALCILNgIsIAogASgAMCITNgIAIAIg\
ASgANCIKNgI0IAkgASgAOCIUNgIAIAIgASgAPCIVNgI8IAAgAyATIAsgECAGIAIoAgwiFmogBCAFIA\
YgAyAGIARxaiAFIAZBf3NxaiACKAIAIhdqQQN3IgFxaiAEIAFBf3NxaiACKAIEIhhqQQd3IgcgAXFq\
IAYgB0F/c3FqIAwoAgAiDGpBC3ciCCAHcWogASAIQX9zcWpBE3ciCWogDiAJIAhxIAFqIAcgCUF/c3\
FqIA0oAgAiDWpBA3ciASAJcSAHaiAIIAFBf3NxaiACKAIUIhlqQQd3IgIgAXEgCGogCSACQX9zcWpq\
QQt3IgcgAnFqIAEgB0F/c3FqQRN3IghqIBIgESAPIAggB3EgAWogAiAIQX9zcWpqQQN3IgEgCHEgAm\
ogByABQX9zcWpqQQd3IgIgAXEgB2ogCCACQX9zcWpqQQt3IgcgAnFqIAEgB0F/c3FqQRN3IgggB3Eg\
AWogAiAIQX9zcWpqQQN3IgEgFCABIAogASAIcSACaiAHIAFBf3NxampBB3ciCXEgB2ogCCAJQX9zcW\
pqQQt3IgIgCXIgFSAIaiACIAlxIgdqIAEgAkF/c3FqQRN3IgFxIAdyaiAXakGZ84nUBWpBA3ciByAC\
IA9qIAkgDWogByABIAJycSABIAJxcmpBmfOJ1AVqQQV3IgIgByABcnEgByABcXJqQZnzidQFakEJdy\
IIIAJyIAEgE2ogCCACIAdycSACIAdxcmpBmfOJ1AVqQQ13IgFxIAggAnFyaiAYakGZ84nUBWpBA3ci\
ByAIIBFqIAIgGWogByABIAhycSABIAhxcmpBmfOJ1AVqQQV3IgIgByABcnEgByABcXJqQZnzidQFak\
EJdyIIIAJyIAEgCmogCCACIAdycSACIAdxcmpBmfOJ1AVqQQ13IgFxIAggAnFyaiAMakGZ84nUBWpB\
A3ciByAIIBJqIAIgDmogByABIAhycSABIAhxcmpBmfOJ1AVqQQV3IgIgByABcnEgByABcXJqQZnzid\
QFakEJdyIIIAJyIAEgFGogCCACIAdycSACIAdxcmpBmfOJ1AVqQQ13IgFxIAggAnFyaiAWakGZ84nU\
BWpBA3ciByABIBVqIAggC2ogAiAQaiAHIAEgCHJxIAEgCHFyakGZ84nUBWpBBXciAiAHIAFycSAHIA\
FxcmpBmfOJ1AVqQQl3IgggAiAHcnEgAiAHcXJqQZnzidQFakENdyIHIAhzIgkgAnNqIBdqQaHX5/YG\
akEDdyIBIAcgE2ogASAPIAIgCSABc2pqQaHX5/YGakEJdyICcyAIIA1qIAEgB3MgAnNqQaHX5/YGak\
ELdyIHc2pBodfn9gZqQQ93IgggB3MiCSACc2ogDGpBodfn9gZqQQN3IgEgCCAUaiABIBIgAiAJIAFz\
ampBodfn9gZqQQl3IgJzIAcgDmogASAIcyACc2pBodfn9gZqQQt3IgdzakGh1+f2BmpBD3ciCCAHcy\
IJIAJzaiAYakGh1+f2BmpBA3ciASAIIApqIAEgESACIAkgAXNqakGh1+f2BmpBCXciAnMgByAZaiAB\
IAhzIAJzakGh1+f2BmpBC3ciB3NqQaHX5/YGakEPdyIIIAdzIgkgAnNqIBZqQaHX5/YGakEDdyIBaj\
YCACAAIAUgCyACIAkgAXNqakGh1+f2BmpBCXciAmo2AgwgACAEIAcgEGogASAIcyACc2pBodfn9gZq\
QQt3IgdqNgIIIAAgBiAIIBVqIAIgAXMgB3NqQaHX5/YGakEPd2o2AgQL+w0CDX8BfiMAQaACayIHJA\
ACQAJAAkACQAJAAkACQAJAAkACQCABQYEISQ0AQX8gAUF/aiIIQQt2Z3ZBCnRBgAhqQYAIIAhB/w9L\
GyIIIAFLDQMgB0EIakEAQYABEJMBGiABIAhrIQkgACAIaiEKIAhBCnatIAN8IRQgCEGACEcNASAHQQ\
hqQSBqIQtB4AAhDCAAQYAIIAIgAyAEIAdBCGpBIBAeIQEMAgtBACEIIAdBADYCjAEgAUGAeHEiCkUN\
BiAKQYAIRg0FIAcgAEGACGo2AghBsJHAACAHQQhqQbSHwABBlIfAABBhAAtBwAAhDCAHQQhqQcAAai\
ELIAAgCCACIAMgBCAHQQhqQcAAEB4hAQsgCiAJIAIgFCAEIAsgDBAeIQgCQCABQQFHDQAgBkE/TQ0C\
IAUgBykACDcAACAFQThqIAdBCGpBOGopAAA3AAAgBUEwaiAHQQhqQTBqKQAANwAAIAVBKGogB0EIak\
EoaikAADcAACAFQSBqIAdBCGpBIGopAAA3AAAgBUEYaiAHQQhqQRhqKQAANwAAIAVBEGogB0EIakEQ\
aikAADcAACAFQQhqIAdBCGpBCGopAAA3AABBAiEIDAYLIAggAWpBBXQiAUGBAU8NAiAHQQhqIAEgAi\
AEIAUgBhAtIQgMBQtB6IzAAEEjQeCEwAAQcgALQcAAIAZBgIXAABCLAQALIAFBgAFB8ITAABCLAQAL\
IAcgADYCiAFBASEIIAdBATYCjAELIAFB/wdxIQkCQCAIIAZBBXYiASAIIAFJG0UNACAHKAKIASEBIA\
dBCGpBGGoiCyACQRhqKQIANwMAIAdBCGpBEGoiDCACQRBqKQIANwMAIAdBCGpBCGoiDSACQQhqKQIA\
NwMAIAcgAikCADcDCCAHQQhqIAFBwAAgAyAEQQFyEBggB0EIaiABQcAAakHAACADIAQQGCAHQQhqIA\
FBgAFqQcAAIAMgBBAYIAdBCGogAUHAAWpBwAAgAyAEEBggB0EIaiABQYACakHAACADIAQQGCAHQQhq\
IAFBwAJqQcAAIAMgBBAYIAdBCGogAUGAA2pBwAAgAyAEEBggB0EIaiABQcADakHAACADIAQQGCAHQQ\
hqIAFBgARqQcAAIAMgBBAYIAdBCGogAUHABGpBwAAgAyAEEBggB0EIaiABQYAFakHAACADIAQQGCAH\
QQhqIAFBwAVqQcAAIAMgBBAYIAdBCGogAUGABmpBwAAgAyAEEBggB0EIaiABQcAGakHAACADIAQQGC\
AHQQhqIAFBgAdqQcAAIAMgBBAYIAdBCGogAUHAB2pBwAAgAyAEQQJyEBggBSALKQMANwAYIAUgDCkD\
ADcAECAFIA0pAwA3AAggBSAHKQMINwAACyAJRQ0AIAdBkAFqQTBqIg1CADcDACAHQZABakE4aiIOQg\
A3AwAgB0GQAWpBwABqIg9CADcDACAHQZABakHIAGoiEEIANwMAIAdBkAFqQdAAaiIRQgA3AwAgB0GQ\
AWpB2ABqIhJCADcDACAHQZABakHgAGoiE0IANwMAIAdBkAFqQSBqIgEgAkEYaikCADcDACAHQZABak\
EYaiILIAJBEGopAgA3AwAgB0GQAWpBEGoiDCACQQhqKQIANwMAIAdCADcDuAEgByAEOgD6ASAHQQA7\
AfgBIAcgAikCADcDmAEgByAIrSADfDcDkAEgB0GQAWogACAKaiAJEDchBCAHQQhqQRBqIAwpAwA3Aw\
AgB0EIakEYaiALKQMANwMAIAdBCGpBIGogASkDADcDACAHQQhqQTBqIA0pAwA3AwAgB0EIakE4aiAO\
KQMANwMAIAdBCGpBwABqIA8pAwA3AwAgB0EIakHIAGogECkDADcDACAHQQhqQdAAaiARKQMANwMAIA\
dBCGpB2ABqIBIpAwA3AwAgB0EIakHgAGogEykDADcDACAHIAcpA5gBNwMQIAcgBykDuAE3AzAgBy0A\
+gEhAiAHLQD5ASEAIAcgBy0A+AEiCToAcCAHIAQpAwAiAzcDCCAHIAIgAEVyQQJyIgQ6AHEgB0GAAm\
pBGGoiAiABKQMANwMAIAdBgAJqQRBqIgEgCykDADcDACAHQYACakEIaiIAIAwpAwA3AwAgByAHKQOY\
ATcDgAIgB0GAAmogB0EwaiAJIAMgBBAYIAhBBXQiBEEgaiIJIAZLDQEgAigCACECIAEoAgAhASAAKA\
IAIQAgBygClAIhBiAHKAKMAiEJIAcoAoQCIQogBygCgAIhCyAFIARqIgQgBygCnAI2ABwgBCACNgAY\
IAQgBjYAFCAEIAE2ABAgBCAJNgAMIAQgADYACCAEIAo2AAQgBCALNgAAIAhBAWohCAsgB0GgAmokAC\
AIDwsgCSAGQbCEwAAQiwEAC4MNAhJ/BH4jAEGwAWsiAiQAAkACQCABKAKQASIDDQAgACABKQMINwMI\
IAAgASkDKDcDKCAAQRBqIAFBEGopAwA3AwAgAEEYaiABQRhqKQMANwMAIABBIGogAUEgaikDADcDAC\
AAQTBqIAFBMGopAwA3AwAgAEE4aiABQThqKQMANwMAIABBwABqIAFBwABqKQMANwMAIABByABqIAFB\
yABqKQMANwMAIABB0ABqIAFB0ABqKQMANwMAIABB2ABqIAFB2ABqKQMANwMAIABB4ABqIAFB4ABqKQ\
MANwMAIAFB6QBqLQAAIQQgAS0AaiEFIAAgAS0AaDoAaCAAIAEpAwA3AwAgACAFIARFckECcjoAaQwB\
CwJAAkACQAJAIAFB6QBqLQAAIgRBBnRBACABLQBoIgZrRw0AIANBfmohByADQQFNDQIgAS0AaiEIIA\
JB8ABqQRhqIgkgAUGUAWoiBSAHQQV0aiIEQRhqKQAANwMAIAJB8ABqQRBqIgogBEEQaikAADcDACAC\
QfAAakEIaiILIARBCGopAAA3AwAgAkHwAGpBIGoiBiADQQV0IAVqQWBqIgUpAAA3AwAgAkGYAWoiDC\
AFQQhqKQAANwMAIAJB8ABqQTBqIg0gBUEQaikAADcDACACQfAAakE4aiIOIAVBGGopAAA3AwAgAiAE\
KQAANwNwIAJBIGogAUGIAWopAwA3AwAgAkEYaiABQYABaikDADcDACACQRBqIAFB+ABqKQMANwMAIA\
IgASkDcDcDCCACQeAAaiAOKQMANwMAIAJB2ABqIA0pAwA3AwAgAkHQAGogDCkDADcDACACQcgAaiAG\
KQMANwMAQcAAIQYgAkHAAGogCSkDADcDACACQThqIAopAwA3AwAgAkEwaiALKQMANwMAIAIgAikDcD\
cDKCACIAhBBHIiCDoAaSACQcAAOgBoQgAhFCACQgA3AwAgCCEOIAcNAQwDCyACQRBqIAFBEGopAwA3\
AwAgAkEYaiABQRhqKQMANwMAIAJBIGogAUEgaikDADcDACACQTBqIAFBMGopAwA3AwAgAkE4aiABQT\
hqKQMANwMAIAJBwABqIAFBwABqKQMANwMAIAJByABqIAFByABqKQMANwMAIAJB0ABqIAFB0ABqKQMA\
NwMAIAJB2ABqIAFB2ABqKQMANwMAIAJB4ABqIAFB4ABqKQMANwMAIAIgASkDCDcDCCACIAEpAyg3Ay\
ggAiABLQBqIgUgBEVyQQJyIg46AGkgAiAGOgBoIAIgASkDACIUNwMAIAVBBHIhCCADIQcLAkAgB0F/\
aiINIANPIg8NACACQfAAakEYaiIJIAJBCGoiBEEYaiIKKQIANwMAIAJB8ABqQRBqIgsgBEEQaiIMKQ\
IANwMAIAJB8ABqQQhqIhAgBEEIaiIRKQIANwMAIAIgBCkCADcDcCACQfAAaiACQShqIgUgBiAUIA4Q\
GCAQKQMAIRQgCykDACEVIAkpAwAhFiACKQNwIRcgBUEYaiIQIAFBlAFqIA1BBXRqIgZBGGopAgA3Ag\
AgBUEQaiISIAZBEGopAgA3AgAgBUEIaiAGQQhqKQIANwIAIAUgBikCADcCACAEIAFB8ABqIgYpAwA3\
AwAgESAGQQhqKQMANwMAIAwgBkEQaiIRKQMANwMAIAogBkEYaiITKQMANwMAIAIgFjcDYCACIBU3A1\
ggAiAUNwNQIAIgFzcDSCACIAg6AGkgAkHAADoAaCACQgA3AwAgDUUNAkECIAdrIQ0gB0EFdCABakHU\
AGohAQJAA0AgDw0BIAkgCikCADcDACALIAwpAgA3AwAgAkHwAGpBCGoiByAEQQhqIg4pAgA3AwAgAi\
AEKQIANwNwIAJB8ABqIAVBwABCACAIEBggBykDACEUIAspAwAhFSAJKQMAIRYgAikDcCEXIBAgAUEY\
aikCADcCACASIAFBEGopAgA3AgAgBUEIaiABQQhqKQIANwIAIAUgASkCADcCACAEIAYpAwA3AwAgDi\
AGQQhqKQMANwMAIAwgESkDADcDACAKIBMpAwA3AwAgAiAWNwNgIAIgFTcDWCACIBQ3A1AgAiAXNwNI\
IAIgCDoAaSACQcAAOgBoIAJCADcDACABQWBqIQEgDUEBaiINQQFGDQQMAAsLQQAgDWshDQsgDSADQY\
CGwAAQawALIAcgA0HwhcAAEGsACyAAIAJB8AAQlAEaCyAAQQA6AHAgAkGwAWokAAugDQICfwR+IwBB\
kAJrIgMkAAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAkF9ag\
4JAwwKCwEFDAIADAsCQCABQZeAwABBCxCVAUUNACABQaKAwABBCxCVAQ0MQdABEBkiAUUNFiADQZAB\
aiICQTAQcyABIAJByAAQlAEhAiADQQA2AgAgAyADQQRyQQBBgAEQkwFBf3NqQYQBakEHSRogA0GAAT\
YCACADQYgBaiADQYQBEJQBGiACQcgAaiADQYgBakEEckGAARCUARogAkHIAWpBADoAAEECIQIMFAtB\
0AEQGSIBRQ0VIANBkAFqIgJBIBBzIAEgAkHIABCUASECIANBADYCACADIANBBHJBAEGAARCTAUF/c2\
pBhAFqQQdJGiADQYABNgIAIANBiAFqIANBhAEQlAEaIAJByABqIANBiAFqQQRyQYABEJQBGiACQcgB\
akEAOgAAQQEhAgwTCyABQZCAwABBBxCVAUUNEQJAIAFBrYDAAEEHEJUBRQ0AIAFB94DAACACEJUBRQ\
0FIAFB/oDAACACEJUBRQ0GIAFBhYHAACACEJUBRQ0HIAFBjIHAACACEJUBDQtBFCECEE0hAQwTC0Hw\
ABAZIgFFDRQgA0GIAWpBCGoQeiABQSBqIANBiAFqQShqKQMANwMAIAFBGGogA0GIAWpBIGopAwA3Aw\
AgAUEQaiADQYgBakEYaikDADcDACABQQhqIANBiAFqQRBqKQMANwMAIAEgAykDkAE3AwAgA0EMakIA\
NwIAIANBFGpCADcCACADQRxqQgA3AgAgA0EkakIANwIAIANBLGpCADcCACADQTRqQgA3AgAgA0E8ak\
IANwIAIANCADcCBCADQQA2AgAgAyADQQRyQX9zakHEAGpBB0kaIANBwAA2AgAgA0GIAWogA0HEABCU\
ARogAUEoaiICQThqIANBiAFqQTxqKQIANwAAIAJBMGogA0GIAWpBNGopAgA3AAAgAkEoaiADQYgBak\
EsaikCADcAACACQSBqIANBiAFqQSRqKQIANwAAIAJBGGogA0GIAWpBHGopAgA3AAAgAkEQaiADQYgB\
akEUaikCADcAACACQQhqIANBiAFqQQxqKQIANwAAIAIgAykCjAE3AAAgAUHoAGpBADoAAEEDIQIMEg\
sgAUG6gMAAQQoQlQFFDQogAUHEgMAAQQoQlQFFDQsCQCABQc6AwABBChCVAUUNACABQdiAwABBChCV\
AQ0CQQghAhBYIQEMEgtBByECEFkhAQwRCwJAIAFB4oDAAEEDEJUBRQ0AIAFB5YDAAEEDEJUBDQlBCi\
ECED8hAQwRC0EJIQIQPyEBDBALIAFB6IDAAEEKEJUBDQdBCyECEDQhAQwPCyABKQAAQtOQhZrTxYyZ\
NFENCSABKQAAQtOQhZrTxcyaNlENCgJAIAEpAABC05CFmtPljJw0UQ0AIAEpAABC05CFmtOlzZgyUg\
0EQRAhAhBYIQEMDwtBDyECEFkhAQwOC0ERIQIQMiEBDA0LQRIhAhAzIQEMDAtBEyECEE4hAQwLCwJA\
IAEpAABC05CF2tSojJk4UQ0AIAEpAABC05CF2tTIzJo2Ug0DQRYhAhBaIQEMCwtBFSECEFshAQwKCy\
ABQfKAwABBBRCVAUUNBiABQZOBwABBBRCVAQ0BQRchAhA1IQEMCQsgAUG0gMAAQQYQlQFFDQYLIABB\
mIHAADYCBCAAQQhqQRU2AgBBASEBDAgLQQUhAhBcIQEMBgtBBiECEFohAQwFC0ENIQIQXCEBDAQLQQ\
4hAhBaIQEMAwtBDCECEDshAQwCC0H4DhAZIgFFDQMgAUEANgKQASABQgA3AwAgAUGIAWpBACkDwI1A\
IgU3AwAgAUGAAWpBACkDuI1AIgY3AwAgAUH4AGpBACkDsI1AIgc3AwAgAUEAKQOojUAiCDcDcCABIA\
g3AwggAUEQaiAHNwMAIAFBGGogBjcDACABQSBqIAU3AwAgAUEoakEAQcMAEJMBGkEEIQIMAQtB0AEQ\
GSIBRQ0CIANBkAFqIgJBwAAQcyABIAJByAAQlAEhBEEAIQIgA0EANgIAIAMgA0EEckEAQYABEJMBQX\
9zakGEAWpBB0kaIANBgAE2AgAgA0GIAWogA0GEARCUARogBEHIAGogA0GIAWpBBHJBgAEQlAEaIARB\
yAFqQQA6AAALIAAgAjYCBCAAQQhqIAE2AgBBACEBCyAAIAE2AgAgA0GQAmokAA8LAAvPDQIDfwV+Iw\
BBoAFrIgIkAAJAAkAgAUUNACABKAIADQEgAUF/NgIAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC\
QAJAAkACQAJAAkACQAJAAkACQAJAAkAgASgCBA4YAAECAwQFBgcICQoLDA0ODxAREhMUFRYXAAsgAU\
EIaigCACEDIAJB0ABqQQhqIgRBwAAQcyACQQhqIARByAAQlAEaIAMgAkEIakHIABCUAUHIAWpBADoA\
AAwXCyABQQhqKAIAIQMgAkHQAGpBCGoiBEEgEHMgAkEIaiAEQcgAEJQBGiADIAJBCGpByAAQlAFByA\
FqQQA6AAAMFgsgAUEIaigCACEDIAJB0ABqQQhqIgRBMBBzIAJBCGogBEHIABCUARogAyACQQhqQcgA\
EJQBQcgBakEAOgAADBULIAFBCGooAgAhAyACQdAAakEIahB6IAJBCGpBIGogAkH4AGopAwAiBTcDAC\
ACQQhqQRhqIAJB0ABqQSBqKQMAIgY3AwAgAkEIakEQaiACQdAAakEYaikDACIHNwMAIAJBCGpBCGog\
AkHQAGpBEGopAwAiCDcDACACIAIpA1giCTcDCCADQSBqIAU3AwAgA0EYaiAGNwMAIANBEGogBzcDAC\
ADQQhqIAg3AwAgAyAJNwMAIANB6ABqQQA6AAAMFAsgAUEIaigCACIDQgA3AwAgAyADKQNwNwMIIANB\
EGogA0H4AGopAwA3AwAgA0EYaiADQYABaikDADcDACADQSBqIANBiAFqKQMANwMAIANBKGpBAEHCAB\
CTARogAygCkAFFDRMgA0EANgKQAQwTCyABQQhqKAIAQQBByAEQkwFB2AJqQQA6AAAMEgsgAUEIaigC\
AEEAQcgBEJMBQdACakEAOgAADBELIAFBCGooAgBBAEHIARCTAUGwAmpBADoAAAwQCyABQQhqKAIAQQ\
BByAEQkwFBkAJqQQA6AAAMDwsgAUEIaigCACIDQv6568XpjpWZEDcDECADQoHGlLqW8ermbzcDCCAD\
QgA3AwAgA0HYAGpBADoAAAwOCyABQQhqKAIAIgNC/rnrxemOlZkQNwMQIANCgcaUupbx6uZvNwMIIA\
NCADcDACADQdgAakEAOgAADA0LIAFBCGooAgAiA0IANwMAIANBACkDkI1ANwMIIANBEGpBACkDmI1A\
NwMAIANBGGpBACgCoI1ANgIAIANB4ABqQQA6AAAMDAsgAUEIaigCACIDQfDDy558NgIYIANC/rnrxe\
mOlZkQNwMQIANCgcaUupbx6uZvNwMIIANCADcDACADQeAAakEAOgAADAsLIAFBCGooAgBBAEHIARCT\
AUHYAmpBADoAAAwKCyABQQhqKAIAQQBByAEQkwFB0AJqQQA6AAAMCQsgAUEIaigCAEEAQcgBEJMBQb\
ACakEAOgAADAgLIAFBCGooAgBBAEHIARCTAUGQAmpBADoAAAwHCyABQQhqKAIAIgNCADcDACADQQAp\
A8iNQDcDCCADQRBqQQApA9CNQDcDACADQRhqQQApA9iNQDcDACADQSBqQQApA+CNQDcDACADQegAak\
EAOgAADAYLIAFBCGooAgAiA0IANwMAIANBACkDqI1ANwMIIANBEGpBACkDsI1ANwMAIANBGGpBACkD\
uI1ANwMAIANBIGpBACkDwI1ANwMAIANB6ABqQQA6AAAMBQsgAUEIaigCACIDQgA3A0AgA0EAKQOojk\
A3AwAgA0HIAGpCADcDACADQQhqQQApA7COQDcDACADQRBqQQApA7iOQDcDACADQRhqQQApA8COQDcD\
ACADQSBqQQApA8iOQDcDACADQShqQQApA9COQDcDACADQTBqQQApA9iOQDcDACADQThqQQApA+COQD\
cDACADQdABakEAOgAADAQLIAFBCGooAgAiA0IANwNAIANBACkD6I1ANwMAIANByABqQgA3AwAgA0EI\
akEAKQPwjUA3AwAgA0EQakEAKQP4jUA3AwAgA0EYakEAKQOAjkA3AwAgA0EgakEAKQOIjkA3AwAgA0\
EoakEAKQOQjkA3AwAgA0EwakEAKQOYjkA3AwAgA0E4akEAKQOgjkA3AwAgA0HQAWpBADoAAAwDCyAB\
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\
BkIhhkKAgICAgOA/gyAGQhGGQoCAgIDwH4OEhCEIAkAgBEE/cyIARQ0AIAVBAWpBACAAEJMBGgsgCC\
AJhCEIAkACQCAEQThxQThGDQAgASAINwA4IANBCGogAUEBEBUMAQsgA0EIaiABQQEQFSADQeAAakEM\
akIANwIAIANB4ABqQRRqQgA3AgAgA0HgAGpBHGpCADcCACADQeAAakEkakIANwIAIANB4ABqQSxqQg\
A3AgAgA0HgAGpBNGpCADcCACADQZwBakIANwIAIANCADcCZCADQQA2AmAgA0HgAGogA0HgAGpBBHJB\
f3NqQcQAakEHSRogA0HAADYCYCADQagBaiADQeAAakHEABCUARogA0HQAGogA0GoAWpBNGopAgA3Aw\
AgA0HIAGogA0GoAWpBLGopAgA3AwAgA0HAAGogA0GoAWpBJGopAgA3AwAgA0E4aiADQagBakEcaikC\
ADcDACADQTBqIANBqAFqQRRqKQIANwMAIANBKGogA0GoAWpBDGopAgA3AwAgAyADKQKsATcDICADIA\
g3A1ggA0EIaiADQSBqQQEQFQsgAUEAOgBAIAIgAygCCCIBQRh0IAFBCHRBgID8B3FyIAFBCHZBgP4D\
cSABQRh2cnI2AAAgAiADKAIMIgFBGHQgAUEIdEGAgPwHcXIgAUEIdkGA/gNxIAFBGHZycjYABCACIA\
MoAhAiAUEYdCABQQh0QYCA/AdxciABQQh2QYD+A3EgAUEYdnJyNgAIIAIgAygCFCIBQRh0IAFBCHRB\
gID8B3FyIAFBCHZBgP4DcSABQRh2cnI2AAwgAiADKAIYIgFBGHQgAUEIdEGAgPwHcXIgAUEIdkGA/g\
NxIAFBGHZycjYAECADQfABaiQAC/8GARd/IwBB0AFrIgIkAAJAAkACQCAAKAKQASIDIAF7pyIETQ0A\
IANBf2ohBSAAQfAAaiEGIANBBXQgAGpB1ABqIQcgAkEgakEoaiEIIAJBIGpBCGohCSACQZABakEgai\
EKIAJBEGohCyACQRhqIQwgA0F+akE3SSENA0AgACAFNgKQASACQQhqIgMgB0EoaikAADcDACALIAdB\
MGopAAA3AwAgDCAHQThqKQAANwMAIAIgB0EgaikAADcDACAFRQ0CIAAgBUF/aiIONgKQASAALQBqIQ\
8gCiACKQMANwAAIApBCGogAykDADcAACAKQRBqIAspAwA3AAAgCkEYaiAMKQMANwAAIAJBkAFqQRhq\
IgMgB0EYaiIQKQAANwMAIAJBkAFqQRBqIhEgB0EQaiISKQAANwMAIAJBkAFqQQhqIhMgB0EIaiIUKQ\
AANwMAIAkgBikDADcDACAJQQhqIAZBCGoiFSkDADcDACAJQRBqIAZBEGoiFikDADcDACAJQRhqIAZB\
GGoiFykDADcDACACIAcpAAA3A5ABIAhBOGogAkGQAWpBOGopAwA3AAAgCEEwaiACQZABakEwaikDAD\
cAACAIQShqIAJBkAFqQShqKQMANwAAIAhBIGogCikDADcAACAIQRhqIAMpAwA3AAAgCEEQaiARKQMA\
NwAAIAhBCGogEykDADcAACAIIAIpA5ABNwAAIAJBwAA6AIgBIAIgD0EEciIPOgCJASACQgA3AyAgAy\
AXKQIANwMAIBEgFikCADcDACATIBUpAgA3AwAgAiAGKQIANwOQASACQZABaiAIQcAAQgAgDxAYIAMo\
AgAhAyARKAIAIREgEygCACETIAIoAqwBIQ8gAigCpAEhFSACKAKcASEWIAIoApQBIRcgAigCkAEhGC\
ANRQ0DIAcgGDYCACAHQRxqIA82AgAgECADNgIAIAdBFGogFTYCACASIBE2AgAgB0EMaiAWNgIAIBQg\
EzYCACAHQQRqIBc2AgAgACAFNgKQASAHQWBqIQcgDiEFIA4gBE8NAAsLIAJB0AFqJAAPC0HYkMAAQS\
tBwIXAABByAAsgAiAPNgKsASACIAM2AqgBIAIgFTYCpAEgAiARNgKgASACIBY2ApwBIAIgEzYCmAEg\
AiAXNgKUASACIBg2ApABQbCRwAAgAkGQAWpBpIfAAEGUh8AAEGEAC5wFAQp/IwBBMGsiAyQAIANBJG\
ogATYCACADQQM6ACggA0KAgICAgAQ3AwggAyAANgIgQQAhBCADQQA2AhggA0EANgIQAkACQAJAAkAg\
AigCCCIFDQAgAkEUaigCACIARQ0BIAIoAhAhASAAQQN0IQYgAEF/akH/////AXFBAWohBCACKAIAIQ\
ADQAJAIABBBGooAgAiB0UNACADKAIgIAAoAgAgByADKAIkKAIMEQgADQQLIAEoAgAgA0EIaiABQQRq\
KAIAEQYADQMgAUEIaiEBIABBCGohACAGQXhqIgYNAAwCCwsgAkEMaigCACIBRQ0AIAFBBXQhCCABQX\
9qQf///z9xQQFqIQQgAigCACEAQQAhBgNAAkAgAEEEaigCACIBRQ0AIAMoAiAgACgCACABIAMoAiQo\
AgwRCAANAwsgAyAFIAZqIgFBHGotAAA6ACggAyABQQRqKQIAQiCJNwMIIAFBGGooAgAhCSACKAIQIQ\
pBACELQQAhBwJAAkACQCABQRRqKAIADgMBAAIBCyAJQQN0IQxBACEHIAogDGoiDEEEaigCAEEERw0B\
IAwoAgAoAgAhCQtBASEHCyADIAk2AhQgAyAHNgIQIAFBEGooAgAhBwJAAkACQCABQQxqKAIADgMBAA\
IBCyAHQQN0IQkgCiAJaiIJQQRqKAIAQQRHDQEgCSgCACgCACEHC0EBIQsLIAMgBzYCHCADIAs2Ahgg\
CiABKAIAQQN0aiIBKAIAIANBCGogASgCBBEGAA0CIABBCGohACAIIAZBIGoiBkcNAAsLAkAgBCACKA\
IETw0AIAMoAiAgAigCACAEQQN0aiIBKAIAIAEoAgQgAygCJCgCDBEIAA0BC0EAIQEMAQtBASEBCyAD\
QTBqJAAgAQuaBAIDfwJ+IwBB8AFrIgMkACAAKQMAIQYgASABLQBAIgRqIgVBgAE6AAAgA0EIakEQai\
AAQRhqKAIANgIAIANBEGogAEEQaikCADcDACADIAApAgg3AwggBkIJhiEGIAStQgOGIQcCQCAEQT9z\
IgBFDQAgBUEBakEAIAAQkwEaCyAGIAeEIQYCQAJAIARBOHFBOEYNACABIAY3ADggA0EIaiABEBMMAQ\
sgA0EIaiABEBMgA0HgAGpBDGpCADcCACADQeAAakEUakIANwIAIANB4ABqQRxqQgA3AgAgA0HgAGpB\
JGpCADcCACADQeAAakEsakIANwIAIANB4ABqQTRqQgA3AgAgA0GcAWpCADcCACADQgA3AmQgA0EANg\
JgIANB4ABqIANB4ABqQQRyQX9zakHEAGpBB0kaIANBwAA2AmAgA0GoAWogA0HgAGpBxAAQlAEaIANB\
0ABqIANBqAFqQTRqKQIANwMAIANByABqIANBqAFqQSxqKQIANwMAIANBwABqIANBqAFqQSRqKQIANw\
MAIANBOGogA0GoAWpBHGopAgA3AwAgA0EwaiADQagBakEUaikCADcDACADQShqIANBqAFqQQxqKQIA\
NwMAIAMgAykCrAE3AyAgAyAGNwNYIANBCGogA0EgahATCyABQQA6AEAgAiADKAIINgAAIAIgAykCDD\
cABCACIAMpAhQ3AAwgA0HwAWokAAuKBAEKfyMAQTBrIgYkAEEAIQcgBkEANgIIAkAgAUFAcSIIRQ0A\
QQEhByAGQQE2AgggBiAANgIAIAhBwABGDQBBAiEHIAZBAjYCCCAGIABBwABqNgIEIAhBgAFGDQAgBi\
AAQYABajYCEEGwkcAAIAZBEGpBoIbAAEGUh8AAEGEACyABQT9xIQkCQCAHIAVBBXYiASAHIAFJGyIB\
RQ0AIANBBHIhCiABQQV0IQtBACEDIAYhDANAIAwoAgAhASAGQRBqQRhqIg0gAkEYaikCADcDACAGQR\
BqQRBqIg4gAkEQaikCADcDACAGQRBqQQhqIg8gAkEIaikCADcDACAGIAIpAgA3AxAgBkEQaiABQcAA\
QgAgChAYIAQgA2oiAUEYaiANKQMANwAAIAFBEGogDikDADcAACABQQhqIA8pAwA3AAAgASAGKQMQNw\
AAIAxBBGohDCALIANBIGoiA0cNAAsLAkACQAJAAkAgCUUNACAHQQV0IgIgBUsNASAFIAJrIgFBH00N\
AiAJQSBHDQMgBCACaiICIAAgCGoiASkAADcAACACQRhqIAFBGGopAAA3AAAgAkEQaiABQRBqKQAANw\
AAIAJBCGogAUEIaikAADcAACAHQQFqIQcLIAZBMGokACAHDwsgAiAFQcCEwAAQjAEAC0EgIAFBwITA\
ABCLAQALQSAgCUHQhMAAEGoAC/IDAgN/An4jAEHgAWsiAyQAIAApAwAhBiABIAEtAEAiBGoiBUGAAT\
oAACADQQhqIABBEGopAgA3AwAgAyAAKQIINwMAIAZCCYYhBiAErUIDhiEHAkAgBEE/cyIARQ0AIAVB\
AWpBACAAEJMBGgsgBiAHhCEGAkACQCAEQThxQThGDQAgASAGNwA4IAMgARAdDAELIAMgARAdIANB0A\
BqQQxqQgA3AgAgA0HQAGpBFGpCADcCACADQdAAakEcakIANwIAIANB0ABqQSRqQgA3AgAgA0HQAGpB\
LGpCADcCACADQdAAakE0akIANwIAIANBjAFqQgA3AgAgA0IANwJUIANBADYCUCADQdAAaiADQdAAak\
EEckF/c2pBxABqQQdJGiADQcAANgJQIANBmAFqIANB0ABqQcQAEJQBGiADQcAAaiADQZgBakE0aikC\
ADcDACADQThqIANBmAFqQSxqKQIANwMAIANBMGogA0GYAWpBJGopAgA3AwAgA0EoaiADQZgBakEcai\
kCADcDACADQSBqIANBmAFqQRRqKQIANwMAIANBGGogA0GYAWpBDGopAgA3AwAgAyADKQKcATcDECAD\
IAY3A0ggAyADQRBqEB0LIAFBADoAQCACIAMpAwA3AAAgAiADKQMINwAIIANB4AFqJAAL8gMCA38Cfi\
MAQeABayIDJAAgACkDACEGIAEgAS0AQCIEaiIFQYABOgAAIANBCGogAEEQaikCADcDACADIAApAgg3\
AwAgBkIJhiEGIAStQgOGIQcCQCAEQT9zIgBFDQAgBUEBakEAIAAQkwEaCyAGIAeEIQYCQAJAIARBOH\
FBOEYNACABIAY3ADggAyABEBsMAQsgAyABEBsgA0HQAGpBDGpCADcCACADQdAAakEUakIANwIAIANB\
0ABqQRxqQgA3AgAgA0HQAGpBJGpCADcCACADQdAAakEsakIANwIAIANB0ABqQTRqQgA3AgAgA0GMAW\
pCADcCACADQgA3AlQgA0EANgJQIANB0ABqIANB0ABqQQRyQX9zakHEAGpBB0kaIANBwAA2AlAgA0GY\
AWogA0HQAGpBxAAQlAEaIANBwABqIANBmAFqQTRqKQIANwMAIANBOGogA0GYAWpBLGopAgA3AwAgA0\
EwaiADQZgBakEkaikCADcDACADQShqIANBmAFqQRxqKQIANwMAIANBIGogA0GYAWpBFGopAgA3AwAg\
A0EYaiADQZgBakEMaikCADcDACADIAMpApwBNwMQIAMgBjcDSCADIANBEGoQGwsgAUEAOgBAIAIgAy\
kDADcAACACIAMpAwg3AAggA0HgAWokAAvnAwIEfwJ+IwBB0AFrIgMkACABIAEtAEAiBGoiBUEBOgAA\
IAApAwBCCYYhByAErUIDhiEIAkAgBEE/cyIGRQ0AIAVBAWpBACAGEJMBGgsgByAIhCEHAkACQCAEQT\
hxQThGDQAgASAHNwA4IABBCGogARAWDAELIABBCGoiBCABEBYgA0HAAGpBDGpCADcCACADQcAAakEU\
akIANwIAIANBwABqQRxqQgA3AgAgA0HAAGpBJGpCADcCACADQcAAakEsakIANwIAIANBwABqQTRqQg\
A3AgAgA0H8AGpCADcCACADQgA3AkQgA0EANgJAIANBwABqIANBwABqQQRyQX9zakHEAGpBB0kaIANB\
wAA2AkAgA0GIAWogA0HAAGpBxAAQlAEaIANBMGogA0GIAWpBNGopAgA3AwAgA0EoaiADQYgBakEsai\
kCADcDACADQSBqIANBiAFqQSRqKQIANwMAIANBGGogA0GIAWpBHGopAgA3AwAgA0EQaiADQYgBakEU\
aikCADcDACADQQhqIANBiAFqQQxqKQIANwMAIAMgAykCjAE3AwAgAyAHNwM4IAQgAxAWCyABQQA6AE\
AgAiAAKQMINwAAIAIgAEEQaikDADcACCACIABBGGopAwA3ABAgA0HQAWokAAuAAwEFfwJAAkACQCAB\
QQlJDQBBACECQc3/eyABQRAgAUEQSxsiAWsgAE0NASABQRAgAEELakF4cSAAQQtJGyIDakEMahAZIg\
BFDQEgAEF4aiECAkACQCABQX9qIgQgAHENACACIQEMAQsgAEF8aiIFKAIAIgZBeHEgBCAAakEAIAFr\
cUF4aiIAQQAgASAAIAJrQRBLG2oiASACayIAayEEAkAgBkEDcUUNACABIAEoAgRBAXEgBHJBAnI2Ag\
QgASAEaiIEIAQoAgRBAXI2AgQgBSAFKAIAQQFxIAByQQJyNgIAIAIgAGoiBCAEKAIEQQFyNgIEIAIg\
ABAkDAELIAIoAgAhAiABIAQ2AgQgASACIABqNgIACyABKAIEIgBBA3FFDQIgAEF4cSICIANBEGpNDQ\
IgASAAQQFxIANyQQJyNgIEIAEgA2oiACACIANrIgNBA3I2AgQgASACaiICIAIoAgRBAXI2AgQgACAD\
ECQMAgsgABAZIQILIAIPCyABQQhqC4sDAQJ/IwBBkAFrIgAkAAJAQfAAEBkiAUUNACAAQQxqQgA3Ag\
AgAEEUakIANwIAIABBHGpCADcCACAAQSRqQgA3AgAgAEEsakIANwIAIABBNGpCADcCACAAQTxqQgA3\
AgAgAEIANwIEIABBADYCACAAIABBBHJBf3NqQcQAakEHSRogAEHAADYCACAAQcgAaiAAQcQAEJQBGi\
ABQeAAaiAAQcgAakE8aikCADcAACABQdgAaiAAQcgAakE0aikCADcAACABQdAAaiAAQcgAakEsaikC\
ADcAACABQcgAaiAAQcgAakEkaikCADcAACABQcAAaiAAQcgAakEcaikCADcAACABQThqIABByABqQR\
RqKQIANwAAIAFBMGogAEHIAGpBDGopAgA3AAAgASAAKQJMNwAoIAFCADcDACABQegAakEAOgAAIAFB\
ACkDyI1ANwMIIAFBEGpBACkD0I1ANwMAIAFBGGpBACkD2I1ANwMAIAFBIGpBACkD4I1ANwMAIABBkA\
FqJAAgAQ8LAAuLAwECfyMAQZABayIAJAACQEHwABAZIgFFDQAgAEEMakIANwIAIABBFGpCADcCACAA\
QRxqQgA3AgAgAEEkakIANwIAIABBLGpCADcCACAAQTRqQgA3AgAgAEE8akIANwIAIABCADcCBCAAQQ\
A2AgAgACAAQQRyQX9zakHEAGpBB0kaIABBwAA2AgAgAEHIAGogAEHEABCUARogAUHgAGogAEHIAGpB\
PGopAgA3AAAgAUHYAGogAEHIAGpBNGopAgA3AAAgAUHQAGogAEHIAGpBLGopAgA3AAAgAUHIAGogAE\
HIAGpBJGopAgA3AAAgAUHAAGogAEHIAGpBHGopAgA3AAAgAUE4aiAAQcgAakEUaikCADcAACABQTBq\
IABByABqQQxqKQIANwAAIAEgACkCTDcAKCABQgA3AwAgAUHoAGpBADoAACABQQApA6iNQDcDCCABQR\
BqQQApA7CNQDcDACABQRhqQQApA7iNQDcDACABQSBqQQApA8CNQDcDACAAQZABaiQAIAEPCwAL+wIB\
An8jAEGQAWsiACQAAkBB6AAQGSIBRQ0AIABBDGpCADcCACAAQRRqQgA3AgAgAEEcakIANwIAIABBJG\
pCADcCACAAQSxqQgA3AgAgAEE0akIANwIAIABBPGpCADcCACAAQgA3AgQgAEEANgIAIAAgAEEEckF/\
c2pBxABqQQdJGiAAQcAANgIAIABByABqIABBxAAQlAEaIAFB2ABqIABByABqQTxqKQIANwAAIAFB0A\
BqIABByABqQTRqKQIANwAAIAFByABqIABByABqQSxqKQIANwAAIAFBwABqIABByABqQSRqKQIANwAA\
IAFBOGogAEHIAGpBHGopAgA3AAAgAUEwaiAAQcgAakEUaikCADcAACABQShqIABByABqQQxqKQIANw\
AAIAEgACkCTDcAICABQgA3AwAgAUHgAGpBADoAACABQQApA5CNQDcDCCABQRBqQQApA5iNQDcDACAB\
QRhqQQAoAqCNQDYCACAAQZABaiQAIAEPCwAL+wIBAn8jAEGQAWsiACQAAkBB6AAQGSIBRQ0AIAFCAD\
cDACABQQApA+DRQDcDCCABQRBqQQApA+jRQDcDACABQRhqQQApA/DRQDcDACAAQQxqQgA3AgAgAEEU\
akIANwIAIABBHGpCADcCACAAQSRqQgA3AgAgAEEsakIANwIAIABBNGpCADcCACAAQTxqQgA3AgAgAE\
IANwIEIABBADYCACAAIABBBHJBf3NqQcQAakEHSRogAEHAADYCACAAQcgAaiAAQcQAEJQBGiABQdgA\
aiAAQcgAakE8aikCADcAACABQdAAaiAAQcgAakE0aikCADcAACABQcgAaiAAQcgAakEsaikCADcAAC\
ABQcAAaiAAQcgAakEkaikCADcAACABQThqIABByABqQRxqKQIANwAAIAFBMGogAEHIAGpBFGopAgA3\
AAAgAUEoaiAAQcgAakEMaikCADcAACABIAApAkw3ACAgAUHgAGpBADoAACAAQZABaiQAIAEPCwALqQ\
MBAX8gAiACLQCoASIDakEAQagBIANrEJMBIQMgAkEAOgCoASADQR86AAAgAiACLQCnAUGAAXI6AKcB\
IAEgASkDACACKQAAhTcDACABIAEpAwggAikACIU3AwggASABKQMQIAIpABCFNwMQIAEgASkDGCACKQ\
AYhTcDGCABIAEpAyAgAikAIIU3AyAgASABKQMoIAIpACiFNwMoIAEgASkDMCACKQAwhTcDMCABIAEp\
AzggAikAOIU3AzggASABKQNAIAIpAECFNwNAIAEgASkDSCACKQBIhTcDSCABIAEpA1AgAikAUIU3A1\
AgASABKQNYIAIpAFiFNwNYIAEgASkDYCACKQBghTcDYCABIAEpA2ggAikAaIU3A2ggASABKQNwIAIp\
AHCFNwNwIAEgASkDeCACKQB4hTcDeCABIAEpA4ABIAIpAIABhTcDgAEgASABKQOIASACKQCIAYU3A4\
gBIAEgASkDkAEgAikAkAGFNwOQASABIAEpA5gBIAIpAJgBhTcDmAEgASABKQOgASACKQCgAYU3A6AB\
IAEQJSAAIAFByAEQlAEaC+8CAQN/AkACQAJAAkAgAC0AaCIDRQ0AAkAgA0HBAE8NACAAQShqIgQgA2\
ogAUHAACADayIDIAIgAyACSRsiAxCUARogACAALQBoIANqIgU6AGggASADaiEBAkAgAiADayICDQBB\
ACECDAMLIABBCGogBEHAACAAKQMAIAAtAGogAEHpAGoiAy0AAEVyEBggBEEAQcEAEJMBGiADIAMtAA\
BBAWo6AAAMAQsgA0HAAEGghMAAEIwBAAtBACEDIAJBwQBJDQEgAEEIaiEEIABB6QBqIgMtAAAhBQNA\
IAQgAUHAACAAKQMAIAAtAGogBUH/AXFFchAYIAMgAy0AAEEBaiIFOgAAIAFBwABqIQEgAkFAaiICQc\
AASw0ACyAALQBoIQULIAVB/wFxIgNBwQBPDQELIAAgA2pBKGogAUHAACADayIDIAIgAyACSRsiAhCU\
ARogACAALQBoIAJqOgBoIAAPCyADQcAAQaCEwAAQjAEAC50DAQJ/IwBBEGsiAyQAIAEgAS0AkAEiBG\
pBAEGQASAEaxCTASEEIAFBADoAkAEgBEEBOgAAIAEgAS0AjwFBgAFyOgCPASAAIAApAwAgASkAAIU3\
AwAgACAAKQMIIAEpAAiFNwMIIAAgACkDECABKQAQhTcDECAAIAApAxggASkAGIU3AxggACAAKQMgIA\
EpACCFNwMgIAAgACkDKCABKQAohTcDKCAAIAApAzAgASkAMIU3AzAgACAAKQM4IAEpADiFNwM4IAAg\
ACkDQCABKQBAhTcDQCAAIAApA0ggASkASIU3A0ggACAAKQNQIAEpAFCFNwNQIAAgACkDWCABKQBYhT\
cDWCAAIAApA2AgASkAYIU3A2AgACAAKQNoIAEpAGiFNwNoIAAgACkDcCABKQBwhTcDcCAAIAApA3gg\
ASkAeIU3A3ggACAAKQOAASABKQCAAYU3A4ABIAAgACkDiAEgASkAiAGFNwOIASAAECUgAiAAKQMANw\
AAIAIgACkDCDcACCACIAApAxA3ABAgAiAAKQMYPgAYIANBEGokAAudAwECfyMAQRBrIgMkACABIAEt\
AJABIgRqQQBBkAEgBGsQkwEhBCABQQA6AJABIARBBjoAACABIAEtAI8BQYABcjoAjwEgACAAKQMAIA\
EpAACFNwMAIAAgACkDCCABKQAIhTcDCCAAIAApAxAgASkAEIU3AxAgACAAKQMYIAEpABiFNwMYIAAg\
ACkDICABKQAghTcDICAAIAApAyggASkAKIU3AyggACAAKQMwIAEpADCFNwMwIAAgACkDOCABKQA4hT\
cDOCAAIAApA0AgASkAQIU3A0AgACAAKQNIIAEpAEiFNwNIIAAgACkDUCABKQBQhTcDUCAAIAApA1gg\
ASkAWIU3A1ggACAAKQNgIAEpAGCFNwNgIAAgACkDaCABKQBohTcDaCAAIAApA3AgASkAcIU3A3AgAC\
AAKQN4IAEpAHiFNwN4IAAgACkDgAEgASkAgAGFNwOAASAAIAApA4gBIAEpAIgBhTcDiAEgABAlIAIg\
ACkDADcAACACIAApAwg3AAggAiAAKQMQNwAQIAIgACkDGD4AGCADQRBqJAALlgMBBH8jAEGQBGsiAy\
QAAkAgAkUNACACQagBbCEEIANB4AJqQQRyIQUgA0GwAWogA0GwAWpBBHIiBkF/c2pBrAFqQQdJGgNA\
IAAoAgAhAiADQQA2ArABIAZBAEGoARCTARogA0GoATYCsAEgA0HgAmogA0GwAWpBrAEQlAEaIANBCG\
ogBUGoARCUARogAyACKQMANwMIIAMgAikDCDcDECADIAIpAxA3AxggAyACKQMYNwMgIAMgAikDIDcD\
KCADIAIpAyg3AzAgAyACKQMwNwM4IAMgAikDODcDQCADIAIpA0A3A0ggAyACKQNINwNQIAMgAikDUD\
cDWCADIAIpA1g3A2AgAyACKQNgNwNoIAMgAikDaDcDcCADIAIpA3A3A3ggAyACKQN4NwOAASADIAIp\
A4ABNwOIASADIAIpA4gBNwOQASADIAIpA5ABNwOYASADIAIpA5gBNwOgASADIAIpA6ABNwOoASACEC\
UgASADQQhqQagBEJQBGiABQagBaiEBIARB2H5qIgQNAAsLIANBkARqJAAL+gIBAn8jAEGQAWsiACQA\
AkBB6AAQGSIBRQ0AIABBDGpCADcCACAAQRRqQgA3AgAgAEEcakIANwIAIABBJGpCADcCACAAQSxqQg\
A3AgAgAEE0akIANwIAIABBPGpCADcCACAAQgA3AgQgAEEANgIAIAAgAEEEckF/c2pBxABqQQdJGiAA\
QcAANgIAIABByABqIABBxAAQlAEaIAFB2ABqIABByABqQTxqKQIANwAAIAFB0ABqIABByABqQTRqKQ\
IANwAAIAFByABqIABByABqQSxqKQIANwAAIAFBwABqIABByABqQSRqKQIANwAAIAFBOGogAEHIAGpB\
HGopAgA3AAAgAUEwaiAAQcgAakEUaikCADcAACABQShqIABByABqQQxqKQIANwAAIAEgACkCTDcAIC\
ABQfDDy558NgIYIAFC/rnrxemOlZkQNwMQIAFCgcaUupbx6uZvNwMIIAFCADcDACABQeAAakEAOgAA\
IABBkAFqJAAgAQ8LAAvkAgEEfyMAQZAEayIDJAAgAyAANgIEIABByAFqIQQCQAJAAkACQAJAIABB8A\
JqLQAAIgVFDQBBqAEgBWsiBiACSw0BIAEgBCAFaiAGEJQBIAZqIQEgAiAGayECCyACIAJBqAFuIgZB\
qAFsIgVJDQEgA0EEaiABIAYQOgJAIAIgBWsiAg0AQQAhAgwECyADQQA2ArABIANBsAFqIANBsAFqQQ\
RyQQBBqAEQkwFBf3NqQawBakEHSRogA0GoATYCsAEgA0HgAmogA0GwAWpBrAEQlAEaIANBCGogA0Hg\
AmpBBHJBqAEQlAEaIANBBGogA0EIakEBEDogAkGpAU8NAiABIAVqIANBCGogAhCUARogBCADQQhqQa\
gBEJQBGgwDCyABIAQgBWogAhCUARogBSACaiECDAILQeiMwABBI0HIjMAAEHIACyACQagBQdiMwAAQ\
iwEACyAAIAI6APACIANBkARqJAAL5AIBBH8jAEGwA2siAyQAIAMgADYCBCAAQcgBaiEEAkACQAJAAk\
ACQCAAQdACai0AACIFRQ0AQYgBIAVrIgYgAksNASABIAQgBWogBhCUASAGaiEBIAIgBmshAgsgAiAC\
QYgBbiIGQYgBbCIFSQ0BIANBBGogASAGEEMCQCACIAVrIgINAEEAIQIMBAsgA0EANgKQASADQZABai\
ADQZABakEEckEAQYgBEJMBQX9zakGMAWpBB0kaIANBiAE2ApABIANBoAJqIANBkAFqQYwBEJQBGiAD\
QQhqIANBoAJqQQRyQYgBEJQBGiADQQRqIANBCGpBARBDIAJBiQFPDQIgASAFaiADQQhqIAIQlAEaIA\
QgA0EIakGIARCUARoMAwsgASAEIAVqIAIQlAEaIAUgAmohAgwCC0HojMAAQSNByIzAABByAAsgAkGI\
AUHYjMAAEIsBAAsgACACOgDQAiADQbADaiQAC5EDAQF/AkAgAkUNACABIAJBqAFsaiEDIAAoAgAhAg\
NAIAIgAikDACABKQAAhTcDACACIAIpAwggASkACIU3AwggAiACKQMQIAEpABCFNwMQIAIgAikDGCAB\
KQAYhTcDGCACIAIpAyAgASkAIIU3AyAgAiACKQMoIAEpACiFNwMoIAIgAikDMCABKQAwhTcDMCACIA\
IpAzggASkAOIU3AzggAiACKQNAIAEpAECFNwNAIAIgAikDSCABKQBIhTcDSCACIAIpA1AgASkAUIU3\
A1AgAiACKQNYIAEpAFiFNwNYIAIgAikDYCABKQBghTcDYCACIAIpA2ggASkAaIU3A2ggAiACKQNwIA\
EpAHCFNwNwIAIgAikDeCABKQB4hTcDeCACIAIpA4ABIAEpAIABhTcDgAEgAiACKQOIASABKQCIAYU3\
A4gBIAIgAikDkAEgASkAkAGFNwOQASACIAIpA5gBIAEpAJgBhTcDmAEgAiACKQOgASABKQCgAYU3A6\
ABIAIQJSABQagBaiIBIANHDQALCwvuAgECfyMAQZABayIAJAACQEHgABAZIgFFDQAgAEEMakIANwIA\
IABBFGpCADcCACAAQRxqQgA3AgAgAEEkakIANwIAIABBLGpCADcCACAAQTRqQgA3AgAgAEE8akIANw\
IAIABCADcCBCAAQQA2AgAgACAAQQRyQX9zakHEAGpBB0kaIABBwAA2AgAgAEHIAGogAEHEABCUARog\
AUHQAGogAEHIAGpBPGopAgA3AAAgAUHIAGogAEHIAGpBNGopAgA3AAAgAUHAAGogAEHIAGpBLGopAg\
A3AAAgAUE4aiAAQcgAakEkaikCADcAACABQTBqIABByABqQRxqKQIANwAAIAFBKGogAEHIAGpBFGop\
AgA3AAAgAUEgaiAAQcgAakEMaikCADcAACABIAApAkw3ABggAUL+uevF6Y6VmRA3AxAgAUKBxpS6lv\
Hq5m83AwggAUIANwMAIAFB2ABqQQA6AAAgAEGQAWokACABDwsAC7wCAQh/AkACQCACQQ9LDQAgACED\
DAELIABBACAAa0EDcSIEaiEFAkAgBEUNACAAIQMgASEGA0AgAyAGLQAAOgAAIAZBAWohBiADQQFqIg\
MgBUkNAAsLIAUgAiAEayIHQXxxIghqIQMCQAJAIAEgBGoiCUEDcSIGRQ0AIAhBAUgNASAJQXxxIgpB\
BGohAUEAIAZBA3QiAmtBGHEhBCAKKAIAIQYDQCAFIAYgAnYgASgCACIGIAR0cjYCACABQQRqIQEgBU\
EEaiIFIANJDQAMAgsLIAhBAUgNACAJIQEDQCAFIAEoAgA2AgAgAUEEaiEBIAVBBGoiBSADSQ0ACwsg\
B0EDcSECIAkgCGohAQsCQCACRQ0AIAMgAmohBQNAIAMgAS0AADoAACABQQFqIQEgA0EBaiIDIAVJDQ\
ALCyAAC/oCAQF/IAEgAS0AiAEiA2pBAEGIASADaxCTASEDIAFBADoAiAEgA0EBOgAAIAEgAS0AhwFB\
gAFyOgCHASAAIAApAwAgASkAAIU3AwAgACAAKQMIIAEpAAiFNwMIIAAgACkDECABKQAQhTcDECAAIA\
ApAxggASkAGIU3AxggACAAKQMgIAEpACCFNwMgIAAgACkDKCABKQAohTcDKCAAIAApAzAgASkAMIU3\
AzAgACAAKQM4IAEpADiFNwM4IAAgACkDQCABKQBAhTcDQCAAIAApA0ggASkASIU3A0ggACAAKQNQIA\
EpAFCFNwNQIAAgACkDWCABKQBYhTcDWCAAIAApA2AgASkAYIU3A2AgACAAKQNoIAEpAGiFNwNoIAAg\
ACkDcCABKQBwhTcDcCAAIAApA3ggASkAeIU3A3ggACAAKQOAASABKQCAAYU3A4ABIAAQJSACIAApAw\
A3AAAgAiAAKQMINwAIIAIgACkDEDcAECACIAApAxg3ABgL+gIBAX8gASABLQCIASIDakEAQYgBIANr\
EJMBIQMgAUEAOgCIASADQQY6AAAgASABLQCHAUGAAXI6AIcBIAAgACkDACABKQAAhTcDACAAIAApAw\
ggASkACIU3AwggACAAKQMQIAEpABCFNwMQIAAgACkDGCABKQAYhTcDGCAAIAApAyAgASkAIIU3AyAg\
ACAAKQMoIAEpACiFNwMoIAAgACkDMCABKQAwhTcDMCAAIAApAzggASkAOIU3AzggACAAKQNAIAEpAE\
CFNwNAIAAgACkDSCABKQBIhTcDSCAAIAApA1AgASkAUIU3A1AgACAAKQNYIAEpAFiFNwNYIAAgACkD\
YCABKQBghTcDYCAAIAApA2ggASkAaIU3A2ggACAAKQNwIAEpAHCFNwNwIAAgACkDeCABKQB4hTcDeC\
AAIAApA4ABIAEpAIABhTcDgAEgABAlIAIgACkDADcAACACIAApAwg3AAggAiAAKQMQNwAQIAIgACkD\
GDcAGAvmAgEEfyMAQbADayIDJAACQCACRQ0AIAJBiAFsIQQgA0GgAmpBBHIhBSADQZABaiADQZABak\
EEciIGQX9zakGMAWpBB0kaA0AgACgCACECIANBADYCkAEgBkEAQYgBEJMBGiADQYgBNgKQASADQaAC\
aiADQZABakGMARCUARogA0EIaiAFQYgBEJQBGiADIAIpAwA3AwggAyACKQMINwMQIAMgAikDEDcDGC\
ADIAIpAxg3AyAgAyACKQMgNwMoIAMgAikDKDcDMCADIAIpAzA3AzggAyACKQM4NwNAIAMgAikDQDcD\
SCADIAIpA0g3A1AgAyACKQNQNwNYIAMgAikDWDcDYCADIAIpA2A3A2ggAyACKQNoNwNwIAMgAikDcD\
cDeCADIAIpA3g3A4ABIAMgAikDgAE3A4gBIAIQJSABIANBCGpBiAEQlAEaIAFBiAFqIQEgBEH4fmoi\
BA0ACwsgA0GwA2okAAvYAgEBfwJAIAJFDQAgASACQZABbGohAyAAKAIAIQIDQCACIAIpAwAgASkAAI\
U3AwAgAiACKQMIIAEpAAiFNwMIIAIgAikDECABKQAQhTcDECACIAIpAxggASkAGIU3AxggAiACKQMg\
IAEpACCFNwMgIAIgAikDKCABKQAohTcDKCACIAIpAzAgASkAMIU3AzAgAiACKQM4IAEpADiFNwM4IA\
IgAikDQCABKQBAhTcDQCACIAIpA0ggASkASIU3A0ggAiACKQNQIAEpAFCFNwNQIAIgAikDWCABKQBY\
hTcDWCACIAIpA2AgASkAYIU3A2AgAiACKQNoIAEpAGiFNwNoIAIgAikDcCABKQBwhTcDcCACIAIpA3\
ggASkAeIU3A3ggAiACKQOAASABKQCAAYU3A4ABIAIgAikDiAEgASkAiAGFNwOIASACECUgAUGQAWoi\
ASADRw0ACwsL3QIBAX8gAiACLQCIASIDakEAQYgBIANrEJMBIQMgAkEAOgCIASADQR86AAAgAiACLQ\
CHAUGAAXI6AIcBIAEgASkDACACKQAAhTcDACABIAEpAwggAikACIU3AwggASABKQMQIAIpABCFNwMQ\
IAEgASkDGCACKQAYhTcDGCABIAEpAyAgAikAIIU3AyAgASABKQMoIAIpACiFNwMoIAEgASkDMCACKQ\
AwhTcDMCABIAEpAzggAikAOIU3AzggASABKQNAIAIpAECFNwNAIAEgASkDSCACKQBIhTcDSCABIAEp\
A1AgAikAUIU3A1AgASABKQNYIAIpAFiFNwNYIAEgASkDYCACKQBghTcDYCABIAEpA2ggAikAaIU3A2\
ggASABKQNwIAIpAHCFNwNwIAEgASkDeCACKQB4hTcDeCABIAEpA4ABIAIpAIABhTcDgAEgARAlIAAg\
AUHIARCUARoLswIBBH9BHyECAkAgAUH///8HSw0AIAFBBiABQQh2ZyICa3ZBAXEgAkEBdGtBPmohAg\
sgAEIANwIQIAAgAjYCHCACQQJ0QfzUwABqIQMCQAJAAkACQAJAQQAoAvDSQCIEQQEgAnQiBXFFDQAg\
AygCACIEKAIEQXhxIAFHDQEgBCECDAILQQAgBCAFcjYC8NJAIAMgADYCACAAIAM2AhgMAwsgAUEAQR\
kgAkEBdmtBH3EgAkEfRht0IQMDQCAEIANBHXZBBHFqQRBqIgUoAgAiAkUNAiADQQF0IQMgAiEEIAIo\
AgRBeHEgAUcNAAsLIAIoAggiAyAANgIMIAIgADYCCCAAQQA2AhggACACNgIMIAAgAzYCCA8LIAUgAD\
YCACAAIAQ2AhgLIAAgADYCDCAAIAA2AggLugIBBX8gACgCGCEBAkACQAJAIAAoAgwiAiAARw0AIABB\
FEEQIABBFGoiAigCACIDG2ooAgAiBA0BQQAhAgwCCyAAKAIIIgQgAjYCDCACIAQ2AggMAQsgAiAAQR\
BqIAMbIQMDQCADIQUCQCAEIgJBFGoiAygCACIEDQAgAkEQaiEDIAIoAhAhBAsgBA0ACyAFQQA2AgAL\
AkAgAUUNAAJAAkAgACgCHEECdEH81MAAaiIEKAIAIABGDQAgAUEQQRQgASgCECAARhtqIAI2AgAgAg\
0BDAILIAQgAjYCACACDQBBAEEAKALw0kBBfiAAKAIcd3E2AvDSQA8LIAIgATYCGAJAIAAoAhAiBEUN\
ACACIAQ2AhAgBCACNgIYCyAAQRRqKAIAIgRFDQAgAkEUaiAENgIAIAQgAjYCGA8LC8UCAQF/AkAgAk\
UNACABIAJBiAFsaiEDIAAoAgAhAgNAIAIgAikDACABKQAAhTcDACACIAIpAwggASkACIU3AwggAiAC\
KQMQIAEpABCFNwMQIAIgAikDGCABKQAYhTcDGCACIAIpAyAgASkAIIU3AyAgAiACKQMoIAEpACiFNw\
MoIAIgAikDMCABKQAwhTcDMCACIAIpAzggASkAOIU3AzggAiACKQNAIAEpAECFNwNAIAIgAikDSCAB\
KQBIhTcDSCACIAIpA1AgASkAUIU3A1AgAiACKQNYIAEpAFiFNwNYIAIgAikDYCABKQBghTcDYCACIA\
IpA2ggASkAaIU3A2ggAiACKQNwIAEpAHCFNwNwIAIgAikDeCABKQB4hTcDeCACIAIpA4ABIAEpAIAB\
hTcDgAEgAhAlIAFBiAFqIgEgA0cNAAsLC8cCAQF/IAEgAS0AaCIDakEAQegAIANrEJMBIQMgAUEAOg\
BoIANBAToAACABIAEtAGdBgAFyOgBnIAAgACkDACABKQAAhTcDACAAIAApAwggASkACIU3AwggACAA\
KQMQIAEpABCFNwMQIAAgACkDGCABKQAYhTcDGCAAIAApAyAgASkAIIU3AyAgACAAKQMoIAEpACiFNw\
MoIAAgACkDMCABKQAwhTcDMCAAIAApAzggASkAOIU3AzggACAAKQNAIAEpAECFNwNAIAAgACkDSCAB\
KQBIhTcDSCAAIAApA1AgASkAUIU3A1AgACAAKQNYIAEpAFiFNwNYIAAgACkDYCABKQBghTcDYCAAEC\
UgAiAAKQMANwAAIAIgACkDCDcACCACIAApAxA3ABAgAiAAKQMYNwAYIAIgACkDIDcAICACIAApAyg3\
ACgLxwIBAX8gASABLQBoIgNqQQBB6AAgA2sQkwEhAyABQQA6AGggA0EGOgAAIAEgAS0AZ0GAAXI6AG\
cgACAAKQMAIAEpAACFNwMAIAAgACkDCCABKQAIhTcDCCAAIAApAxAgASkAEIU3AxAgACAAKQMYIAEp\
ABiFNwMYIAAgACkDICABKQAghTcDICAAIAApAyggASkAKIU3AyggACAAKQMwIAEpADCFNwMwIAAgAC\
kDOCABKQA4hTcDOCAAIAApA0AgASkAQIU3A0AgACAAKQNIIAEpAEiFNwNIIAAgACkDUCABKQBQhTcD\
UCAAIAApA1ggASkAWIU3A1ggACAAKQNgIAEpAGCFNwNgIAAQJSACIAApAwA3AAAgAiAAKQMINwAIIA\
IgACkDEDcAECACIAApAxg3ABggAiAAKQMgNwAgIAIgACkDKDcAKAubAgEBfyABIAEtAEgiA2pBAEHI\
ACADaxCTASEDIAFBADoASCADQQE6AAAgASABLQBHQYABcjoARyAAIAApAwAgASkAAIU3AwAgACAAKQ\
MIIAEpAAiFNwMIIAAgACkDECABKQAQhTcDECAAIAApAxggASkAGIU3AxggACAAKQMgIAEpACCFNwMg\
IAAgACkDKCABKQAohTcDKCAAIAApAzAgASkAMIU3AzAgACAAKQM4IAEpADiFNwM4IAAgACkDQCABKQ\
BAhTcDQCAAECUgAiAAKQMANwAAIAIgACkDCDcACCACIAApAxA3ABAgAiAAKQMYNwAYIAIgACkDIDcA\
ICACIAApAyg3ACggAiAAKQMwNwAwIAIgACkDODcAOAubAgEBfyABIAEtAEgiA2pBAEHIACADaxCTAS\
EDIAFBADoASCADQQY6AAAgASABLQBHQYABcjoARyAAIAApAwAgASkAAIU3AwAgACAAKQMIIAEpAAiF\
NwMIIAAgACkDECABKQAQhTcDECAAIAApAxggASkAGIU3AxggACAAKQMgIAEpACCFNwMgIAAgACkDKC\
ABKQAohTcDKCAAIAApAzAgASkAMIU3AzAgACAAKQM4IAEpADiFNwM4IAAgACkDQCABKQBAhTcDQCAA\
ECUgAiAAKQMANwAAIAIgACkDCDcACCACIAApAxA3ABAgAiAAKQMYNwAYIAIgACkDIDcAICACIAApAy\
g3ACggAiAAKQMwNwAwIAIgACkDODcAOAuIAgECfyMAQZACayIAJAACQEHYARAZIgFFDQAgAEEANgIA\
IAAgAEEEckEAQYABEJMBQX9zakGEAWpBB0kaIABBgAE2AgAgAEGIAWogAEGEARCUARogAUHQAGogAE\
GIAWpBBHJBgAEQlAEaIAFByABqQgA3AwAgAUIANwNAIAFB0AFqQQA6AAAgAUEAKQPojUA3AwAgAUEI\
akEAKQPwjUA3AwAgAUEQakEAKQP4jUA3AwAgAUEYakEAKQOAjkA3AwAgAUEgakEAKQOIjkA3AwAgAU\
EoakEAKQOQjkA3AwAgAUEwakEAKQOYjkA3AwAgAUE4akEAKQOgjkA3AwAgAEGQAmokACABDwsAC4gC\
AQJ/IwBBkAJrIgAkAAJAQdgBEBkiAUUNACAAQQA2AgAgACAAQQRyQQBBgAEQkwFBf3NqQYQBakEHSR\
ogAEGAATYCACAAQYgBaiAAQYQBEJQBGiABQdAAaiAAQYgBakEEckGAARCUARogAUHIAGpCADcDACAB\
QgA3A0AgAUHQAWpBADoAACABQQApA6iOQDcDACABQQhqQQApA7COQDcDACABQRBqQQApA7iOQDcDAC\
ABQRhqQQApA8COQDcDACABQSBqQQApA8iOQDcDACABQShqQQApA9COQDcDACABQTBqQQApA9iOQDcD\
ACABQThqQQApA+COQDcDACAAQZACaiQAIAEPCwALggIBAX8CQCACRQ0AIAEgAkHoAGxqIQMgACgCAC\
ECA0AgAiACKQMAIAEpAACFNwMAIAIgAikDCCABKQAIhTcDCCACIAIpAxAgASkAEIU3AxAgAiACKQMY\
IAEpABiFNwMYIAIgAikDICABKQAghTcDICACIAIpAyggASkAKIU3AyggAiACKQMwIAEpADCFNwMwIA\
IgAikDOCABKQA4hTcDOCACIAIpA0AgASkAQIU3A0AgAiACKQNIIAEpAEiFNwNIIAIgAikDUCABKQBQ\
hTcDUCACIAIpA1ggASkAWIU3A1ggAiACKQNgIAEpAGCFNwNgIAIQJSABQegAaiIBIANHDQALCwvnAQ\
EHfyMAQRBrIgMkACACEAIhBCACEAMhBSACEAQhBgJAAkAgBEGBgARJDQBBACEHIAQhCANAIAMgBiAF\
IAdqIAhBgIAEIAhBgIAESRsQBSIJEF0CQCAJQSRJDQAgCRABCyAAIAEgAygCACIJIAMoAggQESAHQY\
CABGohBwJAIAMoAgRFDQAgCRAiCyAIQYCAfGohCCAEIAdLDQAMAgsLIAMgAhBdIAAgASADKAIAIgcg\
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\
AiQAQQAhAyACQQA2AgADQCACIANqQQRqIAEgA2ooAAA2AgAgAiADQQRqIgM2AgAgA0GAAUcNAAsgAk\
GIAWogAkGEARCUARogACACQYgBakEEckGAARCUASABLQCAAToAgAEgAkGQAmokAAt1AQJ/IwBBsAJr\
IgIkAEEAIQMgAkEANgIAA0AgAiADakEEaiABIANqKAAANgIAIAIgA0EEaiIDNgIAIANBkAFHDQALIA\
JBmAFqIAJBlAEQlAEaIAAgAkGYAWpBBHJBkAEQlAEgAS0AkAE6AJABIAJBsAJqJAALdQECfyMAQaAC\
ayICJABBACEDIAJBADYCAANAIAIgA2pBBGogASADaigAADYCACACIANBBGoiAzYCACADQYgBRw0ACy\
ACQZABaiACQYwBEJQBGiAAIAJBkAFqQQRyQYgBEJQBIAEtAIgBOgCIASACQaACaiQAC3MBAn8jAEHg\
AWsiAiQAQQAhAyACQQA2AgADQCACIANqQQRqIAEgA2ooAAA2AgAgAiADQQRqIgM2AgAgA0HoAEcNAA\
sgAkHwAGogAkHsABCUARogACACQfAAakEEckHoABCUASABLQBoOgBoIAJB4AFqJAALcwECfyMAQaAB\
ayICJABBACEDIAJBADYCAANAIAIgA2pBBGogASADaigAADYCACACIANBBGoiAzYCACADQcgARw0ACy\
ACQdAAaiACQcwAEJQBGiAAIAJB0ABqQQRyQcgAEJQBIAEtAEg6AEggAkGgAWokAAt1AQJ/IwBB4AJr\
IgIkAEEAIQMgAkEANgIAA0AgAiADakEEaiABIANqKAAANgIAIAIgA0EEaiIDNgIAIANBqAFHDQALIA\
JBsAFqIAJBrAEQlAEaIAAgAkGwAWpBBHJBqAEQlAEgAS0AqAE6AKgBIAJB4AJqJAALewECfyMAQTBr\
IgIkACACQRRqQQI2AgAgAkH0h8AANgIQIAJBAjYCDCACQdSHwAA2AgggAUEcaigCACEDIAEoAhghAS\
ACQQI2AiwgAkICNwIcIAJB1IjAADYCGCACIAJBCGo2AiggASADIAJBGGoQKyEBIAJBMGokACABC3sB\
An8jAEEwayICJAAgAkEUakECNgIAIAJB9IfAADYCECACQQI2AgwgAkHUh8AANgIIIAFBHGooAgAhAy\
ABKAIYIQEgAkECNgIsIAJCAjcCHCACQdSIwAA2AhggAiACQQhqNgIoIAEgAyACQRhqECshASACQTBq\
JAAgAQtsAQF/IwBBMGsiAyQAIAMgATYCBCADIAA2AgAgA0EcakECNgIAIANBLGpBAzYCACADQgM3Ag\
wgA0HQi8AANgIIIANBAzYCJCADIANBIGo2AhggAyADNgIoIAMgA0EEajYCICADQQhqIAIQdwALbAEB\
fyMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBHGpBAjYCACADQSxqQQM2AgAgA0ICNwIMIANBsIjAAD\
YCCCADQQM2AiQgAyADQSBqNgIYIAMgAzYCKCADIANBBGo2AiAgA0EIaiACEHcAC2wBAX8jAEEwayID\
JAAgAyABNgIEIAMgADYCACADQRxqQQI2AgAgA0EsakEDNgIAIANCAjcCDCADQeCKwAA2AgggA0EDNg\
IkIAMgA0EgajYCGCADIANBBGo2AiggAyADNgIgIANBCGogAhB3AAtsAQF/IwBBMGsiAyQAIAMgATYC\
BCADIAA2AgAgA0EcakECNgIAIANBLGpBAzYCACADQgI3AgwgA0GAi8AANgIIIANBAzYCJCADIANBIG\
o2AhggAyADQQRqNgIoIAMgAzYCICADQQhqIAIQdwALVwECfwJAAkAgAEUNACAAKAIADQEgAEEANgIA\
IAAoAgghASAAKAIEIQIgABAiAkAgAkEERw0AIAEoApABRQ0AIAFBADYCkAELIAEQIg8LEJABAAsQkQ\
EAC1gBAn9BAEEAKALo0kAiAUEBajYC6NJAQQBBACgCsNZAQQFqIgI2ArDWQAJAIAFBAEgNACACQQJL\
DQBBACgC5NJAQX9MDQAgAkEBSw0AIABFDQAQlwEACwALSgEDf0EAIQMCQCACRQ0AAkADQCAALQAAIg\
QgAS0AACIFRw0BIABBAWohACABQQFqIQEgAkF/aiICRQ0CDAALCyAEIAVrIQMLIAMLRgACQAJAIAFF\
DQAgASgCAA0BIAFBfzYCACABQQRqKAIAIAFBCGooAgAgAhBQIAFBADYCACAAQgA3AwAPCxCQAQALEJ\
EBAAtHAQF/IwBBIGsiAyQAIANBFGpBADYCACADQdiQwAA2AhAgA0IBNwIEIAMgATYCHCADIAA2Ahgg\
AyADQRhqNgIAIAMgAhB3AAuLAQAgAEIANwNAIABC+cL4m5Gjs/DbADcDOCAAQuv6htq/tfbBHzcDMC\
AAQp/Y+dnCkdqCm383AyggAELRhZrv+s+Uh9EANwMgIABC8e30+KWn/aelfzcDGCAAQqvw0/Sv7ry3\
PDcDECAAQrvOqqbY0Ouzu383AwggACABrUKIkveV/8z5hOoAhTcDAAtFAQJ/IwBBEGsiASQAAkAgAC\
gCCCICDQBB2JDAAEErQaCRwAAQcgALIAEgACgCDDYCCCABIAA2AgQgASACNgIAIAEQewALQgEBfwJA\
AkACQCACQYCAxABGDQBBASEEIAAgAiABKAIQEQYADQELIAMNAUEAIQQLIAQPCyAAIANBACABKAIMEQ\
gACz8BAX8jAEEgayIAJAAgAEEcakEANgIAIABB2JDAADYCGCAAQgE3AgwgAEGUgsAANgIIIABBCGpB\
nILAABB3AAs+AQF/IwBBIGsiAiQAIAJBAToAGCACIAE2AhQgAiAANgIQIAJBwIjAADYCDCACQdiQwA\
A2AgggAkEIahB0AAs9AQJ/IAAoAgAiAUEUaigCACECAkACQCABKAIEDgIAAAELIAINACAAKAIELQAQ\
EG8ACyAAKAIELQAQEG8ACzMAAkAgAEH8////B0sNAAJAIAANAEEEDwsgACAAQf3///8HSUECdBAxIg\
BFDQAgAA8LAAtSACAAQsfMo9jW0Ouzu383AwggAEIANwMAIABBIGpCq7OP/JGjs/DbADcDACAAQRhq\
Qv+kuYjFkdqCm383AwAgAEEQakLy5rvjo6f9p6V/NwMACywBAX8jAEEQayIBJAAgAUEIaiAAQQhqKA\
IANgIAIAEgACkCADcDACABEHgACyYAAkAgAA0AQeiOwABBMBCSAQALIAAgAiADIAQgBSABKAIQEQwA\
CyQAAkAgAA0AQeiOwABBMBCSAQALIAAgAiADIAQgASgCEBEKAAskAAJAIAANAEHojsAAQTAQkgEACy\
AAIAIgAyAEIAEoAhARCQALJAACQCAADQBB6I7AAEEwEJIBAAsgACACIAMgBCABKAIQEQoACyQAAkAg\
AA0AQeiOwABBMBCSAQALIAAgAiADIAQgASgCEBEJAAskAAJAIAANAEHojsAAQTAQkgEACyAAIAIgAy\
AEIAEoAhARCQALJAACQCAADQBB6I7AAEEwEJIBAAsgACACIAMgBCABKAIQERcACyQAAkAgAA0AQeiO\
wABBMBCSAQALIAAgAiADIAQgASgCEBEYAAskAAJAIAANAEHojsAAQTAQkgEACyAAIAIgAyAEIAEoAh\
ARFgALIgACQCAADQBB6I7AAEEwEJIBAAsgACACIAMgASgCEBEHAAsgAAJAAkAgAUH8////B0sNACAA\
IAIQJiIBDQELAAsgAQsgAAJAIAANAEHojsAAQTAQkgEACyAAIAIgASgCEBEGAAsUACAAKAIAIAEgAC\
gCBCgCDBEGAAsQACABIAAoAgAgACgCBBAcCw4AAkAgAUUNACAAECILCwsAIAAgASACEG0ACwsAIAAg\
ASACEGwACxEAQayCwABBL0G4g8AAEHIACw0AIAAoAgAaA38MAAsLCwAgACMAaiQAIwALDQBB+NHAAE\
EbEJIBAAsOAEGT0sAAQc8AEJIBAAsJACAAIAEQCwALCgAgACABIAIQUwsKACAAIAEgAhBACwoAIAAg\
ASACEHALDABCuInPl4nG0fhMCwMAAAsCAAsL7NKAgAABAEGAgMAAC+JS6AUQAF0AAACVAAAACQAAAE\
JMQUtFMkJCTEFLRTJCLTI1NkJMQUtFMkItMzg0QkxBS0UyU0JMQUtFM0tFQ0NBSy0yMjRLRUNDQUst\
MjU2S0VDQ0FLLTM4NEtFQ0NBSy01MTJNRDRNRDVSSVBFTUQtMTYwU0hBLTFTSEEtMjI0U0hBLTI1Nl\
NIQS0zODRTSEEtNTEyVElHRVJ1bnN1cHBvcnRlZCBhbGdvcml0aG1ub24tZGVmYXVsdCBsZW5ndGgg\
c3BlY2lmaWVkIGZvciBub24tZXh0ZW5kYWJsZSBhbGdvcml0aG1saWJyYXJ5L2FsbG9jL3NyYy9yYX\
dfdmVjLnJzY2FwYWNpdHkgb3ZlcmZsb3cAAgEQABEAAADmABAAHAAAAAYCAAAFAAAAQXJyYXlWZWM6\
IGNhcGFjaXR5IGV4Y2VlZGVkIGluIGV4dGVuZC9mcm9tX2l0ZXJDOlxVc2Vyc1xheWFtZVwuY2FyZ2\
9ccmVnaXN0cnlcc3JjXGdpdGh1Yi5jb20tMWVjYzYyOTlkYjllYzgyM1xhcnJheXZlYy0wLjcuMlxz\
cmNcYXJyYXl2ZWMucnNbARAAXQAAAAEEAAAFAAAAQzpcVXNlcnNcYXlhbWVcLmNhcmdvXHJlZ2lzdH\
J5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNcYmxha2UzLTEuMy4xXHNyY1xsaWIucnMA\
AMgBEABWAAAAuQEAAAkAAADIARAAVgAAAF8CAAAKAAAAyAEQAFYAAACNAgAACQAAAMgBEABWAAAAjQ\
IAADQAAADIARAAVgAAALkCAAAfAAAAyAEQAFYAAADdAgAACgAAAMgBEABWAAAA1gIAAAkAAADIARAA\
VgAAAAEDAAAZAAAAyAEQAFYAAAADAwAACQAAAMgBEABWAAAAAwMAADgAAADIARAAVgAAAPgDAAAeAA\
AAyAEQAFYAAACqBAAAFgAAAMgBEABWAAAAvAQAABYAAADIARAAVgAAAO0EAAASAAAAyAEQAFYAAAD3\
BAAAEgAAAMgBEABWAAAAaQUAACEAAAARAAAABAAAAAQAAAASAAAAQzpcVXNlcnNcYXlhbWVcLmNhcm\
dvXHJlZ2lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNcYXJyYXl2ZWMtMC43LjJc\
c3JjXGFycmF5dmVjX2ltcGwucnMAADADEABiAAAAJwAAAAkAAAARAAAAIAAAAAEAAAATAAAAEQAAAA\
QAAAAEAAAAEgAAAENhcGFjaXR5RXJyb3IAAADEAxAADQAAAGluc3VmZmljaWVudCBjYXBhY2l0eQAA\
ANwDEAAVAAAAKWluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaX\
MgAP0DEAAgAAAAHQQQABIAAAARAAAAAAAAAAEAAAAUAAAAOiAAAFgIEAAAAAAAUAQQAAIAAAAwMDAx\
MDIwMzA0MDUwNjA3MDgwOTEwMTExMjEzMTQxNTE2MTcxODE5MjAyMTIyMjMyNDI1MjYyNzI4MjkzMD\
MxMzIzMzM0MzUzNjM3MzgzOTQwNDE0MjQzNDQ0NTQ2NDc0ODQ5NTA1MTUyNTM1NDU1NTY1NzU4NTk2\
MDYxNjI2MzY0NjU2NjY3Njg2OTcwNzE3MjczNzQ3NTc2Nzc3ODc5ODA4MTgyODM4NDg1ODY4Nzg4OD\
k5MDkxOTI5Mzk0OTU5Njk3OTg5OXJhbmdlIHN0YXJ0IGluZGV4ICBvdXQgb2YgcmFuZ2UgZm9yIHNs\
aWNlIG9mIGxlbmd0aCAsBRAAEgAAAD4FEAAiAAAAcmFuZ2UgZW5kIGluZGV4IHAFEAAQAAAAPgUQAC\
IAAABzb3VyY2Ugc2xpY2UgbGVuZ3RoICgpIGRvZXMgbm90IG1hdGNoIGRlc3RpbmF0aW9uIHNsaWNl\
IGxlbmd0aCAokAUQABUAAAClBRAAKwAAAPwDEAABAAAAQzpcVXNlcnNcYXlhbWVcLmNhcmdvXHJlZ2\
lzdHJ5XHNyY1xnaXRodWIuY29tLTFlY2M2Mjk5ZGI5ZWM4MjNcYmxvY2stYnVmZmVyLTAuMTAuMFxz\
cmNcbGliLnJzAAAA6AUQAF0AAAA/AQAAHgAAAOgFEABdAAAA/AAAACcAAABhc3NlcnRpb24gZmFpbG\
VkOiBtaWQgPD0gc2VsZi5sZW4oKQAAAAAAASNFZ4mrze/+3LqYdlQyEPDh0sMAAAAAZ+YJaoWuZ7ty\
8248OvVPpX9SDlGMaAWbq9mDHxnN4FvYngXBB9V8NhfdcDA5WQ73MQvA/xEVWGinj/lkpE/6vgjJvP\
Nn5glqO6fKhIWuZ7sr+JT+cvNuPPE2HV869U+l0YLmrX9SDlEfbD4rjGgFm2u9Qfur2YMfeSF+ExnN\
4FvYngXBXZ27ywfVfDYqKZpiF91wMFoBWZE5WQ732OwvFTELwP9nJjNnERVYaIdKtI6nj/lkDS4M26\
RP+r4dSLVHY2xvc3VyZSBpbnZva2VkIHJlY3Vyc2l2ZWx5IG9yIGRlc3Ryb3llZCBhbHJlYWR5AQAA\
AAAAAACCgAAAAAAAAIqAAAAAAACAAIAAgAAAAICLgAAAAAAAAAEAAIAAAAAAgYAAgAAAAIAJgAAAAA\
AAgIoAAAAAAAAAiAAAAAAAAAAJgACAAAAAAAoAAIAAAAAAi4AAgAAAAACLAAAAAAAAgImAAAAAAACA\
A4AAAAAAAIACgAAAAAAAgIAAAAAAAACACoAAAAAAAAAKAACAAAAAgIGAAIAAAACAgIAAAAAAAIABAA\
CAAAAAAAiAAIAAAACAY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWxp\
YnJhcnkvc3RkL3NyYy9wYW5pY2tpbmcucnMAgwgQABwAAABHAgAADwAAAGNhbGxlZCBgUmVzdWx0Oj\
p1bndyYXAoKWAgb24gYW4gYEVycmAgdmFsdWUAAAAAAF4M6fd8saoC7KhD4gNLQqzT/NUN41vNcjp/\
+faTmwFtk5Ef0v94mc3iKYBwyaFzdcODKpJrMmSxcFiRBO4+iEbm7ANxBeOs6lxTowi4aUHFfMTejZ\
FU50wM9A3c3/SiCvq+TacYb7cQaqvRWiO2zMb/4i9XIWFyEx6SnRlvjEgaygcA2vT5yUvHQVLo9ub1\
JrZHWerbeZCFkoyeycWFGE9Lhm+pHnaO133BtVKMQjaOwWMwNydoz2luxbSbPckHtuq1dg52DoJ9Qt\
x/8MacXGTgQjMkeKA4vwR9Lp08NGtfxg4LYOuKwvKsvFRyX9gObOVP26SBIllxn+0Pzmn6ZxnbRWW5\
+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\
+dhJMmP7iOPtm8+AnvFsEZpTgRhXJNVr9/MDUaj3R6715rcVz5x+1N7G19sauygCQVzlRJlO214l1E\
e2MPyquCuIEV0qIdMpu4sJ9bOWAukU6rWPWgLdVyGUe2e1rJCjwOdY+wFKvYNMZ9OJO7nzS9+kLZ4p\
SKuMMh7E/FIsWLqWjPMDsl3Yf7290cqDroJgwUK0u7Ca2qVr6F+5P6lxN2cELrLYUjFJyVhThB5UtJ\
eGSCq+ZmmO0y3copUrhTySrBEswHuo8g2ZsYgjvjdPG/oIgHwD5VRNyNBwH9RXzn7srZBUOjoG2Sc8\
KwC/ojCAhKOufsADIO1tMgLGhkCpaX0op4OKevUwy196xXnn63nkRGi16bzcBQ+0c6PiDleIbnga16\
D26L3NupyHL6NkwbzRapeL12aWXuIhqzzD5eWqYxCQkI1pSESzGJi7ih4+rodk47TcO4kx+b2vGdW7\
X9ygRWPKZZSbJv4ohuxRnD9gAV0et0lQoQZA5E2xy3b35XBsv+0rVe/yGBJBozZacAgHDMtEYJhPdR\
RN5w4oqA5D2VbNZVBfU9eRJcGW7wpy8SMyyB+lY3NvOaDD782riWdFIwEQMlR2mLrc/ofhssO0pZbw\
bnVsbCBwb2ludGVyIHBhc3NlZCB0byBydXN0cmVjdXJzaXZlIHVzZSBvZiBhbiBvYmplY3QgZGV0ZW\
N0ZWQgd2hpY2ggd291bGQgbGVhZCB0byB1bnNhZmUgYWxpYXNpbmcgaW4gcnVzdADnz4CAAARuYW1l\
AdzPgIAAmQEARWpzX3N5czo6VHlwZUVycm9yOjpuZXc6Ol9fd2JnX25ld19kYjI1NGFlMGExYmIwZm\
Y1OjpoYTI0ZWExODBiNTMzNGVmMAE7d2FzbV9iaW5kZ2VuOjpfX3diaW5kZ2VuX29iamVjdF9kcm9w\
X3JlZjo6aDE5ZDUwMGYzZTBmNDllNTECVWpzX3N5czo6VWludDhBcnJheTo6Ynl0ZV9sZW5ndGg6Ol\
9fd2JnX2J5dGVMZW5ndGhfODdhMDQzNmE3NGFkYzI2Yzo6aDIzYjEzYTM1M2UzNzgwNDIDVWpzX3N5\
czo6VWludDhBcnJheTo6Ynl0ZV9vZmZzZXQ6Ol9fd2JnX2J5dGVPZmZzZXRfNDQ3N2Q1NDcxMGFmNm\
Y5Yjo6aGU4ZWUxMDAwODAyY2Y4ZDQETGpzX3N5czo6VWludDhBcnJheTo6YnVmZmVyOjpfX3diZ19i\
dWZmZXJfMjEzMTBlYTE3MjU3YjBiNDo6aGQyODBkYTQzODQ1ZDc4NGEFeWpzX3N5czo6VWludDhBcn\
JheTo6bmV3X3dpdGhfYnl0ZV9vZmZzZXRfYW5kX2xlbmd0aDo6X193YmdfbmV3d2l0aGJ5dGVvZmZz\
ZXRhbmRsZW5ndGhfZDlhYTI2NjcwM2NiOThiZTo6aDIyMDMxMzZjNzkxZGI0ZWEGTGpzX3N5czo6VW\
ludDhBcnJheTo6bGVuZ3RoOjpfX3diZ19sZW5ndGhfOWUxYWUxOTAwY2IwZmJkNTo6aDFlYmRmMmI3\
NWFkMTNiNWIHMndhc21fYmluZGdlbjo6X193YmluZGdlbl9tZW1vcnk6Omg0ZGMyNzVjOGQxYzk5NT\
cyCFVqc19zeXM6OldlYkFzc2VtYmx5OjpNZW1vcnk6OmJ1ZmZlcjo6X193YmdfYnVmZmVyXzNmM2Q3\
NjRkNDc0N2Q1NjQ6OmhmYjkxMmFkZTU5OTgwMjI5CUZqc19zeXM6OlVpbnQ4QXJyYXk6Om5ldzo6X1\
93YmdfbmV3XzhjM2YwMDUyMjcyYTQ1N2E6Omg3OWM2MDkzMmI0ZGIzMjc4CkZqc19zeXM6OlVpbnQ4\
QXJyYXk6OnNldDo6X193Ymdfc2V0XzgzZGI5NjkwZjkzNTNlNzk6Omg3ODI5MjAwOTM4ODkwMzFkCz\
F3YXNtX2JpbmRnZW46Ol9fd2JpbmRnZW5fdGhyb3c6OmgwY2ExZmFiODliODNiMzgzDEBkZW5vX3N0\
ZF93YXNtX2NyeXB0bzo6ZGlnZXN0OjpDb250ZXh0OjpkaWdlc3Q6OmhmMTg3OTkzNzQ4MmU1ODQ3DS\
xzaGEyOjpzaGE1MTI6OmNvbXByZXNzNTEyOjpoZWM3NGU0Nzc0YTdlMDQwYQ5KZGVub19zdGRfd2Fz\
bV9jcnlwdG86OmRpZ2VzdDo6Q29udGV4dDo6ZGlnZXN0X2FuZF9yZXNldDo6aDZhNGZkMjI1ZjY3ND\
ljMGQPLHNoYTI6OnNoYTI1Njo6Y29tcHJlc3MyNTY6Omg0NjllNDIyNzljM2Y4MmQ1EBNkaWdlc3Rj\
b250ZXh0X2Nsb25lEUBkZW5vX3N0ZF93YXNtX2NyeXB0bzo6ZGlnZXN0OjpDb250ZXh0Ojp1cGRhdG\
U6OmhhNmVkYjg4YTFmMDk0OGYxEjNibGFrZTI6OkJsYWtlMmJWYXJDb3JlOjpjb21wcmVzczo6aGIw\
YmNjYTI1NzQzZTJiZGQTKXJpcGVtZDo6YzE2MDo6Y29tcHJlc3M6OmgwMjMzNjA1NjhlMTc3ZWE5FD\
NibGFrZTI6OkJsYWtlMnNWYXJDb3JlOjpjb21wcmVzczo6aDdhOTlhN2EzMWUwNTc2ZGQVK3NoYTE6\
OmNvbXByZXNzOjpjb21wcmVzczo6aDY3NmE4YzFhODBiMDA2Y2QWLHRpZ2VyOjpjb21wcmVzczo6Y2\
9tcHJlc3M6Omg4ZTkxMGYxOTdiYjdkYjc5Fy1ibGFrZTM6Ok91dHB1dFJlYWRlcjo6ZmlsbDo6aDBm\
NDU2NzBlZDUyOWE3ODgYNmJsYWtlMzo6cG9ydGFibGU6OmNvbXByZXNzX2luX3BsYWNlOjpoODJhND\
gzNWJhNzhhZTk5ORk6ZGxtYWxsb2M6OmRsbWFsbG9jOjpEbG1hbGxvYzxBPjo6bWFsbG9jOjpoYTk2\
ZmNlZmJiNDRkNmRhNRplPGRpZ2VzdDo6Y29yZV9hcGk6OndyYXBwZXI6OkNvcmVXcmFwcGVyPFQ+IG\
FzIGRpZ2VzdDo6VXBkYXRlPjo6dXBkYXRlOjp7e2Nsb3N1cmV9fTo6aDdkOGMwMGE0OWNjNTAyYTkb\
aDxtZDU6Ok1kNUNvcmUgYXMgZGlnZXN0Ojpjb3JlX2FwaTo6Rml4ZWRPdXRwdXRDb3JlPjo6ZmluYW\
xpemVfZml4ZWRfY29yZTo6e3tjbG9zdXJlfX06OmgyZWRlNTY0ZDNiOWQ5YWE1HCxjb3JlOjpmbXQ6\
OkZvcm1hdHRlcjo6cGFkOjpoOGM3NTNlNDk0ZjdiNTY5ZB0gbWQ0Ojpjb21wcmVzczo6aGEwODdhNj\
g2M2E2ZDVkNjceMGJsYWtlMzo6Y29tcHJlc3Nfc3VidHJlZV93aWRlOjpoNGUwOTU3MTJmOGIxNGVj\
NB8vYmxha2UzOjpIYXNoZXI6OmZpbmFsaXplX3hvZjo6aDFkYmIzNWJlN2MzYTViYjMgPWRlbm9fc3\
RkX3dhc21fY3J5cHRvOjpkaWdlc3Q6OkNvbnRleHQ6Om5ldzo6aGMxMDI1YzRlNmI0MDc0YTYhE2Rp\
Z2VzdGNvbnRleHRfcmVzZXQiOGRsbWFsbG9jOjpkbG1hbGxvYzo6RGxtYWxsb2M8QT46OmZyZWU6Om\
hhNDczN2I3Zjg0OTcwYWRkI3I8c2hhMjo6Y29yZV9hcGk6OlNoYTUxMlZhckNvcmUgYXMgZGlnZXN0\
Ojpjb3JlX2FwaTo6VmFyaWFibGVPdXRwdXRDb3JlPjo6ZmluYWxpemVfdmFyaWFibGVfY29yZTo6aD\
k3OGVkYTNlNWJmNGQ4NWMkQWRsbWFsbG9jOjpkbG1hbGxvYzo6RGxtYWxsb2M8QT46OmRpc3Bvc2Vf\
Y2h1bms6OmgzYjZjNGU3NGZhOGFhMDRiJSBrZWNjYWs6OmYxNjAwOjpoZmUyMWFkMGU3YjIxYzU5Zi\
YOX19ydXN0X3JlYWxsb2MncjxzaGEyOjpjb3JlX2FwaTo6U2hhMjU2VmFyQ29yZSBhcyBkaWdlc3Q6\
OmNvcmVfYXBpOjpWYXJpYWJsZU91dHB1dENvcmU+OjpmaW5hbGl6ZV92YXJpYWJsZV9jb3JlOjpoZG\
Y0OWFhZTRhMjkzNDMwMihOY29yZTo6Zm10OjpudW06OmltcDo6PGltcGwgY29yZTo6Zm10OjpEaXNw\
bGF5IGZvciB1MzI+OjpmbXQ6OmhjNTBhMWM5YjgyZWI0NDQ2KV08c2hhMTo6U2hhMUNvcmUgYXMgZG\
lnZXN0Ojpjb3JlX2FwaTo6Rml4ZWRPdXRwdXRDb3JlPjo6ZmluYWxpemVfZml4ZWRfY29yZTo6aDE2\
OGNiNTBiZmNiMDBjMjIqMWJsYWtlMzo6SGFzaGVyOjptZXJnZV9jdl9zdGFjazo6aDBhOWM0YzI2ZT\
NhMjQwNjIrI2NvcmU6OmZtdDo6d3JpdGU6OmhlZDhmZTdkMDk1NDc5ZWEyLGQ8cmlwZW1kOjpSaXBl\
bWQxNjBDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2\
ZpeGVkX2NvcmU6Omg2ZDgyNWIxODgxMDU1NzYxLTRibGFrZTM6OmNvbXByZXNzX3BhcmVudHNfcGFy\
YWxsZWw6OmhiNmY2ZWMwODM2NzU5MTdkLls8bWQ0OjpNZDRDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcG\
k6OkZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6Omg3Y2Q3OTY3ZGQ2NmYzYjE2\
L1s8bWQ1OjpNZDVDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZpbm\
FsaXplX2ZpeGVkX2NvcmU6OmhkMDc3MjcxM2EyZjQxMjRjMF88dGlnZXI6OlRpZ2VyQ29yZSBhcyBk\
aWdlc3Q6OmNvcmVfYXBpOjpGaXhlZE91dHB1dENvcmU+OjpmaW5hbGl6ZV9maXhlZF9jb3JlOjpoMT\
MyMDkyM2MxNjg2NDg5NDEwZGxtYWxsb2M6OkRsbWFsbG9jPEE+OjptYWxsb2M6OmgwMDU3MzU2N2Ez\
MzM4ZGY4Mkw8YWxsb2M6OmJveGVkOjpCb3g8VD4gYXMgY29yZTo6ZGVmYXVsdDo6RGVmYXVsdD46Om\
RlZmF1bHQ6OmhmYzgzZjY4NGNmNDdhNDk5M0w8YWxsb2M6OmJveGVkOjpCb3g8VD4gYXMgY29yZTo6\
ZGVmYXVsdDo6RGVmYXVsdD46OmRlZmF1bHQ6OmhkNDBmYWU0Njk0NWI4YmRiNEw8YWxsb2M6OmJveG\
VkOjpCb3g8VD4gYXMgY29yZTo6ZGVmYXVsdDo6RGVmYXVsdD46OmRlZmF1bHQ6Omg3ODlhOGRmODA0\
N2Q5OTI2NUw8YWxsb2M6OmJveGVkOjpCb3g8VD4gYXMgY29yZTo6ZGVmYXVsdDo6RGVmYXVsdD46Om\
RlZmF1bHQ6OmhjZmY3OWViMDgzNzBkN2Q3NmQ8c2hhMzo6U2hha2UxMjhDb3JlIGFzIGRpZ2VzdDo6\
Y29yZV9hcGk6OkV4dGVuZGFibGVPdXRwdXRDb3JlPjo6ZmluYWxpemVfeG9mX2NvcmU6OmhlZTc0Mz\
IyYjBmN2JkZGUzNy1ibGFrZTM6OkNodW5rU3RhdGU6OnVwZGF0ZTo6aDkwMmE0MzQyNTZlMTU2YTg4\
YjxzaGEzOjpLZWNjYWsyMjRDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT\
46OmZpbmFsaXplX2ZpeGVkX2NvcmU6OmhhM2Q0YmJkOTdmMTliNDc0OWE8c2hhMzo6U2hhM18yMjRD\
b3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVkX2\
NvcmU6Omg2YzUxODIxMTA2ZjRkY2I3OnI8ZGlnZXN0Ojpjb3JlX2FwaTo6eG9mX3JlYWRlcjo6WG9m\
UmVhZGVyQ29yZVdyYXBwZXI8VD4gYXMgZGlnZXN0OjpYb2ZSZWFkZXI+OjpyZWFkOjp7e2Nsb3N1cm\
V9fTo6aDA2NGY5YTJkMDBkYTMxYjc7TDxhbGxvYzo6Ym94ZWQ6OkJveDxUPiBhcyBjb3JlOjpkZWZh\
dWx0OjpEZWZhdWx0Pjo6ZGVmYXVsdDo6aGJlOTBmMmE5NTExZmExMjI8ZTxkaWdlc3Q6OmNvcmVfYX\
BpOjp4b2ZfcmVhZGVyOjpYb2ZSZWFkZXJDb3JlV3JhcHBlcjxUPiBhcyBkaWdlc3Q6OlhvZlJlYWRl\
cj46OnJlYWQ6OmgwNmVkNDFlZjliZTlkN2UyPWU8ZGlnZXN0Ojpjb3JlX2FwaTo6eG9mX3JlYWRlcj\
o6WG9mUmVhZGVyQ29yZVdyYXBwZXI8VD4gYXMgZGlnZXN0OjpYb2ZSZWFkZXI+OjpyZWFkOjpoODlk\
ODFhYjFhNzA2ZjM0ZT5lPGRpZ2VzdDo6Y29yZV9hcGk6OndyYXBwZXI6OkNvcmVXcmFwcGVyPFQ+IG\
FzIGRpZ2VzdDo6VXBkYXRlPjo6dXBkYXRlOjp7e2Nsb3N1cmV9fTo6aDVlYzI3NGIxNDg2YmExZDU/\
TDxhbGxvYzo6Ym94ZWQ6OkJveDxUPiBhcyBjb3JlOjpkZWZhdWx0OjpEZWZhdWx0Pjo6ZGVmYXVsdD\
o6aDdmY2U4YTYzZWRhYTJhOWJAMWNvbXBpbGVyX2J1aWx0aW5zOjptZW06Om1lbWNweTo6aDQ1ZWI1\
MzYwMWQ5ZDZiZjBBYjxzaGEzOjpLZWNjYWsyNTZDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeG\
VkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6Omg3ZTJhZGJiN2E5ZDdmYjg5QmE8c2hh\
Mzo6U2hhM18yNTZDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZpbm\
FsaXplX2ZpeGVkX2NvcmU6OmgyMDg1ZWRlMDE5ZmMzYTBmQ3I8ZGlnZXN0Ojpjb3JlX2FwaTo6eG9m\
X3JlYWRlcjo6WG9mUmVhZGVyQ29yZVdyYXBwZXI8VD4gYXMgZGlnZXN0OjpYb2ZSZWFkZXI+OjpyZW\
FkOjp7e2Nsb3N1cmV9fTo6aGQyM2ExZTdiODUwNTA5ZGFEZTxkaWdlc3Q6OmNvcmVfYXBpOjp3cmFw\
cGVyOjpDb3JlV3JhcHBlcjxUPiBhcyBkaWdlc3Q6OlVwZGF0ZT46OnVwZGF0ZTo6e3tjbG9zdXJlfX\
06OmgzMDMxY2Q2MjU1Mjg0ZjJjRWQ8c2hhMzo6U2hha2UyNTZDb3JlIGFzIGRpZ2VzdDo6Y29yZV9h\
cGk6OkV4dGVuZGFibGVPdXRwdXRDb3JlPjo6ZmluYWxpemVfeG9mX2NvcmU6Omg2NGM2NDQxNjZkZT\
UzOGEwRkZkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+OjppbnNlcnRfbGFyZ2VfY2h1bms6\
OmhiMTI5OTBmOTI1MzhmYmJmR0ZkbG1hbGxvYzo6ZGxtYWxsb2M6OkRsbWFsbG9jPEE+Ojp1bmxpbm\
tfbGFyZ2VfY2h1bms6OmhiZThkMzZhOWY0MDYwY2VlSGU8ZGlnZXN0Ojpjb3JlX2FwaTo6d3JhcHBl\
cjo6Q29yZVdyYXBwZXI8VD4gYXMgZGlnZXN0OjpVcGRhdGU+Ojp1cGRhdGU6Ont7Y2xvc3VyZX19Oj\
poMmViZGVhYWU5NjQ4MjIzNEliPHNoYTM6OktlY2NhazM4NENvcmUgYXMgZGlnZXN0Ojpjb3JlX2Fw\
aTo6Rml4ZWRPdXRwdXRDb3JlPjo6ZmluYWxpemVfZml4ZWRfY29yZTo6aDNhNDNlOTFlYzE3NDQ1OT\
lKYTxzaGEzOjpTaGEzXzM4NENvcmUgYXMgZGlnZXN0Ojpjb3JlX2FwaTo6Rml4ZWRPdXRwdXRDb3Jl\
Pjo6ZmluYWxpemVfZml4ZWRfY29yZTo6aGJhNjUxNDU3MWI2Y2RjNmZLYjxzaGEzOjpLZWNjYWs1MT\
JDb3JlIGFzIGRpZ2VzdDo6Y29yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVk\
X2NvcmU6OmhlNzk0NWIzODYxYWMzOTQ1TGE8c2hhMzo6U2hhM181MTJDb3JlIGFzIGRpZ2VzdDo6Y2\
9yZV9hcGk6OkZpeGVkT3V0cHV0Q29yZT46OmZpbmFsaXplX2ZpeGVkX2NvcmU6Omg1YTJlMGFiNjNh\
NWU0ZjdkTUw8YWxsb2M6OmJveGVkOjpCb3g8VD4gYXMgY29yZTo6ZGVmYXVsdDo6RGVmYXVsdD46Om\
RlZmF1bHQ6OmhhODkyMWQ4NTQxNWI0NjFmTkw8YWxsb2M6OmJveGVkOjpCb3g8VD4gYXMgY29yZTo6\
ZGVmYXVsdDo6RGVmYXVsdD46OmRlZmF1bHQ6OmgwOGVmYWY3YTE5NjNlODFkT2U8ZGlnZXN0Ojpjb3\
JlX2FwaTo6d3JhcHBlcjo6Q29yZVdyYXBwZXI8VD4gYXMgZGlnZXN0OjpVcGRhdGU+Ojp1cGRhdGU6\
Ont7Y2xvc3VyZX19OjpoMzdiMDQ1ZmVkZGI1MGJiN1A+ZGVub19zdGRfd2FzbV9jcnlwdG86OkRpZ2\
VzdENvbnRleHQ6OnVwZGF0ZTo6aDc1NWQzNWU2MWE1Nzk4NWJRWzxibG9ja19idWZmZXI6OkJsb2Nr\
QnVmZmVyPEJsb2NrU2l6ZSxLaW5kPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aDYzN2\
MxYzYyY2EwMTU4YjZSBmRpZ2VzdFMxY29tcGlsZXJfYnVpbHRpbnM6Om1lbTo6bWVtc2V0OjpoNWI4\
Yjk5OGE0YjJmYjIwNVRlPGRpZ2VzdDo6Y29yZV9hcGk6OndyYXBwZXI6OkNvcmVXcmFwcGVyPFQ+IG\
FzIGRpZ2VzdDo6VXBkYXRlPjo6dXBkYXRlOjp7e2Nsb3N1cmV9fTo6aGNiMzJhYzkzM2VjMjU3NjJV\
FGRpZ2VzdGNvbnRleHRfZGlnZXN0VhFkaWdlc3Rjb250ZXh0X25ld1ccZGlnZXN0Y29udGV4dF9kaW\
dlc3RBbmRSZXNldFhMPGFsbG9jOjpib3hlZDo6Qm94PFQ+IGFzIGNvcmU6OmRlZmF1bHQ6OkRlZmF1\
bHQ+OjpkZWZhdWx0OjpoN2M1MjFjNjZmY2M1ZjBlMFlMPGFsbG9jOjpib3hlZDo6Qm94PFQ+IGFzIG\
NvcmU6OmRlZmF1bHQ6OkRlZmF1bHQ+OjpkZWZhdWx0OjpoNmNhZTQ4Yzk0ZTYxNTBjMlpMPGFsbG9j\
Ojpib3hlZDo6Qm94PFQ+IGFzIGNvcmU6OmRlZmF1bHQ6OkRlZmF1bHQ+OjpkZWZhdWx0OjpoMzMwZj\
QzMmYxYjk4MWI2M1tMPGFsbG9jOjpib3hlZDo6Qm94PFQ+IGFzIGNvcmU6OmRlZmF1bHQ6OkRlZmF1\
bHQ+OjpkZWZhdWx0OjpoZmI3NmVkNGYzYTc0YmQ4MVxMPGFsbG9jOjpib3hlZDo6Qm94PFQ+IGFzIG\
NvcmU6OmRlZmF1bHQ6OkRlZmF1bHQ+OjpkZWZhdWx0OjpoNzg0ZDY4ZGM2YjUxYzk4YV0tanNfc3lz\
OjpVaW50OEFycmF5Ojp0b192ZWM6Omg3NWRkMjNlM2E1NTk4ZDYwXhtkaWdlc3Rjb250ZXh0X2RpZ2\
VzdEFuZERyb3BfP3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0Ojpo\
YzlhM2Q4ZWUxMDQzNGU1ZGBHZGVub19zdGRfd2FzbV9jcnlwdG86OkRpZ2VzdENvbnRleHQ6OmRpZ2\
VzdF9hbmRfZHJvcDo6aGExMmMwYTFmNzcwYTAyMTNhLmNvcmU6OnJlc3VsdDo6dW53cmFwX2ZhaWxl\
ZDo6aDJkYzcwNmQ5NDhjMjI5NjBiWzxibG9ja19idWZmZXI6OkJsb2NrQnVmZmVyPEJsb2NrU2l6ZS\
xLaW5kPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aGVjZWMwNDk3NDVlZDQxNDFjWzxi\
bG9ja19idWZmZXI6OkJsb2NrQnVmZmVyPEJsb2NrU2l6ZSxLaW5kPiBhcyBjb3JlOjpjbG9uZTo6Q2\
xvbmU+OjpjbG9uZTo6aDcxNGFjYzM4NDMzYTExOGRkWzxibG9ja19idWZmZXI6OkJsb2NrQnVmZmVy\
PEJsb2NrU2l6ZSxLaW5kPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aDczNjBkYjk1OG\
EzNThjODVlWzxibG9ja19idWZmZXI6OkJsb2NrQnVmZmVyPEJsb2NrU2l6ZSxLaW5kPiBhcyBjb3Jl\
OjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aDkwZTQwNmVmZjNkZDIxMDRmWzxibG9ja19idWZmZXI6Ok\
Jsb2NrQnVmZmVyPEJsb2NrU2l6ZSxLaW5kPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6\
aGM3OWM0NTFlMDkyY2I5ZDFnWzxibG9ja19idWZmZXI6OkJsb2NrQnVmZmVyPEJsb2NrU2l6ZSxLaW\
5kPiBhcyBjb3JlOjpjbG9uZTo6Q2xvbmU+OjpjbG9uZTo6aDJmODE4MGNiMDg5YzJmOThoUDxhcnJh\
eXZlYzo6ZXJyb3JzOjpDYXBhY2l0eUVycm9yPFQ+IGFzIGNvcmU6OmZtdDo6RGVidWc+OjpmbXQ6Om\
gxY2JhMzA5MjAwMTQ1OThlaVA8YXJyYXl2ZWM6OmVycm9yczo6Q2FwYWNpdHlFcnJvcjxUPiBhcyBj\
b3JlOjpmbXQ6OkRlYnVnPjo6Zm10OjpoOWMwZWJhZDlkMDgyZTU1OGpOY29yZTo6c2xpY2U6OjxpbX\
BsIFtUXT46OmNvcHlfZnJvbV9zbGljZTo6bGVuX21pc21hdGNoX2ZhaWw6OmhmM2JiYWJjMDIwNDg2\
NGJjazZjb3JlOjpwYW5pY2tpbmc6OnBhbmljX2JvdW5kc19jaGVjazo6aDFmYjdhNmRmMTAzMzEyNz\
lsRGNvcmU6OnNsaWNlOjppbmRleDo6c2xpY2Vfc3RhcnRfaW5kZXhfbGVuX2ZhaWxfcnQ6OmhiMzE3\
Y2E4MzMyMDQ2NWE2bUJjb3JlOjpzbGljZTo6aW5kZXg6OnNsaWNlX2VuZF9pbmRleF9sZW5fZmFpbF\
9ydDo6aGZjZjkzZGQzNWYwMTEyYmRuGF9fd2JnX2RpZ2VzdGNvbnRleHRfZnJlZW83c3RkOjpwYW5p\
Y2tpbmc6OnJ1c3RfcGFuaWNfd2l0aF9ob29rOjpoNzBhMGUxOTVmNGRiMmEyOXAxY29tcGlsZXJfYn\
VpbHRpbnM6Om1lbTo6bWVtY21wOjpoMTI4NWI4NDEyMGRmNWRjZHEUZGlnZXN0Y29udGV4dF91cGRh\
dGVyKWNvcmU6OnBhbmlja2luZzo6cGFuaWM6Omg4YWYwNDYzOTdhMmJmNjVkczpibGFrZTI6OkJsYW\
tlMmJWYXJDb3JlOjpuZXdfd2l0aF9wYXJhbXM6Omg0NGYxNTNlOTYwYjIwOTM5dBFydXN0X2JlZ2lu\
X3Vud2luZHVDY29yZTo6Zm10OjpGb3JtYXR0ZXI6OnBhZF9pbnRlZ3JhbDo6d3JpdGVfcHJlZml4Oj\
poNjBiMWI1MDNlNjZmMzJiMXY0YWxsb2M6OnJhd192ZWM6OmNhcGFjaXR5X292ZXJmbG93OjpoNGIy\
NzVjYjNjMTBiMGE3OHctY29yZTo6cGFuaWNraW5nOjpwYW5pY19mbXQ6Omg3NTFiZTgwNzc5ZDQyYj\
UzeENzdGQ6OnBhbmlja2luZzo6YmVnaW5fcGFuaWNfaGFuZGxlcjo6e3tjbG9zdXJlfX06OmhkY2Zj\
ODE5Y2U4MzY4MjlleRFfX3diaW5kZ2VuX21hbGxvY3o6Ymxha2UyOjpCbGFrZTJzVmFyQ29yZTo6bm\
V3X3dpdGhfcGFyYW1zOjpoMjNlMzIwMWM5ZmYyMzMyOXtJc3RkOjpzeXNfY29tbW9uOjpiYWNrdHJh\
Y2U6Ol9fcnVzdF9lbmRfc2hvcnRfYmFja3RyYWNlOjpoNTNjYWJhZmFiNWIwOWFkYXw/d2FzbV9iaW\
5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlNF9tdXQ6Omg5NjlhZjNlZGJiNzM4YjVmfT93\
YXNtX2JpbmRnZW46OmNvbnZlcnQ6OmNsb3N1cmVzOjppbnZva2UzX211dDo6aDA1OTZjYWRlZDYzNz\
JlYWZ+P3dhc21fYmluZGdlbjo6Y29udmVydDo6Y2xvc3VyZXM6Omludm9rZTNfbXV0OjpoNDIxN2Nj\
NDEwYzk0OWE2YX8/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlM19tdXQ6Om\
hiYzBkZTg4ZTYzNTRlYTJigAE/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tl\
M19tdXQ6OmgxOGYyY2JiNjE4MmUwZmYwgQE/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlcz\
o6aW52b2tlM19tdXQ6Omg0MmUzZjhmYjQzNjIwOGU0ggE/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0Ojpj\
bG9zdXJlczo6aW52b2tlM19tdXQ6OmhjYTZjYzM2N2Y0OWE3MjM2gwE/d2FzbV9iaW5kZ2VuOjpjb2\
52ZXJ0OjpjbG9zdXJlczo6aW52b2tlM19tdXQ6OmgzZjliODQxZjE0MmQ5OGU4hAE/d2FzbV9iaW5k\
Z2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlM19tdXQ6Omg3MDhjYmY5YTQyNWUzMDM5hQE/d2\
FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlczo6aW52b2tlMl9tdXQ6Omg3ZjAxNzJhNWUyYjY1\
YzY5hgESX193YmluZGdlbl9yZWFsbG9jhwE/d2FzbV9iaW5kZ2VuOjpjb252ZXJ0OjpjbG9zdXJlcz\
o6aW52b2tlMV9tdXQ6OmgxZmMwOTdmZjY0ZTNhOTY5iAEwPCZUIGFzIGNvcmU6OmZtdDo6RGVidWc+\
OjpmbXQ6OmhmZjRhZjFiNGE4MTM5OTZhiQEyPCZUIGFzIGNvcmU6OmZtdDo6RGlzcGxheT46OmZtdD\
o6aDY0ZGQyZjhhMzhjZWIxMDOKAQ9fX3diaW5kZ2VuX2ZyZWWLAT9jb3JlOjpzbGljZTo6aW5kZXg6\
OnNsaWNlX2VuZF9pbmRleF9sZW5fZmFpbDo6aDNkYjQ3NmIwZDA5OTk0ZDKMAUFjb3JlOjpzbGljZT\
o6aW5kZXg6OnNsaWNlX3N0YXJ0X2luZGV4X2xlbl9mYWlsOjpoMTM2Y2NhZDc2NDEzNjgxMI0BM2Fy\
cmF5dmVjOjphcnJheXZlYzo6ZXh0ZW5kX3BhbmljOjpoNjRmY2MxNjMwYmVhY2NhN44BOWNvcmU6Om\
9wczo6ZnVuY3Rpb246OkZuT25jZTo6Y2FsbF9vbmNlOjpoZTAyMWRiYmY2ZmFhYTA2ZI8BH19fd2Jp\
bmRnZW5fYWRkX3RvX3N0YWNrX3BvaW50ZXKQATF3YXNtX2JpbmRnZW46Ol9fcnQ6OnRocm93X251bG\
w6OmgxYWMxZTJjMTFkOWRlMDlikQEyd2FzbV9iaW5kZ2VuOjpfX3J0Ojpib3Jyb3dfZmFpbDo6aDc4\
ZDIwNzFkNmMwNWI5ODSSASp3YXNtX2JpbmRnZW46OnRocm93X3N0cjo6aDNmMjIyOWZlMzAzMjI2OW\
STAQZtZW1zZXSUAQZtZW1jcHmVAQZtZW1jbXCWATE8VCBhcyBjb3JlOjphbnk6OkFueT46OnR5cGVf\
aWQ6OmgxM2M3ODU5NjY4OGY2N2IylwEKcnVzdF9wYW5pY5gBb2NvcmU6OnB0cjo6ZHJvcF9pbl9wbG\
FjZTwmY29yZTo6aXRlcjo6YWRhcHRlcnM6OmNvcGllZDo6Q29waWVkPGNvcmU6OnNsaWNlOjppdGVy\
OjpJdGVyPHU4Pj4+OjpoMDVmYTBmOTcxYjQ2YjBlNwDvgICAAAlwcm9kdWNlcnMCCGxhbmd1YWdlAQ\
RSdXN0AAxwcm9jZXNzZWQtYnkDBXJ1c3RjHTEuNjUuMCAoODk3ZTM3NTUzIDIwMjItMTEtMDIpBndh\
bHJ1cwYwLjE5LjAMd2FzbS1iaW5kZ2VuBjAuMi44Mw==\
");
    const wasmModule = new WebAssembly.Module(wasmBytes);
    return new WebAssembly.Instance(wasmModule, imports);
}
function base64decode(b64) {
    const binString = atob(b64);
    const size = binString.length;
    const bytes = new Uint8Array(size);
    for(let i = 0; i < size; i++){
        bytes[i] = binString.charCodeAt(i);
    }
    return bytes;
}
let _exiting = false;
const kSize = 2048;
const kMask = 2048 - 1;
class FixedCircularBuffer {
    bottom;
    top;
    list;
    next;
    constructor(){
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
    }
    isEmpty() {
        return this.top === this.bottom;
    }
    isFull() {
        return (this.top + 1 & kMask) === this.bottom;
    }
    push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
    }
    shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === undefined) {
            return null;
        }
        this.list[this.bottom] = undefined;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
    }
}
class FixedQueue {
    head;
    tail;
    constructor(){
        this.head = this.tail = new FixedCircularBuffer();
    }
    isEmpty() {
        return this.head.isEmpty();
    }
    push(data) {
        if (this.head.isFull()) {
            this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
    }
    shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
            this.tail = tail.next;
        }
        return next;
    }
}
const queue = new FixedQueue();
let _nextTick;
function processTicksAndRejections() {
    let tock;
    do {
        while(tock = queue.shift()){
            try {
                const callback = tock.callback;
                if (tock.args === undefined) {
                    callback();
                } else {
                    const args = tock.args;
                    switch(args.length){
                        case 1:
                            callback(args[0]);
                            break;
                        case 2:
                            callback(args[0], args[1]);
                            break;
                        case 3:
                            callback(args[0], args[1], args[2]);
                            break;
                        case 4:
                            callback(args[0], args[1], args[2], args[3]);
                            break;
                        default:
                            callback(...args);
                    }
                }
            } finally{}
        }
        core.runMicrotasks();
    }while (!queue.isEmpty())
    core.setHasTickScheduled(false);
}
if (typeof core.setNextTickCallback !== "undefined") {
    function runNextTicks() {
        if (!core.hasTickScheduled()) {
            core.runMicrotasks();
        }
        if (!core.hasTickScheduled()) {
            return true;
        }
        processTicksAndRejections();
        return true;
    }
    core.setNextTickCallback(processTicksAndRejections);
    core.setMacrotaskCallback(runNextTicks);
    function __nextTickNative(callback, ...args) {
        validateFunction(callback, "callback");
        if (_exiting) {
            return;
        }
        let args_;
        switch(args.length){
            case 0:
                break;
            case 1:
                args_ = [
                    args[0]
                ];
                break;
            case 2:
                args_ = [
                    args[0],
                    args[1]
                ];
                break;
            case 3:
                args_ = [
                    args[0],
                    args[1],
                    args[2]
                ];
                break;
            default:
                args_ = new Array(args.length);
                for(let i = 0; i < args.length; i++){
                    args_[i] = args[i];
                }
        }
        if (queue.isEmpty()) {
            core.setHasTickScheduled(true);
        }
        const tickObject = {
            callback,
            args: args_
        };
        queue.push(tickObject);
    }
    _nextTick = __nextTickNative;
} else {
    function __nextTickQueueMicrotask(callback, ...args) {
        if (args) {
            queueMicrotask(()=>callback.call(this, ...args));
        } else {
            queueMicrotask(callback);
        }
    }
    _nextTick = __nextTickQueueMicrotask;
}
function nextTick1(callback, ...args) {
    _nextTick(callback, ...args);
}
const stdio = {};
var NotImplemented;
(function(NotImplemented) {
    NotImplemented[NotImplemented["ascii"] = 0] = "ascii";
    NotImplemented[NotImplemented["latin1"] = 1] = "latin1";
    NotImplemented[NotImplemented["utf16le"] = 2] = "utf16le";
})(NotImplemented || (NotImplemented = {}));
function normalizeEncoding2(enc) {
    const encoding = normalizeEncoding1(enc ?? null);
    if (encoding && encoding in NotImplemented) notImplemented(encoding);
    if (!encoding && typeof enc === "string" && enc.toLowerCase() !== "raw") {
        throw new Error(`Unknown encoding: ${enc}`);
    }
    return String(encoding);
}
function isBufferType(buf) {
    return buf instanceof ArrayBuffer && buf.BYTES_PER_ELEMENT;
}
function utf8CheckByte(__byte) {
    if (__byte <= 0x7f) return 0;
    else if (__byte >> 5 === 0x06) return 2;
    else if (__byte >> 4 === 0x0e) return 3;
    else if (__byte >> 3 === 0x1e) return 4;
    return __byte >> 6 === 0x02 ? -1 : -2;
}
function utf8CheckIncomplete(self, buf, i) {
    let j = buf.length - 1;
    if (j < i) return 0;
    let nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
function utf8CheckExtraBytes(self, buf) {
    if ((buf[0] & 0xc0) !== 0x80) {
        self.lastNeed = 0;
        return "\ufffd";
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xc0) !== 0x80) {
            self.lastNeed = 1;
            return "\ufffd";
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xc0) !== 0x80) {
                self.lastNeed = 2;
                return "\ufffd";
            }
        }
    }
}
function utf8FillLastComplete(buf) {
    const p = this.lastTotal - this.lastNeed;
    const r = utf8CheckExtraBytes(this, buf);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
function utf8FillLastIncomplete(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
}
function utf8Text(buf, i) {
    const total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    const end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
}
function utf8End(buf) {
    const r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "\ufffd";
    return r;
}
function utf8Write(buf) {
    if (typeof buf === "string") {
        return buf;
    }
    if (buf.length === 0) return "";
    let r;
    let i;
    const normalizedBuffer = isBufferType(buf) ? buf : Buffer.from(buf);
    if (this.lastNeed) {
        r = this.fillLast(normalizedBuffer);
        if (r === undefined) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
    } else {
        i = 0;
    }
    if (i < buf.length) {
        return r ? r + this.text(normalizedBuffer, i) : this.text(normalizedBuffer, i);
    }
    return r || "";
}
function base64Text(buf, i) {
    const n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
    } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
}
function base64End(buf) {
    const r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    }
    return r;
}
function simpleWrite(buf) {
    if (typeof buf === "string") {
        return buf;
    }
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
}
class StringDecoderBase {
    encoding;
    lastChar;
    lastNeed;
    lastTotal;
    constructor(encoding, nb){
        this.encoding = encoding;
        this.lastNeed = 0;
        this.lastTotal = 0;
        this.lastChar = Buffer.allocUnsafe(nb);
    }
}
class Base64Decoder extends StringDecoderBase {
    end = base64End;
    fillLast = utf8FillLastIncomplete;
    text = base64Text;
    write = utf8Write;
    constructor(encoding){
        super(normalizeEncoding2(encoding), 3);
    }
}
class GenericDecoder extends StringDecoderBase {
    end = simpleEnd;
    fillLast = undefined;
    text = utf8Text;
    write = simpleWrite;
    constructor(encoding){
        super(normalizeEncoding2(encoding), 4);
    }
}
class Utf8Decoder extends StringDecoderBase {
    end = utf8End;
    fillLast = utf8FillLastComplete;
    text = utf8Text;
    write = utf8Write;
    constructor(encoding){
        super(normalizeEncoding2(encoding), 4);
    }
}
class StringDecoder {
    encoding;
    end;
    fillLast;
    lastChar;
    lastNeed;
    lastTotal;
    text;
    write;
    constructor(encoding){
        const normalizedEncoding = normalizeEncoding2(encoding);
        let decoder;
        switch(normalizedEncoding){
            case "utf8":
                decoder = new Utf8Decoder(encoding);
                break;
            case "base64":
                decoder = new Base64Decoder(encoding);
                break;
            default:
                decoder = new GenericDecoder(encoding);
        }
        this.encoding = decoder.encoding;
        this.end = decoder.end;
        this.fillLast = decoder.fillLast;
        this.lastChar = decoder.lastChar;
        this.lastNeed = decoder.lastNeed;
        this.lastTotal = decoder.lastTotal;
        this.text = decoder.text;
        this.write = decoder.write;
    }
}
const PStringDecoder = new Proxy(StringDecoder, {
    apply (_target, thisArg, args) {
        return Object.assign(thisArg, new StringDecoder(...args));
    }
});
const __default4 = {
    StringDecoder: PStringDecoder
};
"use strict";
const kRejection = Symbol.for("nodejs.rejection");
const kCapture = Symbol("kCapture");
const kErrorMonitor = Symbol("events.errorMonitor");
const kMaxEventTargetListeners = Symbol("events.maxEventTargetListeners");
const kMaxEventTargetListenersWarned = Symbol("events.maxEventTargetListenersWarned");
function EventEmitter(opts) {
    EventEmitter.init.call(this, opts);
}
EventEmitter.on = on;
EventEmitter.once = once1;
EventEmitter.getEventListeners = getEventListeners;
EventEmitter.setMaxListeners = setMaxListeners;
EventEmitter.listenerCount = listenerCount;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.usingDomains = false;
EventEmitter.captureRejectionSymbol = kRejection;
EventEmitter.captureRejectionSymbol;
EventEmitter.errorMonitor;
Object.defineProperty(EventEmitter, "captureRejections", {
    get () {
        return EventEmitter.prototype[kCapture];
    },
    set (value) {
        validateBoolean(value, "EventEmitter.captureRejections");
        EventEmitter.prototype[kCapture] = value;
    },
    enumerable: true
});
EventEmitter.errorMonitor = kErrorMonitor;
Object.defineProperty(EventEmitter.prototype, kCapture, {
    value: false,
    writable: true,
    enumerable: false
});
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;
let defaultMaxListeners = 10;
function checkListener(listener) {
    validateFunction(listener, "listener");
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
        return defaultMaxListeners;
    },
    set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || Number.isNaN(arg)) {
            throw new ERR_OUT_OF_RANGE("defaultMaxListeners", "a non-negative number", arg);
        }
        defaultMaxListeners = arg;
    }
});
Object.defineProperties(EventEmitter, {
    kMaxEventTargetListeners: {
        value: kMaxEventTargetListeners,
        enumerable: false,
        configurable: false,
        writable: false
    },
    kMaxEventTargetListenersWarned: {
        value: kMaxEventTargetListenersWarned,
        enumerable: false,
        configurable: false,
        writable: false
    }
});
function setMaxListeners(n = defaultMaxListeners, ...eventTargets) {
    if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
        throw new ERR_OUT_OF_RANGE("n", "a non-negative number", n);
    }
    if (eventTargets.length === 0) {
        defaultMaxListeners = n;
    } else {
        for(let i = 0; i < eventTargets.length; i++){
            const target = eventTargets[i];
            if (target instanceof EventTarget) {
                target[kMaxEventTargetListeners] = n;
                target[kMaxEventTargetListenersWarned] = false;
            } else if (typeof target.setMaxListeners === "function") {
                target.setMaxListeners(n);
            } else {
                throw new ERR_INVALID_ARG_TYPE("eventTargets", [
                    "EventEmitter",
                    "EventTarget"
                ], target);
            }
        }
    }
}
EventEmitter.init = function(opts) {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
    if (opts?.captureRejections) {
        validateBoolean(opts.captureRejections, "options.captureRejections");
        this[kCapture] = Boolean(opts.captureRejections);
    } else {
        this[kCapture] = EventEmitter.prototype[kCapture];
    }
};
function addCatch(that, promise, type, args) {
    if (!that[kCapture]) {
        return;
    }
    try {
        const then = promise.then;
        if (typeof then === "function") {
            then.call(promise, undefined, function(err) {
                process.nextTick(emitUnhandledRejectionOrErr, that, err, type, args);
            });
        }
    } catch (err) {
        that.emit("error", err);
    }
}
function emitUnhandledRejectionOrErr(ee, err, type, args) {
    if (typeof ee[kRejection] === "function") {
        ee[kRejection](err, type, ...args);
    } else {
        const prev = ee[kCapture];
        try {
            ee[kCapture] = false;
            ee.emit("error", err);
        } finally{
            ee[kCapture] = prev;
        }
    }
}
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || Number.isNaN(n)) {
        throw new ERR_OUT_OF_RANGE("n", "a non-negative number", n);
    }
    this._maxListeners = n;
    return this;
};
function _getMaxListeners(that) {
    if (that._maxListeners === undefined) {
        return EventEmitter.defaultMaxListeners;
    }
    return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type, ...args) {
    let doError = type === "error";
    const events = this._events;
    if (events !== undefined) {
        if (doError && events[kErrorMonitor] !== undefined) {
            this.emit(kErrorMonitor, ...args);
        }
        doError = doError && events.error === undefined;
    } else if (!doError) {
        return false;
    }
    if (doError) {
        let er;
        if (args.length > 0) {
            er = args[0];
        }
        if (er instanceof Error) {
            try {
                const capture = {};
                Error.captureStackTrace(capture, EventEmitter.prototype.emit);
            } catch  {}
            throw er;
        }
        let stringifiedEr;
        try {
            stringifiedEr = inspect(er);
        } catch  {
            stringifiedEr = er;
        }
        const err = new ERR_UNHANDLED_ERROR(stringifiedEr);
        err.context = er;
        throw err;
    }
    const handler = events[type];
    if (handler === undefined) {
        return false;
    }
    if (typeof handler === "function") {
        const result = handler.apply(this, args);
        if (result !== undefined && result !== null) {
            addCatch(this, result, type, args);
        }
    } else {
        const len = handler.length;
        const listeners = arrayClone(handler);
        for(let i = 0; i < len; ++i){
            const result = listeners[i].apply(this, args);
            if (result !== undefined && result !== null) {
                addCatch(this, result, type, args);
            }
        }
    }
    return true;
};
function _addListener(target, type, listener, prepend) {
    let m;
    let events;
    let existing;
    checkListener(listener);
    events = target._events;
    if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
    } else {
        if (events.newListener !== undefined) {
            target.emit("newListener", type, listener.listener ?? listener);
            events = target._events;
        }
        existing = events[type];
    }
    if (existing === undefined) {
        events[type] = listener;
        ++target._eventsCount;
    } else {
        if (typeof existing === "function") {
            existing = events[type] = prepend ? [
                listener,
                existing
            ] : [
                existing,
                listener
            ];
        } else if (prepend) {
            existing.unshift(listener);
        } else {
            existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            const w = new Error("Possible EventEmitter memory leak detected. " + `${existing.length} ${String(type)} listeners ` + `added to ${inspect(target, {
                depth: -1
            })}. Use ` + "emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            process.emitWarning(w);
        }
    }
    return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
};
function onceWrapper() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) {
            return this.listener.call(this.target);
        }
        return this.listener.apply(this.target, arguments);
    }
}
function _onceWrap(target, type, listener) {
    const state = {
        fired: false,
        wrapFn: undefined,
        target,
        type,
        listener
    };
    const wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    checkListener(listener);
    const events = this._events;
    if (events === undefined) {
        return this;
    }
    const list = events[type];
    if (list === undefined) {
        return this;
    }
    if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) {
            this._events = Object.create(null);
        } else {
            delete events[type];
            if (events.removeListener) {
                this.emit("removeListener", type, list.listener || listener);
            }
        }
    } else if (typeof list !== "function") {
        let position = -1;
        for(let i = list.length - 1; i >= 0; i--){
            if (list[i] === listener || list[i].listener === listener) {
                position = i;
                break;
            }
        }
        if (position < 0) {
            return this;
        }
        if (position === 0) {
            list.shift();
        } else {
            spliceOne(list, position);
        }
        if (list.length === 1) {
            events[type] = list[0];
        }
        if (events.removeListener !== undefined) {
            this.emit("removeListener", type, listener);
        }
    }
    return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    const events = this._events;
    if (events === undefined) {
        return this;
    }
    if (events.removeListener === undefined) {
        if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
        } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) {
                this._events = Object.create(null);
            } else {
                delete events[type];
            }
        }
        return this;
    }
    if (arguments.length === 0) {
        for (const key of Reflect.ownKeys(events)){
            if (key === "removeListener") continue;
            this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
    }
    const listeners = events[type];
    if (typeof listeners === "function") {
        this.removeListener(type, listeners);
    } else if (listeners !== undefined) {
        for(let i = listeners.length - 1; i >= 0; i--){
            this.removeListener(type, listeners[i]);
        }
    }
    return this;
};
function _listeners(target, type, unwrap) {
    const events = target._events;
    if (events === undefined) {
        return [];
    }
    const evlistener = events[type];
    if (evlistener === undefined) {
        return [];
    }
    if (typeof evlistener === "function") {
        return unwrap ? [
            evlistener.listener || evlistener
        ] : [
            evlistener
        ];
    }
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener);
}
EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
};
const _listenerCount = function listenerCount(type) {
    const events = this._events;
    if (events !== undefined) {
        const evlistener = events[type];
        if (typeof evlistener === "function") {
            return 1;
        } else if (evlistener !== undefined) {
            return evlistener.length;
        }
    }
    return 0;
};
EventEmitter.prototype.listenerCount = _listenerCount;
function listenerCount(emitter, type) {
    if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
    }
    return _listenerCount.call(emitter, type);
}
EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};
function arrayClone(arr) {
    switch(arr.length){
        case 2:
            return [
                arr[0],
                arr[1]
            ];
        case 3:
            return [
                arr[0],
                arr[1],
                arr[2]
            ];
        case 4:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3]
            ];
        case 5:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3],
                arr[4]
            ];
        case 6:
            return [
                arr[0],
                arr[1],
                arr[2],
                arr[3],
                arr[4],
                arr[5]
            ];
    }
    return arr.slice();
}
function unwrapListeners(arr) {
    const ret = arrayClone(arr);
    for(let i = 0; i < ret.length; ++i){
        const orig = ret[i].listener;
        if (typeof orig === "function") {
            ret[i] = orig;
        }
    }
    return ret;
}
function getEventListeners(emitterOrTarget, type) {
    if (typeof emitterOrTarget.listeners === "function") {
        return emitterOrTarget.listeners(type);
    }
    if (emitterOrTarget instanceof EventTarget) {
        const root = emitterOrTarget[kEvents].get(type);
        const listeners = [];
        let handler = root?.next;
        while(handler?.listener !== undefined){
            const listener = handler.listener?.deref ? handler.listener.deref() : handler.listener;
            listeners.push(listener);
            handler = handler.next;
        }
        return listeners;
    }
    throw new ERR_INVALID_ARG_TYPE("emitter", [
        "EventEmitter",
        "EventTarget"
    ], emitterOrTarget);
}
async function once1(emitter, name, options = {}) {
    const signal = options?.signal;
    validateAbortSignal(signal, "options.signal");
    if (signal?.aborted) {
        throw new AbortError();
    }
    return new Promise((resolve, reject)=>{
        const errorListener = (err)=>{
            emitter.removeListener(name, resolver);
            if (signal != null) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
            }
            reject(err);
        };
        const resolver = (...args)=>{
            if (typeof emitter.removeListener === "function") {
                emitter.removeListener("error", errorListener);
            }
            if (signal != null) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener);
            }
            resolve(args);
        };
        eventTargetAgnosticAddListener(emitter, name, resolver, {
            once: true
        });
        if (name !== "error" && typeof emitter.once === "function") {
            emitter.once("error", errorListener);
        }
        function abortListener() {
            eventTargetAgnosticRemoveListener(emitter, name, resolver);
            eventTargetAgnosticRemoveListener(emitter, "error", errorListener);
            reject(new AbortError());
        }
        if (signal != null) {
            eventTargetAgnosticAddListener(signal, "abort", abortListener, {
                once: true
            });
        }
    });
}
const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function*() {}).prototype);
function createIterResult(value, done) {
    return {
        value,
        done
    };
}
function eventTargetAgnosticRemoveListener(emitter, name, listener, flags) {
    if (typeof emitter.removeListener === "function") {
        emitter.removeListener(name, listener);
    } else if (typeof emitter.removeEventListener === "function") {
        emitter.removeEventListener(name, listener, flags);
    } else {
        throw new ERR_INVALID_ARG_TYPE("emitter", "EventEmitter", emitter);
    }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
        if (flags?.once) {
            emitter.once(name, listener);
        } else {
            emitter.on(name, listener);
        }
    } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, (arg)=>{
            listener(arg);
        }, flags);
    } else {
        throw new ERR_INVALID_ARG_TYPE("emitter", "EventEmitter", emitter);
    }
}
function on(emitter, event, options) {
    const signal = options?.signal;
    validateAbortSignal(signal, "options.signal");
    if (signal?.aborted) {
        throw new AbortError();
    }
    const unconsumedEvents = [];
    const unconsumedPromises = [];
    let error = null;
    let finished = false;
    const iterator = Object.setPrototypeOf({
        next () {
            const value = unconsumedEvents.shift();
            if (value) {
                return Promise.resolve(createIterResult(value, false));
            }
            if (error) {
                const p = Promise.reject(error);
                error = null;
                return p;
            }
            if (finished) {
                return Promise.resolve(createIterResult(undefined, true));
            }
            return new Promise(function(resolve, reject) {
                unconsumedPromises.push({
                    resolve,
                    reject
                });
            });
        },
        return () {
            eventTargetAgnosticRemoveListener(emitter, event, eventHandler);
            eventTargetAgnosticRemoveListener(emitter, "error", errorHandler);
            if (signal) {
                eventTargetAgnosticRemoveListener(signal, "abort", abortListener, {
                    once: true
                });
            }
            finished = true;
            for (const promise of unconsumedPromises){
                promise.resolve(createIterResult(undefined, true));
            }
            return Promise.resolve(createIterResult(undefined, true));
        },
        throw (err) {
            if (!err || !(err instanceof Error)) {
                throw new ERR_INVALID_ARG_TYPE("EventEmitter.AsyncIterator", "Error", err);
            }
            error = err;
            eventTargetAgnosticRemoveListener(emitter, event, eventHandler);
            eventTargetAgnosticRemoveListener(emitter, "error", errorHandler);
        },
        [Symbol.asyncIterator] () {
            return this;
        }
    }, AsyncIteratorPrototype);
    eventTargetAgnosticAddListener(emitter, event, eventHandler);
    if (event !== "error" && typeof emitter.on === "function") {
        emitter.on("error", errorHandler);
    }
    if (signal) {
        eventTargetAgnosticAddListener(signal, "abort", abortListener, {
            once: true
        });
    }
    return iterator;
    function abortListener() {
        errorHandler(new AbortError());
    }
    function eventHandler(...args) {
        const promise = unconsumedPromises.shift();
        if (promise) {
            promise.resolve(createIterResult(args, false));
        } else {
            unconsumedEvents.push(args);
        }
    }
    function errorHandler(err) {
        finished = true;
        const toError = unconsumedPromises.shift();
        if (toError) {
            toError.reject(err);
        } else {
            error = err;
        }
        iterator.return();
    }
}
function _arch() {
    if (Deno.build.arch == "x86_64") {
        return "x64";
    } else if (Deno.build.arch == "aarch64") {
        return "arm64";
    } else {
        throw Error("unreachable");
    }
}
const arch = _arch();
const chdir = Deno.chdir;
const cwd = Deno.cwd;
function denoEnvGet(name) {
    try {
        return Deno.env.get(name);
    } catch (e) {
        if (e instanceof TypeError) {
            return undefined;
        }
        throw e;
    }
}
const OBJECT_PROTO_PROP_NAMES = Object.getOwnPropertyNames(Object.prototype);
const env = new Proxy(Object(), {
    get: (target, prop)=>{
        if (typeof prop === "symbol") {
            return target[prop];
        }
        const envValue = denoEnvGet(prop);
        if (envValue) {
            return envValue;
        }
        if (OBJECT_PROTO_PROP_NAMES.includes(prop)) {
            return target[prop];
        }
        return envValue;
    },
    ownKeys: ()=>Reflect.ownKeys(Deno.env.toObject()),
    getOwnPropertyDescriptor: (_target, name)=>{
        const value = denoEnvGet(String(name));
        if (value) {
            return {
                enumerable: true,
                configurable: true,
                value
            };
        }
    },
    set (_target, prop, value) {
        Deno.env.set(String(prop), String(value));
        return true;
    },
    has: (_target, prop)=>typeof denoEnvGet(String(prop)) === "string"
});
const pid = Deno.pid;
const platform = isWindows1 ? "win32" : Deno.build.os;
const version = "v18.12.1";
const versions = {
    node: "18.12.1",
    uv: "1.43.0",
    zlib: "1.2.11",
    brotli: "1.0.9",
    ares: "1.18.1",
    modules: "108",
    nghttp2: "1.47.0",
    napi: "8",
    llhttp: "6.0.10",
    openssl: "3.0.7+quic",
    cldr: "41.0",
    icu: "71.1",
    tz: "2022b",
    unicode: "14.0",
    ngtcp2: "0.8.1",
    nghttp3: "0.7.0",
    ...Deno.version
};
const kDestroy = Symbol("kDestroy");
Symbol("kConstruct");
function checkError(err, w, r) {
    if (err) {
        err.stack;
        if (w && !w.errored) {
            w.errored = err;
        }
        if (r && !r.errored) {
            r.errored = err;
        }
    }
}
function destroy(err, cb) {
    const r = this._readableState;
    const w = this._writableState;
    const s = w || r;
    if (w && w.destroyed || r && r.destroyed) {
        if (typeof cb === "function") {
            cb();
        }
        return this;
    }
    checkError(err, w, r);
    if (w) {
        w.destroyed = true;
    }
    if (r) {
        r.destroyed = true;
    }
    if (!s.constructed) {
        this.once(kDestroy, function(er) {
            _destroy(this, aggregateTwoErrors(er, err), cb);
        });
    } else {
        _destroy(this, err, cb);
    }
    return this;
}
function _destroy(self, err, cb) {
    let called = false;
    function onDestroy(err) {
        if (called) {
            return;
        }
        called = true;
        const r = self._readableState;
        const w = self._writableState;
        checkError(err, w, r);
        if (w) {
            w.closed = true;
        }
        if (r) {
            r.closed = true;
        }
        if (typeof cb === "function") {
            cb(err);
        }
        if (err) {
            nextTick1(emitErrorCloseNT, self, err);
        } else {
            nextTick1(emitCloseNT, self);
        }
    }
    try {
        const result = self._destroy(err || null, onDestroy);
        if (result != null) {
            const then = result.then;
            if (typeof then === "function") {
                then.call(result, function() {
                    nextTick1(onDestroy, null);
                }, function(err) {
                    nextTick1(onDestroy, err);
                });
            }
        }
    } catch (err) {
        onDestroy(err);
    }
}
function emitErrorCloseNT(self, err) {
    emitErrorNT(self, err);
    emitCloseNT(self);
}
function emitCloseNT(self) {
    const r = self._readableState;
    const w = self._writableState;
    if (w) {
        w.closeEmitted = true;
    }
    if (r) {
        r.closeEmitted = true;
    }
    if (w && w.emitClose || r && r.emitClose) {
        self.emit("close");
    }
}
function emitErrorNT(self, err) {
    const r = self._readableState;
    const w = self._writableState;
    if (w && w.errorEmitted || r && r.errorEmitted) {
        return;
    }
    if (w) {
        w.errorEmitted = true;
    }
    if (r) {
        r.errorEmitted = true;
    }
    self.emit("error", err);
}
function errorOrDestroy(stream, err, sync) {
    const r = stream._readableState;
    const w = stream._writableState;
    if (w && w.destroyed || r && r.destroyed) {
        return this;
    }
    if (r && r.autoDestroy || w && w.autoDestroy) {
        stream.destroy(err);
    } else if (err) {
        err.stack;
        if (w && !w.errored) {
            w.errored = err;
        }
        if (r && !r.errored) {
            r.errored = err;
        }
        if (sync) {
            nextTick1(emitErrorNT, stream, err);
        } else {
            emitErrorNT(stream, err);
        }
    }
}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
}
function isServerResponse(stream) {
    return typeof stream._sent100 === "boolean" && typeof stream._removedConnection === "boolean" && typeof stream._removedContLen === "boolean" && typeof stream._removedTE === "boolean" && typeof stream._closed === "boolean";
}
function isReadable(stream) {
    return typeof stream.readable === "boolean" || typeof stream.readableEnded === "boolean" || !!stream._readableState;
}
function isWritable(stream) {
    return typeof stream.writable === "boolean" || typeof stream.writableEnded === "boolean" || !!stream._writableState;
}
function isWritableFinished(stream) {
    if (stream.writableFinished) return true;
    const wState = stream._writableState;
    if (!wState || wState.errored) return false;
    return wState.finished || wState.ended && wState.length === 0;
}
const nop = ()=>{};
function isReadableEnded(stream) {
    if (stream.readableEnded) return true;
    const rState = stream._readableState;
    if (!rState || rState.errored) return false;
    return rState.endEmitted || rState.ended && rState.length === 0;
}
function eos(stream, options, callback) {
    if (arguments.length === 2) {
        callback = options;
        options = {};
    } else if (options == null) {
        options = {};
    } else {
        validateObject(options, "options");
    }
    validateFunction(callback, "callback");
    validateAbortSignal(options.signal, "options.signal");
    callback = once(callback);
    const readable = options.readable || options.readable !== false && isReadable(stream);
    const writable = options.writable || options.writable !== false && isWritable(stream);
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;
    const onlegacyfinish = ()=>{
        if (!stream.writable) onfinish();
    };
    let willEmitClose = isServerResponse(stream) || state && state.autoDestroy && state.emitClose && state.closed === false && isReadable(stream) === readable && isWritable(stream) === writable;
    let writableFinished = stream.writableFinished || wState && wState.finished;
    const onfinish = ()=>{
        writableFinished = true;
        if (stream.destroyed) willEmitClose = false;
        if (willEmitClose && (!stream.readable || readable)) return;
        if (!readable || readableEnded) callback.call(stream);
    };
    let readableEnded = stream.readableEnded || rState && rState.endEmitted;
    const onend = ()=>{
        readableEnded = true;
        if (stream.destroyed) willEmitClose = false;
        if (willEmitClose && (!stream.writable || writable)) return;
        if (!writable || writableFinished) callback.call(stream);
    };
    const onerror = (err)=>{
        callback.call(stream, err);
    };
    const onclose = ()=>{
        if (readable && !readableEnded) {
            if (!isReadableEnded(stream)) {
                return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
            }
        }
        if (writable && !writableFinished) {
            if (!isWritableFinished(stream)) {
                return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());
            }
        }
        callback.call(stream);
    };
    const onrequest = ()=>{
        stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
        stream.on("complete", onfinish);
        if (!willEmitClose) {
            stream.on("abort", onclose);
        }
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
    } else if (writable && !wState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
    }
    if (!willEmitClose && typeof stream.aborted === "boolean") {
        stream.on("aborted", onclose);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (options.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    const closed = !wState && !rState && stream._closed === true || wState && wState.closed || rState && rState.closed || wState && wState.errorEmitted || rState && rState.errorEmitted || rState && stream.req && stream.aborted || (!wState || !willEmitClose || typeof wState.closed !== "boolean") && (!rState || !willEmitClose || typeof rState.closed !== "boolean") && (!writable || wState && wState.finished) && (!readable || rState && rState.endEmitted);
    if (closed) {
        nextTick1(()=>{
            callback();
        });
    }
    const cleanup = ()=>{
        callback = nop;
        stream.removeListener("aborted", onclose);
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
    };
    if (options.signal && !closed) {
        const abort = ()=>{
            const endCallback = callback;
            cleanup();
            endCallback.call(stream, new AbortError());
        };
        if (options.signal.aborted) {
            nextTick1(abort);
        } else {
            const originalCallback = callback;
            callback = once((...args)=>{
                options.signal.removeEventListener("abort", abort);
                originalCallback.apply(stream, args);
            });
            options.signal.addEventListener("abort", abort);
        }
    }
    return cleanup;
}
Symbol("kIsDisturbed");
function isReadableNodeStream(obj) {
    return !!(obj && typeof obj.pipe === "function" && typeof obj.on === "function" && (!obj._writableState || obj._readableState?.readable !== false) && (!obj._writableState || obj._readableState));
}
function isWritableNodeStream(obj) {
    return !!(obj && typeof obj.write === "function" && typeof obj.on === "function" && (!obj._readableState || obj._writableState?.writable !== false));
}
function isNodeStream(obj) {
    return obj && (obj._readableState || obj._writableState || typeof obj.write === "function" && typeof obj.on === "function" || typeof obj.pipe === "function" && typeof obj.on === "function");
}
function isDestroyed(stream) {
    if (!isNodeStream(stream)) return null;
    const wState = stream._writableState;
    const rState = stream._readableState;
    const state = wState || rState;
    return !!(stream.destroyed || state?.destroyed);
}
function isWritableEnded(stream) {
    if (!isWritableNodeStream(stream)) return null;
    if (stream.writableEnded === true) return true;
    const wState = stream._writableState;
    if (wState?.errored) return false;
    if (typeof wState?.ended !== "boolean") return null;
    return wState.ended;
}
function isReadableEnded1(stream) {
    if (!isReadableNodeStream(stream)) return null;
    if (stream.readableEnded === true) return true;
    const rState = stream._readableState;
    if (!rState || rState.errored) return false;
    if (typeof rState?.ended !== "boolean") return null;
    return rState.ended;
}
function isReadableFinished(stream, strict) {
    if (!isReadableNodeStream(stream)) return null;
    const rState = stream._readableState;
    if (rState?.errored) return false;
    if (typeof rState?.endEmitted !== "boolean") return null;
    return !!(rState.endEmitted || strict === false && rState.ended === true && rState.length === 0);
}
function isReadable1(stream) {
    const r = isReadableNodeStream(stream);
    if (r === null || typeof stream?.readable !== "boolean") return null;
    if (isDestroyed(stream)) return false;
    return r && stream.readable && !isReadableFinished(stream);
}
function isWritable1(stream) {
    const r = isWritableNodeStream(stream);
    if (r === null || typeof stream?.writable !== "boolean") return null;
    if (isDestroyed(stream)) return false;
    return r && stream.writable && !isWritableEnded(stream);
}
const __process$ = {
    nextTick: nextTick1,
    stdio
};
var pi = Object.create;
var Bt = Object.defineProperty;
var wi = Object.getOwnPropertyDescriptor;
var yi = Object.getOwnPropertyNames;
var gi = Object.getPrototypeOf, Si = Object.prototype.hasOwnProperty;
((e)=>typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(e, {
        get: (t, n)=>(typeof require < "u" ? require : t)[n]
    }) : e)(function(e) {
    if (typeof require < "u") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + e + '" is not supported');
});
var g = (e, t)=>()=>(t || e((t = {
            exports: {}
        }).exports, t), t.exports);
var Ei = (e, t, n, r)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let i of yi(t))!Si.call(e, i) && i !== n && Bt(e, i, {
        get: ()=>t[i],
        enumerable: !(r = wi(t, i)) || r.enumerable
    });
    return e;
};
var Ri = (e, t, n)=>(n = e != null ? pi(gi(e)) : {}, Ei(t || !e || !e.__esModule ? Bt(n, "default", {
        value: e,
        enumerable: !0
    }) : n, e));
var m = g((Yf, Gt)=>{
    "use strict";
    Gt.exports = {
        ArrayIsArray (e) {
            return Array.isArray(e);
        },
        ArrayPrototypeIncludes (e, t) {
            return e.includes(t);
        },
        ArrayPrototypeIndexOf (e, t) {
            return e.indexOf(t);
        },
        ArrayPrototypeJoin (e, t) {
            return e.join(t);
        },
        ArrayPrototypeMap (e, t) {
            return e.map(t);
        },
        ArrayPrototypePop (e, t) {
            return e.pop(t);
        },
        ArrayPrototypePush (e, t) {
            return e.push(t);
        },
        ArrayPrototypeSlice (e, t, n) {
            return e.slice(t, n);
        },
        Error,
        FunctionPrototypeCall (e, t, ...n) {
            return e.call(t, ...n);
        },
        FunctionPrototypeSymbolHasInstance (e, t) {
            return Function.prototype[Symbol.hasInstance].call(e, t);
        },
        MathFloor: Math.floor,
        Number,
        NumberIsInteger: Number.isInteger,
        NumberIsNaN: Number.isNaN,
        NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
        NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
        NumberParseInt: Number.parseInt,
        ObjectDefineProperties (e, t) {
            return Object.defineProperties(e, t);
        },
        ObjectDefineProperty (e, t, n) {
            return Object.defineProperty(e, t, n);
        },
        ObjectGetOwnPropertyDescriptor (e, t) {
            return Object.getOwnPropertyDescriptor(e, t);
        },
        ObjectKeys (e) {
            return Object.keys(e);
        },
        ObjectSetPrototypeOf (e, t) {
            return Object.setPrototypeOf(e, t);
        },
        Promise,
        PromisePrototypeCatch (e, t) {
            return e.catch(t);
        },
        PromisePrototypeThen (e, t, n) {
            return e.then(t, n);
        },
        PromiseReject (e) {
            return Promise.reject(e);
        },
        ReflectApply: Reflect.apply,
        RegExpPrototypeTest (e, t) {
            return e.test(t);
        },
        SafeSet: Set,
        String,
        StringPrototypeSlice (e, t, n) {
            return e.slice(t, n);
        },
        StringPrototypeToLowerCase (e) {
            return e.toLowerCase();
        },
        StringPrototypeToUpperCase (e) {
            return e.toUpperCase();
        },
        StringPrototypeTrim (e) {
            return e.trim();
        },
        Symbol,
        SymbolAsyncIterator: Symbol.asyncIterator,
        SymbolHasInstance: Symbol.hasInstance,
        SymbolIterator: Symbol.iterator,
        TypedArrayPrototypeSet (e, t, n) {
            return e.set(t, n);
        },
        Uint8Array
    };
});
var j = g((Kf, Je)=>{
    "use strict";
    var Ai = __default3, mi = Object.getPrototypeOf(async function() {}).constructor, Ht = globalThis.Blob || Ai.Blob, Ti = typeof Ht < "u" ? function(t) {
        return t instanceof Ht;
    } : function(t) {
        return !1;
    }, Xe = class extends Error {
        constructor(t){
            if (!Array.isArray(t)) throw new TypeError(`Expected input to be an Array, got ${typeof t}`);
            let n = "";
            for(let r = 0; r < t.length; r++)n += `    ${t[r].stack}
`;
            super(n), this.name = "AggregateError", this.errors = t;
        }
    };
    Je.exports = {
        AggregateError: Xe,
        kEmptyObject: Object.freeze({}),
        once (e) {
            let t = !1;
            return function(...n) {
                t || (t = !0, e.apply(this, n));
            };
        },
        createDeferredPromise: function() {
            let e, t;
            return {
                promise: new Promise((r, i)=>{
                    e = r, t = i;
                }),
                resolve: e,
                reject: t
            };
        },
        promisify (e) {
            return new Promise((t, n)=>{
                e((r, ...i)=>r ? n(r) : t(...i));
            });
        },
        debuglog () {
            return function() {};
        },
        format (e, ...t) {
            return e.replace(/%([sdifj])/g, function(...[n, r]) {
                let i = t.shift();
                return r === "f" ? i.toFixed(6) : r === "j" ? JSON.stringify(i) : r === "s" && typeof i == "object" ? `${i.constructor !== Object ? i.constructor.name : ""} {}`.trim() : i.toString();
            });
        },
        inspect (e) {
            switch(typeof e){
                case "string":
                    if (e.includes("'")) if (e.includes('"')) {
                        if (!e.includes("`") && !e.includes("${")) return `\`${e}\``;
                    } else return `"${e}"`;
                    return `'${e}'`;
                case "number":
                    return isNaN(e) ? "NaN" : Object.is(e, -0) ? String(e) : e;
                case "bigint":
                    return `${String(e)}n`;
                case "boolean":
                case "undefined":
                    return String(e);
                case "object":
                    return "{}";
            }
        },
        types: {
            isAsyncFunction (e) {
                return e instanceof mi;
            },
            isArrayBufferView (e) {
                return ArrayBuffer.isView(e);
            }
        },
        isBlob: Ti
    };
    Je.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom");
});
var O = g((zf, Kt)=>{
    "use strict";
    var { format: Ii , inspect: Re , AggregateError: Mi  } = j(), Ni = globalThis.AggregateError || Mi, Di = Symbol("kIsNodeError"), Oi = [
        "string",
        "function",
        "number",
        "object",
        "Function",
        "Object",
        "boolean",
        "bigint",
        "symbol"
    ], qi = /^([A-Z][a-z0-9]*)+$/, xi = "__node_internal_", Ae = {};
    function X(e, t) {
        if (!e) throw new Ae.ERR_INTERNAL_ASSERTION(t);
    }
    function Vt(e) {
        let t = "", n = e.length, r = e[0] === "-" ? 1 : 0;
        for(; n >= r + 4; n -= 3)t = `_${e.slice(n - 3, n)}${t}`;
        return `${e.slice(0, n)}${t}`;
    }
    function Li(e, t, n) {
        if (typeof t == "function") return X(t.length <= n.length, `Code: ${e}; The provided arguments length (${n.length}) does not match the required ones (${t.length}).`), t(...n);
        let r = (t.match(/%[dfijoOs]/g) || []).length;
        return X(r === n.length, `Code: ${e}; The provided arguments length (${n.length}) does not match the required ones (${r}).`), n.length === 0 ? t : Ii(t, ...n);
    }
    function N(e, t, n) {
        n || (n = Error);
        class r extends n {
            constructor(...o){
                super(Li(e, t, o));
            }
            toString() {
                return `${this.name} [${e}]: ${this.message}`;
            }
        }
        Object.defineProperties(r.prototype, {
            name: {
                value: n.name,
                writable: !0,
                enumerable: !1,
                configurable: !0
            },
            toString: {
                value () {
                    return `${this.name} [${e}]: ${this.message}`;
                },
                writable: !0,
                enumerable: !1,
                configurable: !0
            }
        }), r.prototype.code = e, r.prototype[Di] = !0, Ae[e] = r;
    }
    function Yt(e) {
        let t = xi + e.name;
        return Object.defineProperty(e, "name", {
            value: t
        }), e;
    }
    function Pi(e, t) {
        if (e && t && e !== t) {
            if (Array.isArray(t.errors)) return t.errors.push(e), t;
            let n = new Ni([
                t,
                e
            ], t.message);
            return n.code = t.code, n;
        }
        return e || t;
    }
    var Qe = class extends Error {
        constructor(t = "The operation was aborted", n = void 0){
            if (n !== void 0 && typeof n != "object") throw new Ae.ERR_INVALID_ARG_TYPE("options", "Object", n);
            super(t, n), this.code = "ABORT_ERR", this.name = "AbortError";
        }
    };
    N("ERR_ASSERTION", "%s", Error);
    N("ERR_INVALID_ARG_TYPE", (e, t, n)=>{
        X(typeof e == "string", "'name' must be a string"), Array.isArray(t) || (t = [
            t
        ]);
        let r = "The ";
        e.endsWith(" argument") ? r += `${e} ` : r += `"${e}" ${e.includes(".") ? "property" : "argument"} `, r += "must be ";
        let i = [], o = [], l = [];
        for (let f of t)X(typeof f == "string", "All expected entries have to be of type string"), Oi.includes(f) ? i.push(f.toLowerCase()) : qi.test(f) ? o.push(f) : (X(f !== "object", 'The value "object" should be written as "Object"'), l.push(f));
        if (o.length > 0) {
            let f = i.indexOf("object");
            f !== -1 && (i.splice(i, f, 1), o.push("Object"));
        }
        if (i.length > 0) {
            switch(i.length){
                case 1:
                    r += `of type ${i[0]}`;
                    break;
                case 2:
                    r += `one of type ${i[0]} or ${i[1]}`;
                    break;
                default:
                    {
                        let f = i.pop();
                        r += `one of type ${i.join(", ")}, or ${f}`;
                    }
            }
            (o.length > 0 || l.length > 0) && (r += " or ");
        }
        if (o.length > 0) {
            switch(o.length){
                case 1:
                    r += `an instance of ${o[0]}`;
                    break;
                case 2:
                    r += `an instance of ${o[0]} or ${o[1]}`;
                    break;
                default:
                    {
                        let f = o.pop();
                        r += `an instance of ${o.join(", ")}, or ${f}`;
                    }
            }
            l.length > 0 && (r += " or ");
        }
        switch(l.length){
            case 0:
                break;
            case 1:
                l[0].toLowerCase() !== l[0] && (r += "an "), r += `${l[0]}`;
                break;
            case 2:
                r += `one of ${l[0]} or ${l[1]}`;
                break;
            default:
                {
                    let f = l.pop();
                    r += `one of ${l.join(", ")}, or ${f}`;
                }
        }
        if (n == null) r += `. Received ${n}`;
        else if (typeof n == "function" && n.name) r += `. Received function ${n.name}`;
        else if (typeof n == "object") {
            var u;
            (u = n.constructor) !== null && u !== void 0 && u.name ? r += `. Received an instance of ${n.constructor.name}` : r += `. Received ${Re(n, {
                depth: -1
            })}`;
        } else {
            let f = Re(n, {
                colors: !1
            });
            f.length > 25 && (f = `${f.slice(0, 25)}...`), r += `. Received type ${typeof n} (${f})`;
        }
        return r;
    }, TypeError);
    N("ERR_INVALID_ARG_VALUE", (e, t, n = "is invalid")=>{
        let r = Re(t);
        return r.length > 128 && (r = r.slice(0, 128) + "..."), `The ${e.includes(".") ? "property" : "argument"} '${e}' ${n}. Received ${r}`;
    }, TypeError);
    N("ERR_INVALID_RETURN_VALUE", (e, t, n)=>{
        var r;
        let i = n != null && (r = n.constructor) !== null && r !== void 0 && r.name ? `instance of ${n.constructor.name}` : `type ${typeof n}`;
        return `Expected ${e} to be returned from the "${t}" function but got ${i}.`;
    }, TypeError);
    N("ERR_MISSING_ARGS", (...e)=>{
        X(e.length > 0, "At least one arg needs to be specified");
        let t, n = e.length;
        switch(e = (Array.isArray(e) ? e : [
            e
        ]).map((r)=>`"${r}"`).join(" or "), n){
            case 1:
                t += `The ${e[0]} argument`;
                break;
            case 2:
                t += `The ${e[0]} and ${e[1]} arguments`;
                break;
            default:
                {
                    let r = e.pop();
                    t += `The ${e.join(", ")}, and ${r} arguments`;
                }
                break;
        }
        return `${t} must be specified`;
    }, TypeError);
    N("ERR_OUT_OF_RANGE", (e, t, n)=>{
        X(t, 'Missing "range" argument');
        let r;
        return Number.isInteger(n) && Math.abs(n) > 2 ** 32 ? r = Vt(String(n)) : typeof n == "bigint" ? (r = String(n), (n > 2n ** 32n || n < -(2n ** 32n)) && (r = Vt(r)), r += "n") : r = Re(n), `The value of "${e}" is out of range. It must be ${t}. Received ${r}`;
    }, RangeError);
    N("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error);
    N("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error);
    N("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error);
    N("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error);
    N("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error);
    N("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    N("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error);
    N("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error);
    N("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error);
    N("ERR_STREAM_WRITE_AFTER_END", "write after end", Error);
    N("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError);
    Kt.exports = {
        AbortError: Qe,
        aggregateTwoErrors: Yt(Pi),
        hideStackFrames: Yt,
        codes: Ae
    };
});
var _e = g((Xf, nn)=>{
    "use strict";
    var { ArrayIsArray: Jt , ArrayPrototypeIncludes: Qt , ArrayPrototypeJoin: Zt , ArrayPrototypeMap: ki , NumberIsInteger: et , NumberIsNaN: Wi , NumberMAX_SAFE_INTEGER: Ci , NumberMIN_SAFE_INTEGER: ji , NumberParseInt: $i , ObjectPrototypeHasOwnProperty: vi , RegExpPrototypeExec: Fi , String: Ui , StringPrototypeToUpperCase: Bi , StringPrototypeTrim: Gi  } = m(), { hideStackFrames: k , codes: { ERR_SOCKET_BAD_PORT: Hi , ERR_INVALID_ARG_TYPE: q , ERR_INVALID_ARG_VALUE: me , ERR_OUT_OF_RANGE: J , ERR_UNKNOWN_SIGNAL: zt  }  } = O(), { normalizeEncoding: Vi  } = j(), { isAsyncFunction: Yi , isArrayBufferView: Ki  } = j().types, Xt = {};
    function zi(e) {
        return e === (e | 0);
    }
    function Xi(e) {
        return e === e >>> 0;
    }
    var Ji = /^[0-7]+$/, Qi = "must be a 32-bit unsigned integer or an octal string";
    function Zi(e, t, n) {
        if (typeof e > "u" && (e = n), typeof e == "string") {
            if (Fi(Ji, e) === null) throw new me(t, e, Qi);
            e = $i(e, 8);
        }
        return en(e, t), e;
    }
    var eo = k((e, t, n = ji, r = Ci)=>{
        if (typeof e != "number") throw new q(t, "number", e);
        if (!et(e)) throw new J(t, "an integer", e);
        if (e < n || e > r) throw new J(t, `>= ${n} && <= ${r}`, e);
    }), to = k((e, t, n = -2147483648, r = 2147483647)=>{
        if (typeof e != "number") throw new q(t, "number", e);
        if (!et(e)) throw new J(t, "an integer", e);
        if (e < n || e > r) throw new J(t, `>= ${n} && <= ${r}`, e);
    }), en = k((e, t, n = !1)=>{
        if (typeof e != "number") throw new q(t, "number", e);
        if (!et(e)) throw new J(t, "an integer", e);
        let r = n ? 1 : 0, i = 4294967295;
        if (e < r || e > i) throw new J(t, `>= ${r} && <= ${i}`, e);
    });
    function tn(e, t) {
        if (typeof e != "string") throw new q(t, "string", e);
    }
    function no(e, t, n = void 0, r) {
        if (typeof e != "number") throw new q(t, "number", e);
        if (n != null && e < n || r != null && e > r || (n != null || r != null) && Wi(e)) throw new J(t, `${n != null ? `>= ${n}` : ""}${n != null && r != null ? " && " : ""}${r != null ? `<= ${r}` : ""}`, e);
    }
    var ro = k((e, t, n)=>{
        if (!Qt(n, e)) {
            let r = Zt(ki(n, (o)=>typeof o == "string" ? `'${o}'` : Ui(o)), ", "), i = "must be one of: " + r;
            throw new me(t, e, i);
        }
    });
    function io(e, t) {
        if (typeof e != "boolean") throw new q(t, "boolean", e);
    }
    function Ze(e, t, n) {
        return e == null || !vi(e, t) ? n : e[t];
    }
    var oo = k((e, t, n = null)=>{
        let r = Ze(n, "allowArray", !1), i = Ze(n, "allowFunction", !1);
        if (!Ze(n, "nullable", !1) && e === null || !r && Jt(e) || typeof e != "object" && (!i || typeof e != "function")) throw new q(t, "Object", e);
    }), lo = k((e, t, n = 0)=>{
        if (!Jt(e)) throw new q(t, "Array", e);
        if (e.length < n) {
            let r = `must be longer than ${n}`;
            throw new me(t, e, r);
        }
    });
    function ao(e, t = "signal") {
        if (tn(e, t), Xt[e] === void 0) throw Xt[Bi(e)] !== void 0 ? new zt(e + " (signals must use all capital letters)") : new zt(e);
    }
    var fo = k((e, t = "buffer")=>{
        if (!Ki(e)) throw new q(t, [
            "Buffer",
            "TypedArray",
            "DataView"
        ], e);
    });
    function uo(e, t) {
        let n = Vi(t), r = e.length;
        if (n === "hex" && r % 2 !== 0) throw new me("encoding", t, `is invalid for data of length ${r}`);
    }
    function so(e, t = "Port", n = !0) {
        if (typeof e != "number" && typeof e != "string" || typeof e == "string" && Gi(e).length === 0 || +e !== +e >>> 0 || e > 65535 || e === 0 && !n) throw new Hi(t, e, n);
        return e | 0;
    }
    var co = k((e, t)=>{
        if (e !== void 0 && (e === null || typeof e != "object" || !("aborted" in e))) throw new q(t, "AbortSignal", e);
    }), ho = k((e, t)=>{
        if (typeof e != "function") throw new q(t, "Function", e);
    }), bo = k((e, t)=>{
        if (typeof e != "function" || Yi(e)) throw new q(t, "Function", e);
    }), _o = k((e, t)=>{
        if (e !== void 0) throw new q(t, "undefined", e);
    });
    function po(e, t, n) {
        if (!Qt(n, e)) throw new q(t, `('${Zt(n, "|")}')`, e);
    }
    nn.exports = {
        isInt32: zi,
        isUint32: Xi,
        parseFileMode: Zi,
        validateArray: lo,
        validateBoolean: io,
        validateBuffer: fo,
        validateEncoding: uo,
        validateFunction: ho,
        validateInt32: to,
        validateInteger: eo,
        validateNumber: no,
        validateObject: oo,
        validateOneOf: ro,
        validatePlainFunction: bo,
        validatePort: so,
        validateSignalName: ao,
        validateString: tn,
        validateUint32: en,
        validateUndefined: _o,
        validateUnion: po,
        validateAbortSignal: co
    };
});
var V = g((Jf, _n)=>{
    "use strict";
    var { Symbol: Te , SymbolAsyncIterator: rn , SymbolIterator: on  } = m(), ln = Te("kDestroyed"), an = Te("kIsErrored"), tt = Te("kIsReadable"), fn = Te("kIsDisturbed");
    function Ie(e, t = !1) {
        var n;
        return !!(e && typeof e.pipe == "function" && typeof e.on == "function" && (!t || typeof e.pause == "function" && typeof e.resume == "function") && (!e._writableState || ((n = e._readableState) === null || n === void 0 ? void 0 : n.readable) !== !1) && (!e._writableState || e._readableState));
    }
    function Me(e) {
        var t;
        return !!(e && typeof e.write == "function" && typeof e.on == "function" && (!e._readableState || ((t = e._writableState) === null || t === void 0 ? void 0 : t.writable) !== !1));
    }
    function wo(e) {
        return !!(e && typeof e.pipe == "function" && e._readableState && typeof e.on == "function" && typeof e.write == "function");
    }
    function Q(e) {
        return e && (e._readableState || e._writableState || typeof e.write == "function" && typeof e.on == "function" || typeof e.pipe == "function" && typeof e.on == "function");
    }
    function yo(e, t) {
        return e == null ? !1 : t === !0 ? typeof e[rn] == "function" : t === !1 ? typeof e[on] == "function" : typeof e[rn] == "function" || typeof e[on] == "function";
    }
    function Ne(e) {
        if (!Q(e)) return null;
        let t = e._writableState, n = e._readableState, r = t || n;
        return !!(e.destroyed || e[ln] || r != null && r.destroyed);
    }
    function un(e) {
        if (!Me(e)) return null;
        if (e.writableEnded === !0) return !0;
        let t = e._writableState;
        return t != null && t.errored ? !1 : typeof t?.ended != "boolean" ? null : t.ended;
    }
    function go(e, t) {
        if (!Me(e)) return null;
        if (e.writableFinished === !0) return !0;
        let n = e._writableState;
        return n != null && n.errored ? !1 : typeof n?.finished != "boolean" ? null : !!(n.finished || t === !1 && n.ended === !0 && n.length === 0);
    }
    function So(e) {
        if (!Ie(e)) return null;
        if (e.readableEnded === !0) return !0;
        let t = e._readableState;
        return !t || t.errored ? !1 : typeof t?.ended != "boolean" ? null : t.ended;
    }
    function sn(e, t) {
        if (!Ie(e)) return null;
        let n = e._readableState;
        return n != null && n.errored ? !1 : typeof n?.endEmitted != "boolean" ? null : !!(n.endEmitted || t === !1 && n.ended === !0 && n.length === 0);
    }
    function dn(e) {
        return e && e[tt] != null ? e[tt] : typeof e?.readable != "boolean" ? null : Ne(e) ? !1 : Ie(e) && e.readable && !sn(e);
    }
    function cn(e) {
        return typeof e?.writable != "boolean" ? null : Ne(e) ? !1 : Me(e) && e.writable && !un(e);
    }
    function Eo(e, t) {
        return Q(e) ? Ne(e) ? !0 : !(t?.readable !== !1 && dn(e) || t?.writable !== !1 && cn(e)) : null;
    }
    function Ro(e) {
        var t, n;
        return Q(e) ? e.writableErrored ? e.writableErrored : (t = (n = e._writableState) === null || n === void 0 ? void 0 : n.errored) !== null && t !== void 0 ? t : null : null;
    }
    function Ao(e) {
        var t, n;
        return Q(e) ? e.readableErrored ? e.readableErrored : (t = (n = e._readableState) === null || n === void 0 ? void 0 : n.errored) !== null && t !== void 0 ? t : null : null;
    }
    function mo(e) {
        if (!Q(e)) return null;
        if (typeof e.closed == "boolean") return e.closed;
        let t = e._writableState, n = e._readableState;
        return typeof t?.closed == "boolean" || typeof n?.closed == "boolean" ? t?.closed || n?.closed : typeof e._closed == "boolean" && hn(e) ? e._closed : null;
    }
    function hn(e) {
        return typeof e._closed == "boolean" && typeof e._defaultKeepAlive == "boolean" && typeof e._removedConnection == "boolean" && typeof e._removedContLen == "boolean";
    }
    function bn(e) {
        return typeof e._sent100 == "boolean" && hn(e);
    }
    function To(e) {
        var t;
        return typeof e._consuming == "boolean" && typeof e._dumped == "boolean" && ((t = e.req) === null || t === void 0 ? void 0 : t.upgradeOrConnect) === void 0;
    }
    function Io(e) {
        if (!Q(e)) return null;
        let t = e._writableState, n = e._readableState, r = t || n;
        return !r && bn(e) || !!(r && r.autoDestroy && r.emitClose && r.closed === !1);
    }
    function Mo(e) {
        var t;
        return !!(e && ((t = e[fn]) !== null && t !== void 0 ? t : e.readableDidRead || e.readableAborted));
    }
    function No(e) {
        var t, n, r, i, o, l, u, f, a, c;
        return !!(e && ((t = (n = (r = (i = (o = (l = e[an]) !== null && l !== void 0 ? l : e.readableErrored) !== null && o !== void 0 ? o : e.writableErrored) !== null && i !== void 0 ? i : (u = e._readableState) === null || u === void 0 ? void 0 : u.errorEmitted) !== null && r !== void 0 ? r : (f = e._writableState) === null || f === void 0 ? void 0 : f.errorEmitted) !== null && n !== void 0 ? n : (a = e._readableState) === null || a === void 0 ? void 0 : a.errored) !== null && t !== void 0 ? t : (c = e._writableState) === null || c === void 0 ? void 0 : c.errored));
    }
    _n.exports = {
        kDestroyed: ln,
        isDisturbed: Mo,
        kIsDisturbed: fn,
        isErrored: No,
        kIsErrored: an,
        isReadable: dn,
        kIsReadable: tt,
        isClosed: mo,
        isDestroyed: Ne,
        isDuplexNodeStream: wo,
        isFinished: Eo,
        isIterable: yo,
        isReadableNodeStream: Ie,
        isReadableEnded: So,
        isReadableFinished: sn,
        isReadableErrored: Ao,
        isNodeStream: Q,
        isWritable: cn,
        isWritableNodeStream: Me,
        isWritableEnded: un,
        isWritableFinished: go,
        isWritableErrored: Ro,
        isServerRequest: To,
        isServerResponse: bn,
        willEmitClose: Io
    };
});
var Y = g((Qf, rt)=>{
    var oe = __process$, { AbortError: Do , codes: Oo  } = O(), { ERR_INVALID_ARG_TYPE: qo , ERR_STREAM_PREMATURE_CLOSE: pn  } = Oo, { kEmptyObject: wn , once: yn  } = j(), { validateAbortSignal: xo , validateFunction: Lo , validateObject: Po  } = _e(), { Promise: ko  } = m(), { isClosed: Wo , isReadable: gn , isReadableNodeStream: nt , isReadableFinished: Sn , isReadableErrored: Co , isWritable: En , isWritableNodeStream: Rn , isWritableFinished: An , isWritableErrored: jo , isNodeStream: $o , willEmitClose: vo  } = V();
    function Fo(e) {
        return e.setHeader && typeof e.abort == "function";
    }
    var Uo = ()=>{};
    function mn(e, t, n) {
        var r, i;
        arguments.length === 2 ? (n = t, t = wn) : t == null ? t = wn : Po(t, "options"), Lo(n, "callback"), xo(t.signal, "options.signal"), n = yn(n);
        let o = (r = t.readable) !== null && r !== void 0 ? r : nt(e), l = (i = t.writable) !== null && i !== void 0 ? i : Rn(e);
        if (!$o(e)) throw new qo("stream", "Stream", e);
        let u = e._writableState, f = e._readableState, a = ()=>{
            e.writable || b();
        }, c = vo(e) && nt(e) === o && Rn(e) === l, s = An(e, !1), b = ()=>{
            s = !0, e.destroyed && (c = !1), !(c && (!e.readable || o)) && (!o || d) && n.call(e);
        }, d = Sn(e, !1), h = ()=>{
            d = !0, e.destroyed && (c = !1), !(c && (!e.writable || l)) && (!l || s) && n.call(e);
        }, D = (M)=>{
            n.call(e, M);
        }, L = Wo(e), _ = ()=>{
            L = !0;
            let M = jo(e) || Co(e);
            if (M && typeof M != "boolean") return n.call(e, M);
            if (o && !d && nt(e, !0) && !Sn(e, !1)) return n.call(e, new pn);
            if (l && !s && !An(e, !1)) return n.call(e, new pn);
            n.call(e);
        }, p = ()=>{
            e.req.on("finish", b);
        };
        Fo(e) ? (e.on("complete", b), c || e.on("abort", _), e.req ? p() : e.on("request", p)) : l && !u && (e.on("end", a), e.on("close", a)), !c && typeof e.aborted == "boolean" && e.on("aborted", _), e.on("end", h), e.on("finish", b), t.error !== !1 && e.on("error", D), e.on("close", _), L ? oe.nextTick(_) : u != null && u.errorEmitted || f != null && f.errorEmitted ? c || oe.nextTick(_) : (!o && (!c || gn(e)) && (s || En(e) === !1) || !l && (!c || En(e)) && (d || gn(e) === !1) || f && e.req && e.aborted) && oe.nextTick(_);
        let I = ()=>{
            n = Uo, e.removeListener("aborted", _), e.removeListener("complete", b), e.removeListener("abort", _), e.removeListener("request", p), e.req && e.req.removeListener("finish", b), e.removeListener("end", a), e.removeListener("close", a), e.removeListener("finish", b), e.removeListener("end", h), e.removeListener("error", D), e.removeListener("close", _);
        };
        if (t.signal && !L) {
            let M = ()=>{
                let F = n;
                I(), F.call(e, new Do(void 0, {
                    cause: t.signal.reason
                }));
            };
            if (t.signal.aborted) oe.nextTick(M);
            else {
                let F = n;
                n = yn((...re)=>{
                    t.signal.removeEventListener("abort", M), F.apply(e, re);
                }), t.signal.addEventListener("abort", M);
            }
        }
        return I;
    }
    function Bo(e, t) {
        return new ko((n, r)=>{
            mn(e, t, (i)=>{
                i ? r(i) : n();
            });
        });
    }
    rt.exports = mn;
    rt.exports.finished = Bo;
});
var xn = g((Zf, lt)=>{
    "use strict";
    var Nn = globalThis.AbortController, { codes: { ERR_INVALID_ARG_TYPE: pe , ERR_MISSING_ARGS: Go , ERR_OUT_OF_RANGE: Ho  } , AbortError: $  } = O(), { validateAbortSignal: le , validateInteger: Vo , validateObject: ae  } = _e(), Yo = m().Symbol("kWeak"), { finished: Ko  } = Y(), { ArrayPrototypePush: zo , MathFloor: Xo , Number: Jo , NumberIsNaN: Qo , Promise: Tn , PromiseReject: In , PromisePrototypeThen: Zo , Symbol: Dn  } = m(), De = Dn("kEmpty"), Mn = Dn("kEof");
    function Oe(e, t) {
        if (typeof e != "function") throw new pe("fn", [
            "Function",
            "AsyncFunction"
        ], e);
        t != null && ae(t, "options"), t?.signal != null && le(t.signal, "options.signal");
        let n = 1;
        return t?.concurrency != null && (n = Xo(t.concurrency)), Vo(n, "concurrency", 1), (async function*() {
            var i, o;
            let l = new Nn, u = this, f = [], a = l.signal, c = {
                signal: a
            }, s = ()=>l.abort();
            t != null && (i = t.signal) !== null && i !== void 0 && i.aborted && s(), t == null || (o = t.signal) === null || o === void 0 || o.addEventListener("abort", s);
            let b, d, h = !1;
            function D() {
                h = !0;
            }
            async function L() {
                try {
                    for await (let I of u){
                        var _;
                        if (h) return;
                        if (a.aborted) throw new $;
                        try {
                            I = e(I, c);
                        } catch (M) {
                            I = In(M);
                        }
                        I !== De && (typeof ((_ = I) === null || _ === void 0 ? void 0 : _.catch) == "function" && I.catch(D), f.push(I), b && (b(), b = null), !h && f.length && f.length >= n && await new Tn((M)=>{
                            d = M;
                        }));
                    }
                    f.push(Mn);
                } catch (I) {
                    let M = In(I);
                    Zo(M, void 0, D), f.push(M);
                } finally{
                    var p;
                    h = !0, b && (b(), b = null), t == null || (p = t.signal) === null || p === void 0 || p.removeEventListener("abort", s);
                }
            }
            L();
            try {
                for(;;){
                    for(; f.length > 0;){
                        let _ = await f[0];
                        if (_ === Mn) return;
                        if (a.aborted) throw new $;
                        _ !== De && (yield _), f.shift(), d && (d(), d = null);
                    }
                    await new Tn((_)=>{
                        b = _;
                    });
                }
            } finally{
                l.abort(), h = !0, d && (d(), d = null);
            }
        }).call(this);
    }
    function el(e = void 0) {
        return e != null && ae(e, "options"), e?.signal != null && le(e.signal, "options.signal"), (async function*() {
            let n = 0;
            for await (let i of this){
                var r;
                if (e != null && (r = e.signal) !== null && r !== void 0 && r.aborted) throw new $({
                    cause: e.signal.reason
                });
                yield [
                    n++,
                    i
                ];
            }
        }).call(this);
    }
    async function On(e, t = void 0) {
        for await (let n of ot.call(this, e, t))return !0;
        return !1;
    }
    async function tl(e, t = void 0) {
        if (typeof e != "function") throw new pe("fn", [
            "Function",
            "AsyncFunction"
        ], e);
        return !await On.call(this, async (...n)=>!await e(...n), t);
    }
    async function nl(e, t) {
        for await (let n of ot.call(this, e, t))return n;
    }
    async function rl(e, t) {
        if (typeof e != "function") throw new pe("fn", [
            "Function",
            "AsyncFunction"
        ], e);
        async function n(r, i) {
            return await e(r, i), De;
        }
        for await (let r of Oe.call(this, n, t));
    }
    function ot(e, t) {
        if (typeof e != "function") throw new pe("fn", [
            "Function",
            "AsyncFunction"
        ], e);
        async function n(r, i) {
            return await e(r, i) ? r : De;
        }
        return Oe.call(this, n, t);
    }
    var it = class extends Go {
        constructor(){
            super("reduce"), this.message = "Reduce of an empty stream requires an initial value";
        }
    };
    async function il(e, t, n) {
        var r;
        if (typeof e != "function") throw new pe("reducer", [
            "Function",
            "AsyncFunction"
        ], e);
        n != null && ae(n, "options"), n?.signal != null && le(n.signal, "options.signal");
        let i = arguments.length > 1;
        if (n != null && (r = n.signal) !== null && r !== void 0 && r.aborted) {
            let a = new $(void 0, {
                cause: n.signal.reason
            });
            throw this.once("error", ()=>{}), await Ko(this.destroy(a)), a;
        }
        let o = new Nn, l = o.signal;
        if (n != null && n.signal) {
            let a = {
                once: !0,
                [Yo]: this
            };
            n.signal.addEventListener("abort", ()=>o.abort(), a);
        }
        let u = !1;
        try {
            for await (let a of this){
                var f;
                if (u = !0, n != null && (f = n.signal) !== null && f !== void 0 && f.aborted) throw new $;
                i ? t = await e(t, a, {
                    signal: l
                }) : (t = a, i = !0);
            }
            if (!u && !i) throw new it;
        } finally{
            o.abort();
        }
        return t;
    }
    async function ol(e) {
        e != null && ae(e, "options"), e?.signal != null && le(e.signal, "options.signal");
        let t = [];
        for await (let r of this){
            var n;
            if (e != null && (n = e.signal) !== null && n !== void 0 && n.aborted) throw new $(void 0, {
                cause: e.signal.reason
            });
            zo(t, r);
        }
        return t;
    }
    function ll(e, t) {
        let n = Oe.call(this, e, t);
        return (async function*() {
            for await (let i of n)yield* i;
        }).call(this);
    }
    function qn(e) {
        if (e = Jo(e), Qo(e)) return 0;
        if (e < 0) throw new Ho("number", ">= 0", e);
        return e;
    }
    function al(e, t = void 0) {
        return t != null && ae(t, "options"), t?.signal != null && le(t.signal, "options.signal"), e = qn(e), (async function*() {
            var r;
            if (t != null && (r = t.signal) !== null && r !== void 0 && r.aborted) throw new $;
            for await (let o of this){
                var i;
                if (t != null && (i = t.signal) !== null && i !== void 0 && i.aborted) throw new $;
                e-- <= 0 && (yield o);
            }
        }).call(this);
    }
    function fl(e, t = void 0) {
        return t != null && ae(t, "options"), t?.signal != null && le(t.signal, "options.signal"), e = qn(e), (async function*() {
            var r;
            if (t != null && (r = t.signal) !== null && r !== void 0 && r.aborted) throw new $;
            for await (let o of this){
                var i;
                if (t != null && (i = t.signal) !== null && i !== void 0 && i.aborted) throw new $;
                if (e-- > 0) yield o;
                else return;
            }
        }).call(this);
    }
    lt.exports.streamReturningOperators = {
        asIndexedPairs: el,
        drop: al,
        filter: ot,
        flatMap: ll,
        map: Oe,
        take: fl
    };
    lt.exports.promiseReturningOperators = {
        every: tl,
        forEach: rl,
        reduce: il,
        toArray: ol,
        some: On,
        find: nl
    };
});
var Z = g((eu, vn)=>{
    "use strict";
    var K = __process$, { aggregateTwoErrors: ul , codes: { ERR_MULTIPLE_CALLBACK: sl  } , AbortError: dl  } = O(), { Symbol: kn  } = m(), { kDestroyed: cl , isDestroyed: hl , isFinished: bl , isServerRequest: _l  } = V(), Wn = kn("kDestroy"), at = kn("kConstruct");
    function Cn(e, t, n) {
        e && (e.stack, t && !t.errored && (t.errored = e), n && !n.errored && (n.errored = e));
    }
    function pl(e, t) {
        let n = this._readableState, r = this._writableState, i = r || n;
        return r && r.destroyed || n && n.destroyed ? (typeof t == "function" && t(), this) : (Cn(e, r, n), r && (r.destroyed = !0), n && (n.destroyed = !0), i.constructed ? Ln(this, e, t) : this.once(Wn, function(o) {
            Ln(this, ul(o, e), t);
        }), this);
    }
    function Ln(e, t, n) {
        let r = !1;
        function i(o) {
            if (r) return;
            r = !0;
            let l = e._readableState, u = e._writableState;
            Cn(o, u, l), u && (u.closed = !0), l && (l.closed = !0), typeof n == "function" && n(o), o ? K.nextTick(wl, e, o) : K.nextTick(jn, e);
        }
        try {
            e._destroy(t || null, i);
        } catch (o) {
            i(o);
        }
    }
    function wl(e, t) {
        ft(e, t), jn(e);
    }
    function jn(e) {
        let t = e._readableState, n = e._writableState;
        n && (n.closeEmitted = !0), t && (t.closeEmitted = !0), (n && n.emitClose || t && t.emitClose) && e.emit("close");
    }
    function ft(e, t) {
        let n = e._readableState, r = e._writableState;
        r && r.errorEmitted || n && n.errorEmitted || (r && (r.errorEmitted = !0), n && (n.errorEmitted = !0), e.emit("error", t));
    }
    function yl() {
        let e = this._readableState, t = this._writableState;
        e && (e.constructed = !0, e.closed = !1, e.closeEmitted = !1, e.destroyed = !1, e.errored = null, e.errorEmitted = !1, e.reading = !1, e.ended = e.readable === !1, e.endEmitted = e.readable === !1), t && (t.constructed = !0, t.destroyed = !1, t.closed = !1, t.closeEmitted = !1, t.errored = null, t.errorEmitted = !1, t.finalCalled = !1, t.prefinished = !1, t.ended = t.writable === !1, t.ending = t.writable === !1, t.finished = t.writable === !1);
    }
    function ut(e, t, n) {
        let r = e._readableState, i = e._writableState;
        if (i && i.destroyed || r && r.destroyed) return this;
        r && r.autoDestroy || i && i.autoDestroy ? e.destroy(t) : t && (t.stack, i && !i.errored && (i.errored = t), r && !r.errored && (r.errored = t), n ? K.nextTick(ft, e, t) : ft(e, t));
    }
    function gl(e, t) {
        if (typeof e._construct != "function") return;
        let n = e._readableState, r = e._writableState;
        n && (n.constructed = !1), r && (r.constructed = !1), e.once(at, t), !(e.listenerCount(at) > 1) && K.nextTick(Sl, e);
    }
    function Sl(e) {
        let t = !1;
        function n(r) {
            if (t) {
                ut(e, r ?? new sl);
                return;
            }
            t = !0;
            let i = e._readableState, o = e._writableState, l = o || i;
            i && (i.constructed = !0), o && (o.constructed = !0), l.destroyed ? e.emit(Wn, r) : r ? ut(e, r, !0) : K.nextTick(El, e);
        }
        try {
            e._construct(n);
        } catch (r) {
            n(r);
        }
    }
    function El(e) {
        e.emit(at);
    }
    function Pn(e) {
        return e && e.setHeader && typeof e.abort == "function";
    }
    function $n(e) {
        e.emit("close");
    }
    function Rl(e, t) {
        e.emit("error", t), K.nextTick($n, e);
    }
    function Al(e, t) {
        !e || hl(e) || (!t && !bl(e) && (t = new dl), _l(e) ? (e.socket = null, e.destroy(t)) : Pn(e) ? e.abort() : Pn(e.req) ? e.req.abort() : typeof e.destroy == "function" ? e.destroy(t) : typeof e.close == "function" ? e.close() : t ? K.nextTick(Rl, e, t) : K.nextTick($n, e), e.destroyed || (e[cl] = !0));
    }
    vn.exports = {
        construct: gl,
        destroyer: Al,
        destroy: pl,
        undestroy: yl,
        errorOrDestroy: ut
    };
});
var Le = g((tu, Un)=>{
    "use strict";
    var { ArrayIsArray: ml , ObjectSetPrototypeOf: Fn  } = m(), { EventEmitter: qe  } = EventEmitter;
    function xe(e) {
        qe.call(this, e);
    }
    Fn(xe.prototype, qe.prototype);
    Fn(xe, qe);
    xe.prototype.pipe = function(e, t) {
        let n = this;
        function r(c) {
            e.writable && e.write(c) === !1 && n.pause && n.pause();
        }
        n.on("data", r);
        function i() {
            n.readable && n.resume && n.resume();
        }
        e.on("drain", i), !e._isStdio && (!t || t.end !== !1) && (n.on("end", l), n.on("close", u));
        let o = !1;
        function l() {
            o || (o = !0, e.end());
        }
        function u() {
            o || (o = !0, typeof e.destroy == "function" && e.destroy());
        }
        function f(c) {
            a(), qe.listenerCount(this, "error") === 0 && this.emit("error", c);
        }
        st(n, "error", f), st(e, "error", f);
        function a() {
            n.removeListener("data", r), e.removeListener("drain", i), n.removeListener("end", l), n.removeListener("close", u), n.removeListener("error", f), e.removeListener("error", f), n.removeListener("end", a), n.removeListener("close", a), e.removeListener("close", a);
        }
        return n.on("end", a), n.on("close", a), e.on("close", a), e.emit("pipe", n), e;
    };
    function st(e, t, n) {
        if (typeof e.prependListener == "function") return e.prependListener(t, n);
        !e._events || !e._events[t] ? e.on(t, n) : ml(e._events[t]) ? e._events[t].unshift(n) : e._events[t] = [
            n,
            e._events[t]
        ];
    }
    Un.exports = {
        Stream: xe,
        prependListener: st
    };
});
var ke = g((nu, Pe)=>{
    "use strict";
    var { AbortError: Tl , codes: Il  } = O(), Ml = Y(), { ERR_INVALID_ARG_TYPE: Bn  } = Il, Nl = (e, t)=>{
        if (typeof e != "object" || !("aborted" in e)) throw new Bn(t, "AbortSignal", e);
    };
    function Dl(e) {
        return !!(e && typeof e.pipe == "function");
    }
    Pe.exports.addAbortSignal = function(t, n) {
        if (Nl(t, "signal"), !Dl(n)) throw new Bn("stream", "stream.Stream", n);
        return Pe.exports.addAbortSignalNoValidate(t, n);
    };
    Pe.exports.addAbortSignalNoValidate = function(e, t) {
        if (typeof e != "object" || !("aborted" in e)) return t;
        let n = ()=>{
            t.destroy(new Tl(void 0, {
                cause: e.reason
            }));
        };
        return e.aborted ? n() : (e.addEventListener("abort", n), Ml(t, ()=>e.removeEventListener("abort", n))), t;
    };
});
var Vn = g((iu, Hn)=>{
    "use strict";
    var { StringPrototypeSlice: Gn , SymbolIterator: Ol , TypedArrayPrototypeSet: We , Uint8Array: ql  } = m(), { Buffer: dt  } = __default3, { inspect: xl  } = j();
    Hn.exports = class {
        constructor(){
            this.head = null, this.tail = null, this.length = 0;
        }
        push(t) {
            let n = {
                data: t,
                next: null
            };
            this.length > 0 ? this.tail.next = n : this.head = n, this.tail = n, ++this.length;
        }
        unshift(t) {
            let n = {
                data: t,
                next: this.head
            };
            this.length === 0 && (this.tail = n), this.head = n, ++this.length;
        }
        shift() {
            if (this.length === 0) return;
            let t = this.head.data;
            return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, t;
        }
        clear() {
            this.head = this.tail = null, this.length = 0;
        }
        join(t) {
            if (this.length === 0) return "";
            let n = this.head, r = "" + n.data;
            for(; (n = n.next) !== null;)r += t + n.data;
            return r;
        }
        concat(t) {
            if (this.length === 0) return dt.alloc(0);
            let n = dt.allocUnsafe(t >>> 0), r = this.head, i = 0;
            for(; r;)We(n, r.data, i), i += r.data.length, r = r.next;
            return n;
        }
        consume(t, n) {
            let r = this.head.data;
            if (t < r.length) {
                let i = r.slice(0, t);
                return this.head.data = r.slice(t), i;
            }
            return t === r.length ? this.shift() : n ? this._getString(t) : this._getBuffer(t);
        }
        first() {
            return this.head.data;
        }
        *[Ol]() {
            for(let t = this.head; t; t = t.next)yield t.data;
        }
        _getString(t) {
            let n = "", r = this.head, i = 0;
            do {
                let o = r.data;
                if (t > o.length) n += o, t -= o.length;
                else {
                    t === o.length ? (n += o, ++i, r.next ? this.head = r.next : this.head = this.tail = null) : (n += Gn(o, 0, t), this.head = r, r.data = Gn(o, t));
                    break;
                }
                ++i;
            }while ((r = r.next) !== null)
            return this.length -= i, n;
        }
        _getBuffer(t) {
            let n = dt.allocUnsafe(t), r = t, i = this.head, o = 0;
            do {
                let l = i.data;
                if (t > l.length) We(n, l, r - t), t -= l.length;
                else {
                    t === l.length ? (We(n, l, r - t), ++o, i.next ? this.head = i.next : this.head = this.tail = null) : (We(n, new ql(l.buffer, l.byteOffset, t), r - t), this.head = i, i.data = l.slice(t));
                    break;
                }
                ++o;
            }while ((i = i.next) !== null)
            return this.length -= o, n;
        }
        [Symbol.for("nodejs.util.inspect.custom")](t, n) {
            return xl(this, {
                ...n,
                depth: 0,
                customInspect: !1
            });
        }
    };
});
var Ce = g((ou, Kn)=>{
    "use strict";
    var { MathFloor: Ll , NumberIsInteger: Pl  } = m(), { ERR_INVALID_ARG_VALUE: kl  } = O().codes;
    function Wl(e, t, n) {
        return e.highWaterMark != null ? e.highWaterMark : t ? e[n] : null;
    }
    function Yn(e) {
        return e ? 16 : 16 * 1024;
    }
    function Cl(e, t, n, r) {
        let i = Wl(t, r, n);
        if (i != null) {
            if (!Pl(i) || i < 0) {
                let o = r ? `options.${n}` : "options.highWaterMark";
                throw new kl(o, i);
            }
            return Ll(i);
        }
        return Yn(e.objectMode);
    }
    Kn.exports = {
        getHighWaterMark: Cl,
        getDefaultHighWaterMark: Yn
    };
});
var ct = g((lu, Qn)=>{
    "use strict";
    var zn = __process$, { PromisePrototypeThen: jl , SymbolAsyncIterator: Xn , SymbolIterator: Jn  } = m(), { Buffer: $l  } = __default3, { ERR_INVALID_ARG_TYPE: vl , ERR_STREAM_NULL_VALUES: Fl  } = O().codes;
    function Ul(e, t, n) {
        let r;
        if (typeof t == "string" || t instanceof $l) return new e({
            objectMode: !0,
            ...n,
            read () {
                this.push(t), this.push(null);
            }
        });
        let i;
        if (t && t[Xn]) i = !0, r = t[Xn]();
        else if (t && t[Jn]) i = !1, r = t[Jn]();
        else throw new vl("iterable", [
            "Iterable"
        ], t);
        let o = new e({
            objectMode: !0,
            highWaterMark: 1,
            ...n
        }), l = !1;
        o._read = function() {
            l || (l = !0, f());
        }, o._destroy = function(a, c) {
            jl(u(a), ()=>zn.nextTick(c, a), (s)=>zn.nextTick(c, s || a));
        };
        async function u(a) {
            let c = a != null, s = typeof r.throw == "function";
            if (c && s) {
                let { value: b , done: d  } = await r.throw(a);
                if (await b, d) return;
            }
            if (typeof r.return == "function") {
                let { value: b  } = await r.return();
                await b;
            }
        }
        async function f() {
            for(;;){
                try {
                    let { value: a , done: c  } = i ? await r.next() : r.next();
                    if (c) o.push(null);
                    else {
                        let s = a && typeof a.then == "function" ? await a : a;
                        if (s === null) throw l = !1, new Fl;
                        if (o.push(s)) continue;
                        l = !1;
                    }
                } catch (a) {
                    o.destroy(a);
                }
                break;
            }
        }
        return o;
    }
    Qn.exports = Ul;
});
var we = g((au, dr)=>{
    var W = __process$, { ArrayPrototypeIndexOf: Bl , NumberIsInteger: Gl , NumberIsNaN: Hl , NumberParseInt: Vl , ObjectDefineProperties: tr , ObjectKeys: Yl , ObjectSetPrototypeOf: nr , Promise: Kl , SafeSet: zl , SymbolAsyncIterator: Xl , Symbol: Jl  } = m();
    dr.exports = w;
    w.ReadableState = yt;
    var { EventEmitter: Ql  } = EventEmitter, { Stream: z , prependListener: Zl  } = Le(), { Buffer: ht  } = __default3, { addAbortSignal: ea  } = ke(), ta = Y(), y = j().debuglog("stream", (e)=>{
        y = e;
    }), na = Vn(), ue = Z(), { getHighWaterMark: ra , getDefaultHighWaterMark: ia  } = Ce(), { aggregateTwoErrors: Zn , codes: { ERR_INVALID_ARG_TYPE: oa , ERR_METHOD_NOT_IMPLEMENTED: la , ERR_OUT_OF_RANGE: aa , ERR_STREAM_PUSH_AFTER_EOF: fa , ERR_STREAM_UNSHIFT_AFTER_END_EVENT: ua  }  } = O(), { validateObject: sa  } = _e(), ee = Jl("kPaused"), { StringDecoder: rr  } = __default4, da = ct();
    nr(w.prototype, z.prototype);
    nr(w, z);
    var bt = ()=>{}, { errorOrDestroy: fe  } = ue;
    function yt(e, t, n) {
        typeof n != "boolean" && (n = t instanceof v()), this.objectMode = !!(e && e.objectMode), n && (this.objectMode = this.objectMode || !!(e && e.readableObjectMode)), this.highWaterMark = e ? ra(this, e, "readableHighWaterMark", n) : ia(!1), this.buffer = new na, this.length = 0, this.pipes = [], this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.constructed = !0, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this[ee] = null, this.errorEmitted = !1, this.emitClose = !e || e.emitClose !== !1, this.autoDestroy = !e || e.autoDestroy !== !1, this.destroyed = !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this.defaultEncoding = e && e.defaultEncoding || "utf8", this.awaitDrainWriters = null, this.multiAwaitDrain = !1, this.readingMore = !1, this.dataEmitted = !1, this.decoder = null, this.encoding = null, e && e.encoding && (this.decoder = new rr(e.encoding), this.encoding = e.encoding);
    }
    function w(e) {
        if (!(this instanceof w)) return new w(e);
        let t = this instanceof v();
        this._readableState = new yt(e, this, t), e && (typeof e.read == "function" && (this._read = e.read), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.construct == "function" && (this._construct = e.construct), e.signal && !t && ea(e.signal, this)), z.call(this, e), ue.construct(this, ()=>{
            this._readableState.needReadable && je(this, this._readableState);
        });
    }
    w.prototype.destroy = ue.destroy;
    w.prototype._undestroy = ue.undestroy;
    w.prototype._destroy = function(e, t) {
        t(e);
    };
    w.prototype[Ql.captureRejectionSymbol] = function(e) {
        this.destroy(e);
    };
    w.prototype.push = function(e, t) {
        return ir(this, e, t, !1);
    };
    w.prototype.unshift = function(e, t) {
        return ir(this, e, t, !0);
    };
    function ir(e, t, n, r) {
        y("readableAddChunk", t);
        let i = e._readableState, o;
        if (i.objectMode || (typeof t == "string" ? (n = n || i.defaultEncoding, i.encoding !== n && (r && i.encoding ? t = ht.from(t, n).toString(i.encoding) : (t = ht.from(t, n), n = ""))) : t instanceof ht ? n = "" : z._isUint8Array(t) ? (t = z._uint8ArrayToBuffer(t), n = "") : t != null && (o = new oa("chunk", [
            "string",
            "Buffer",
            "Uint8Array"
        ], t))), o) fe(e, o);
        else if (t === null) i.reading = !1, ba(e, i);
        else if (i.objectMode || t && t.length > 0) if (r) if (i.endEmitted) fe(e, new ua);
        else {
            if (i.destroyed || i.errored) return !1;
            _t(e, i, t, !0);
        }
        else if (i.ended) fe(e, new fa);
        else {
            if (i.destroyed || i.errored) return !1;
            i.reading = !1, i.decoder && !n ? (t = i.decoder.write(t), i.objectMode || t.length !== 0 ? _t(e, i, t, !1) : je(e, i)) : _t(e, i, t, !1);
        }
        else r || (i.reading = !1, je(e, i));
        return !i.ended && (i.length < i.highWaterMark || i.length === 0);
    }
    function _t(e, t, n, r) {
        t.flowing && t.length === 0 && !t.sync && e.listenerCount("data") > 0 ? (t.multiAwaitDrain ? t.awaitDrainWriters.clear() : t.awaitDrainWriters = null, t.dataEmitted = !0, e.emit("data", n)) : (t.length += t.objectMode ? 1 : n.length, r ? t.buffer.unshift(n) : t.buffer.push(n), t.needReadable && $e(e)), je(e, t);
    }
    w.prototype.isPaused = function() {
        let e = this._readableState;
        return e[ee] === !0 || e.flowing === !1;
    };
    w.prototype.setEncoding = function(e) {
        let t = new rr(e);
        this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
        let n = this._readableState.buffer, r = "";
        for (let i of n)r += t.write(i);
        return n.clear(), r !== "" && n.push(r), this._readableState.length = r.length, this;
    };
    var ca = 1073741824;
    function ha(e) {
        if (e > ca) throw new aa("size", "<= 1GiB", e);
        return e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++, e;
    }
    function er(e, t) {
        return e <= 0 || t.length === 0 && t.ended ? 0 : t.objectMode ? 1 : Hl(e) ? t.flowing && t.length ? t.buffer.first().length : t.length : e <= t.length ? e : t.ended ? t.length : 0;
    }
    w.prototype.read = function(e) {
        y("read", e), e === void 0 ? e = NaN : Gl(e) || (e = Vl(e, 10));
        let t = this._readableState, n = e;
        if (e > t.highWaterMark && (t.highWaterMark = ha(e)), e !== 0 && (t.emittedReadable = !1), e === 0 && t.needReadable && ((t.highWaterMark !== 0 ? t.length >= t.highWaterMark : t.length > 0) || t.ended)) return y("read: emitReadable", t.length, t.ended), t.length === 0 && t.ended ? pt(this) : $e(this), null;
        if (e = er(e, t), e === 0 && t.ended) return t.length === 0 && pt(this), null;
        let r = t.needReadable;
        if (y("need readable", r), (t.length === 0 || t.length - e < t.highWaterMark) && (r = !0, y("length less than watermark", r)), t.ended || t.reading || t.destroyed || t.errored || !t.constructed) r = !1, y("reading, ended or constructing", r);
        else if (r) {
            y("do read"), t.reading = !0, t.sync = !0, t.length === 0 && (t.needReadable = !0);
            try {
                this._read(t.highWaterMark);
            } catch (o) {
                fe(this, o);
            }
            t.sync = !1, t.reading || (e = er(n, t));
        }
        let i;
        return e > 0 ? i = ur(e, t) : i = null, i === null ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.multiAwaitDrain ? t.awaitDrainWriters.clear() : t.awaitDrainWriters = null), t.length === 0 && (t.ended || (t.needReadable = !0), n !== e && t.ended && pt(this)), i !== null && !t.errorEmitted && !t.closeEmitted && (t.dataEmitted = !0, this.emit("data", i)), i;
    };
    function ba(e, t) {
        if (y("onEofChunk"), !t.ended) {
            if (t.decoder) {
                let n = t.decoder.end();
                n && n.length && (t.buffer.push(n), t.length += t.objectMode ? 1 : n.length);
            }
            t.ended = !0, t.sync ? $e(e) : (t.needReadable = !1, t.emittedReadable = !0, or(e));
        }
    }
    function $e(e) {
        let t = e._readableState;
        y("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = !1, t.emittedReadable || (y("emitReadable", t.flowing), t.emittedReadable = !0, W.nextTick(or, e));
    }
    function or(e) {
        let t = e._readableState;
        y("emitReadable_", t.destroyed, t.length, t.ended), !t.destroyed && !t.errored && (t.length || t.ended) && (e.emit("readable"), t.emittedReadable = !1), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, ar(e);
    }
    function je(e, t) {
        !t.readingMore && t.constructed && (t.readingMore = !0, W.nextTick(_a, e, t));
    }
    function _a(e, t) {
        for(; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && t.length === 0);){
            let n = t.length;
            if (y("maybeReadMore read 0"), e.read(0), n === t.length) break;
        }
        t.readingMore = !1;
    }
    w.prototype._read = function(e) {
        throw new la("_read()");
    };
    w.prototype.pipe = function(e, t) {
        let n = this, r = this._readableState;
        r.pipes.length === 1 && (r.multiAwaitDrain || (r.multiAwaitDrain = !0, r.awaitDrainWriters = new zl(r.awaitDrainWriters ? [
            r.awaitDrainWriters
        ] : []))), r.pipes.push(e), y("pipe count=%d opts=%j", r.pipes.length, t);
        let o = (!t || t.end !== !1) && e !== W.stdout && e !== W.stderr ? u : L;
        r.endEmitted ? W.nextTick(o) : n.once("end", o), e.on("unpipe", l);
        function l(_, p) {
            y("onunpipe"), _ === n && p && p.hasUnpiped === !1 && (p.hasUnpiped = !0, c());
        }
        function u() {
            y("onend"), e.end();
        }
        let f, a = !1;
        function c() {
            y("cleanup"), e.removeListener("close", h), e.removeListener("finish", D), f && e.removeListener("drain", f), e.removeListener("error", d), e.removeListener("unpipe", l), n.removeListener("end", u), n.removeListener("end", L), n.removeListener("data", b), a = !0, f && r.awaitDrainWriters && (!e._writableState || e._writableState.needDrain) && f();
        }
        function s() {
            a || (r.pipes.length === 1 && r.pipes[0] === e ? (y("false write response, pause", 0), r.awaitDrainWriters = e, r.multiAwaitDrain = !1) : r.pipes.length > 1 && r.pipes.includes(e) && (y("false write response, pause", r.awaitDrainWriters.size), r.awaitDrainWriters.add(e)), n.pause()), f || (f = pa(n, e), e.on("drain", f));
        }
        n.on("data", b);
        function b(_) {
            y("ondata");
            let p = e.write(_);
            y("dest.write", p), p === !1 && s();
        }
        function d(_) {
            if (y("onerror", _), L(), e.removeListener("error", d), e.listenerCount("error") === 0) {
                let p = e._writableState || e._readableState;
                p && !p.errorEmitted ? fe(e, _) : e.emit("error", _);
            }
        }
        Zl(e, "error", d);
        function h() {
            e.removeListener("finish", D), L();
        }
        e.once("close", h);
        function D() {
            y("onfinish"), e.removeListener("close", h), L();
        }
        e.once("finish", D);
        function L() {
            y("unpipe"), n.unpipe(e);
        }
        return e.emit("pipe", n), e.writableNeedDrain === !0 ? r.flowing && s() : r.flowing || (y("pipe resume"), n.resume()), e;
    };
    function pa(e, t) {
        return function() {
            let r = e._readableState;
            r.awaitDrainWriters === t ? (y("pipeOnDrain", 1), r.awaitDrainWriters = null) : r.multiAwaitDrain && (y("pipeOnDrain", r.awaitDrainWriters.size), r.awaitDrainWriters.delete(t)), (!r.awaitDrainWriters || r.awaitDrainWriters.size === 0) && e.listenerCount("data") && e.resume();
        };
    }
    w.prototype.unpipe = function(e) {
        let t = this._readableState, n = {
            hasUnpiped: !1
        };
        if (t.pipes.length === 0) return this;
        if (!e) {
            let i = t.pipes;
            t.pipes = [], this.pause();
            for(let o = 0; o < i.length; o++)i[o].emit("unpipe", this, {
                hasUnpiped: !1
            });
            return this;
        }
        let r = Bl(t.pipes, e);
        return r === -1 ? this : (t.pipes.splice(r, 1), t.pipes.length === 0 && this.pause(), e.emit("unpipe", this, n), this);
    };
    w.prototype.on = function(e, t) {
        let n = z.prototype.on.call(this, e, t), r = this._readableState;
        return e === "data" ? (r.readableListening = this.listenerCount("readable") > 0, r.flowing !== !1 && this.resume()) : e === "readable" && !r.endEmitted && !r.readableListening && (r.readableListening = r.needReadable = !0, r.flowing = !1, r.emittedReadable = !1, y("on readable", r.length, r.reading), r.length ? $e(this) : r.reading || W.nextTick(wa, this)), n;
    };
    w.prototype.addListener = w.prototype.on;
    w.prototype.removeListener = function(e, t) {
        let n = z.prototype.removeListener.call(this, e, t);
        return e === "readable" && W.nextTick(lr, this), n;
    };
    w.prototype.off = w.prototype.removeListener;
    w.prototype.removeAllListeners = function(e) {
        let t = z.prototype.removeAllListeners.apply(this, arguments);
        return (e === "readable" || e === void 0) && W.nextTick(lr, this), t;
    };
    function lr(e) {
        let t = e._readableState;
        t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && t[ee] === !1 ? t.flowing = !0 : e.listenerCount("data") > 0 ? e.resume() : t.readableListening || (t.flowing = null);
    }
    function wa(e) {
        y("readable nexttick read 0"), e.read(0);
    }
    w.prototype.resume = function() {
        let e = this._readableState;
        return e.flowing || (y("resume"), e.flowing = !e.readableListening, ya(this, e)), e[ee] = !1, this;
    };
    function ya(e, t) {
        t.resumeScheduled || (t.resumeScheduled = !0, W.nextTick(ga, e, t));
    }
    function ga(e, t) {
        y("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit("resume"), ar(e), t.flowing && !t.reading && e.read(0);
    }
    w.prototype.pause = function() {
        return y("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (y("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState[ee] = !0, this;
    };
    function ar(e) {
        let t = e._readableState;
        for(y("flow", t.flowing); t.flowing && e.read() !== null;);
    }
    w.prototype.wrap = function(e) {
        let t = !1;
        e.on("data", (r)=>{
            !this.push(r) && e.pause && (t = !0, e.pause());
        }), e.on("end", ()=>{
            this.push(null);
        }), e.on("error", (r)=>{
            fe(this, r);
        }), e.on("close", ()=>{
            this.destroy();
        }), e.on("destroy", ()=>{
            this.destroy();
        }), this._read = ()=>{
            t && e.resume && (t = !1, e.resume());
        };
        let n = Yl(e);
        for(let r = 1; r < n.length; r++){
            let i = n[r];
            this[i] === void 0 && typeof e[i] == "function" && (this[i] = e[i].bind(e));
        }
        return this;
    };
    w.prototype[Xl] = function() {
        return fr(this);
    };
    w.prototype.iterator = function(e) {
        return e !== void 0 && sa(e, "options"), fr(this, e);
    };
    function fr(e, t) {
        typeof e.read != "function" && (e = w.wrap(e, {
            objectMode: !0
        }));
        let n = Sa(e, t);
        return n.stream = e, n;
    }
    async function* Sa(e, t) {
        let n = bt;
        function r(l) {
            this === e ? (n(), n = bt) : n = l;
        }
        e.on("readable", r);
        let i, o = ta(e, {
            writable: !1
        }, (l)=>{
            i = l ? Zn(i, l) : null, n(), n = bt;
        });
        try {
            for(;;){
                let l = e.destroyed ? null : e.read();
                if (l !== null) yield l;
                else {
                    if (i) throw i;
                    if (i === null) return;
                    await new Kl(r);
                }
            }
        } catch (l) {
            throw i = Zn(i, l), i;
        } finally{
            (i || t?.destroyOnReturn !== !1) && (i === void 0 || e._readableState.autoDestroy) ? ue.destroyer(e, null) : (e.off("readable", r), o());
        }
    }
    tr(w.prototype, {
        readable: {
            __proto__: null,
            get () {
                let e = this._readableState;
                return !!e && e.readable !== !1 && !e.destroyed && !e.errorEmitted && !e.endEmitted;
            },
            set (e) {
                this._readableState && (this._readableState.readable = !!e);
            }
        },
        readableDidRead: {
            __proto__: null,
            enumerable: !1,
            get: function() {
                return this._readableState.dataEmitted;
            }
        },
        readableAborted: {
            __proto__: null,
            enumerable: !1,
            get: function() {
                return !!(this._readableState.readable !== !1 && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted);
            }
        },
        readableHighWaterMark: {
            __proto__: null,
            enumerable: !1,
            get: function() {
                return this._readableState.highWaterMark;
            }
        },
        readableBuffer: {
            __proto__: null,
            enumerable: !1,
            get: function() {
                return this._readableState && this._readableState.buffer;
            }
        },
        readableFlowing: {
            __proto__: null,
            enumerable: !1,
            get: function() {
                return this._readableState.flowing;
            },
            set: function(e) {
                this._readableState && (this._readableState.flowing = e);
            }
        },
        readableLength: {
            __proto__: null,
            enumerable: !1,
            get () {
                return this._readableState.length;
            }
        },
        readableObjectMode: {
            __proto__: null,
            enumerable: !1,
            get () {
                return this._readableState ? this._readableState.objectMode : !1;
            }
        },
        readableEncoding: {
            __proto__: null,
            enumerable: !1,
            get () {
                return this._readableState ? this._readableState.encoding : null;
            }
        },
        errored: {
            __proto__: null,
            enumerable: !1,
            get () {
                return this._readableState ? this._readableState.errored : null;
            }
        },
        closed: {
            __proto__: null,
            get () {
                return this._readableState ? this._readableState.closed : !1;
            }
        },
        destroyed: {
            __proto__: null,
            enumerable: !1,
            get () {
                return this._readableState ? this._readableState.destroyed : !1;
            },
            set (e) {
                !this._readableState || (this._readableState.destroyed = e);
            }
        },
        readableEnded: {
            __proto__: null,
            enumerable: !1,
            get () {
                return this._readableState ? this._readableState.endEmitted : !1;
            }
        }
    });
    tr(yt.prototype, {
        pipesCount: {
            __proto__: null,
            get () {
                return this.pipes.length;
            }
        },
        paused: {
            __proto__: null,
            get () {
                return this[ee] !== !1;
            },
            set (e) {
                this[ee] = !!e;
            }
        }
    });
    w._fromList = ur;
    function ur(e, t) {
        if (t.length === 0) return null;
        let n;
        return t.objectMode ? n = t.buffer.shift() : !e || e >= t.length ? (t.decoder ? n = t.buffer.join("") : t.buffer.length === 1 ? n = t.buffer.first() : n = t.buffer.concat(t.length), t.buffer.clear()) : n = t.buffer.consume(e, t.decoder), n;
    }
    function pt(e) {
        let t = e._readableState;
        y("endReadable", t.endEmitted), t.endEmitted || (t.ended = !0, W.nextTick(Ea, t, e));
    }
    function Ea(e, t) {
        if (y("endReadableNT", e.endEmitted, e.length), !e.errored && !e.closeEmitted && !e.endEmitted && e.length === 0) {
            if (e.endEmitted = !0, t.emit("end"), t.writable && t.allowHalfOpen === !1) W.nextTick(Ra, t);
            else if (e.autoDestroy) {
                let n = t._writableState;
                (!n || n.autoDestroy && (n.finished || n.writable === !1)) && t.destroy();
            }
        }
    }
    function Ra(e) {
        e.writable && !e.writableEnded && !e.destroyed && e.end();
    }
    w.from = function(e, t) {
        return da(w, e, t);
    };
    var wt;
    function sr() {
        return wt === void 0 && (wt = {}), wt;
    }
    w.fromWeb = function(e, t) {
        return sr().newStreamReadableFromReadableStream(e, t);
    };
    w.toWeb = function(e, t) {
        return sr().newReadableStreamFromStreamReadable(e, t);
    };
    w.wrap = function(e, t) {
        var n, r;
        return new w({
            objectMode: (n = (r = e.readableObjectMode) !== null && r !== void 0 ? r : e.objectMode) !== null && n !== void 0 ? n : !0,
            ...t,
            destroy (i, o) {
                ue.destroyer(e, i), o(i);
            }
        }).wrap(e);
    };
});
var Tt = g((fu, Ar)=>{
    var te = __process$, { ArrayPrototypeSlice: br , Error: Aa , FunctionPrototypeSymbolHasInstance: _r , ObjectDefineProperty: pr , ObjectDefineProperties: ma , ObjectSetPrototypeOf: wr , StringPrototypeToLowerCase: Ta , Symbol: Ia , SymbolHasInstance: Ma  } = m();
    Ar.exports = S;
    S.WritableState = Se;
    var { EventEmitter: Na  } = EventEmitter, ye = Le().Stream, { Buffer: ve  } = __default3, Be = Z(), { addAbortSignal: Da  } = ke(), { getHighWaterMark: Oa , getDefaultHighWaterMark: qa  } = Ce(), { ERR_INVALID_ARG_TYPE: xa , ERR_METHOD_NOT_IMPLEMENTED: La , ERR_MULTIPLE_CALLBACK: yr , ERR_STREAM_CANNOT_PIPE: Pa , ERR_STREAM_DESTROYED: ge , ERR_STREAM_ALREADY_FINISHED: ka , ERR_STREAM_NULL_VALUES: Wa , ERR_STREAM_WRITE_AFTER_END: Ca , ERR_UNKNOWN_ENCODING: gr  } = O().codes, { errorOrDestroy: se  } = Be;
    wr(S.prototype, ye.prototype);
    wr(S, ye);
    function Et() {}
    var de = Ia("kOnFinished");
    function Se(e, t, n) {
        typeof n != "boolean" && (n = t instanceof v()), this.objectMode = !!(e && e.objectMode), n && (this.objectMode = this.objectMode || !!(e && e.writableObjectMode)), this.highWaterMark = e ? Oa(this, e, "writableHighWaterMark", n) : qa(!1), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
        let r = !!(e && e.decodeStrings === !1);
        this.decodeStrings = !r, this.defaultEncoding = e && e.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = $a.bind(void 0, t), this.writecb = null, this.writelen = 0, this.afterWriteTickInfo = null, Ue(this), this.pendingcb = 0, this.constructed = !0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !e || e.emitClose !== !1, this.autoDestroy = !e || e.autoDestroy !== !1, this.errored = null, this.closed = !1, this.closeEmitted = !1, this[de] = [];
    }
    function Ue(e) {
        e.buffered = [], e.bufferedIndex = 0, e.allBuffers = !0, e.allNoop = !0;
    }
    Se.prototype.getBuffer = function() {
        return br(this.buffered, this.bufferedIndex);
    };
    pr(Se.prototype, "bufferedRequestCount", {
        __proto__: null,
        get () {
            return this.buffered.length - this.bufferedIndex;
        }
    });
    function S(e) {
        let t = this instanceof v();
        if (!t && !_r(S, this)) return new S(e);
        this._writableState = new Se(e, this, t), e && (typeof e.write == "function" && (this._write = e.write), typeof e.writev == "function" && (this._writev = e.writev), typeof e.destroy == "function" && (this._destroy = e.destroy), typeof e.final == "function" && (this._final = e.final), typeof e.construct == "function" && (this._construct = e.construct), e.signal && Da(e.signal, this)), ye.call(this, e), Be.construct(this, ()=>{
            let n = this._writableState;
            n.writing || At(this, n), mt(this, n);
        });
    }
    pr(S, Ma, {
        __proto__: null,
        value: function(e) {
            return _r(this, e) ? !0 : this !== S ? !1 : e && e._writableState instanceof Se;
        }
    });
    S.prototype.pipe = function() {
        se(this, new Pa);
    };
    function Sr(e, t, n, r) {
        let i = e._writableState;
        if (typeof n == "function") r = n, n = i.defaultEncoding;
        else {
            if (!n) n = i.defaultEncoding;
            else if (n !== "buffer" && !ve.isEncoding(n)) throw new gr(n);
            typeof r != "function" && (r = Et);
        }
        if (t === null) throw new Wa;
        if (!i.objectMode) if (typeof t == "string") i.decodeStrings !== !1 && (t = ve.from(t, n), n = "buffer");
        else if (t instanceof ve) n = "buffer";
        else if (ye._isUint8Array(t)) t = ye._uint8ArrayToBuffer(t), n = "buffer";
        else throw new xa("chunk", [
            "string",
            "Buffer",
            "Uint8Array"
        ], t);
        let o;
        return i.ending ? o = new Ca : i.destroyed && (o = new ge("write")), o ? (te.nextTick(r, o), se(e, o, !0), o) : (i.pendingcb++, ja(e, i, t, n, r));
    }
    S.prototype.write = function(e, t, n) {
        return Sr(this, e, t, n) === !0;
    };
    S.prototype.cork = function() {
        this._writableState.corked++;
    };
    S.prototype.uncork = function() {
        let e = this._writableState;
        e.corked && (e.corked--, e.writing || At(this, e));
    };
    S.prototype.setDefaultEncoding = function(t) {
        if (typeof t == "string" && (t = Ta(t)), !ve.isEncoding(t)) throw new gr(t);
        return this._writableState.defaultEncoding = t, this;
    };
    function ja(e, t, n, r, i) {
        let o = t.objectMode ? 1 : n.length;
        t.length += o;
        let l = t.length < t.highWaterMark;
        return l || (t.needDrain = !0), t.writing || t.corked || t.errored || !t.constructed ? (t.buffered.push({
            chunk: n,
            encoding: r,
            callback: i
        }), t.allBuffers && r !== "buffer" && (t.allBuffers = !1), t.allNoop && i !== Et && (t.allNoop = !1)) : (t.writelen = o, t.writecb = i, t.writing = !0, t.sync = !0, e._write(n, r, t.onwrite), t.sync = !1), l && !t.errored && !t.destroyed;
    }
    function cr(e, t, n, r, i, o, l) {
        t.writelen = r, t.writecb = l, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new ge("write")) : n ? e._writev(i, t.onwrite) : e._write(i, o, t.onwrite), t.sync = !1;
    }
    function hr(e, t, n, r) {
        --t.pendingcb, r(n), Rt(t), se(e, n);
    }
    function $a(e, t) {
        let n = e._writableState, r = n.sync, i = n.writecb;
        if (typeof i != "function") {
            se(e, new yr);
            return;
        }
        n.writing = !1, n.writecb = null, n.length -= n.writelen, n.writelen = 0, t ? (t.stack, n.errored || (n.errored = t), e._readableState && !e._readableState.errored && (e._readableState.errored = t), r ? te.nextTick(hr, e, n, t, i) : hr(e, n, t, i)) : (n.buffered.length > n.bufferedIndex && At(e, n), r ? n.afterWriteTickInfo !== null && n.afterWriteTickInfo.cb === i ? n.afterWriteTickInfo.count++ : (n.afterWriteTickInfo = {
            count: 1,
            cb: i,
            stream: e,
            state: n
        }, te.nextTick(va, n.afterWriteTickInfo)) : Er(e, n, 1, i));
    }
    function va({ stream: e , state: t , count: n , cb: r  }) {
        return t.afterWriteTickInfo = null, Er(e, t, n, r);
    }
    function Er(e, t, n, r) {
        for(!t.ending && !e.destroyed && t.length === 0 && t.needDrain && (t.needDrain = !1, e.emit("drain")); n-- > 0;)t.pendingcb--, r();
        t.destroyed && Rt(t), mt(e, t);
    }
    function Rt(e) {
        if (e.writing) return;
        for(let i = e.bufferedIndex; i < e.buffered.length; ++i){
            var t;
            let { chunk: o , callback: l  } = e.buffered[i], u = e.objectMode ? 1 : o.length;
            e.length -= u, l((t = e.errored) !== null && t !== void 0 ? t : new ge("write"));
        }
        let n = e[de].splice(0);
        for(let i = 0; i < n.length; i++){
            var r;
            n[i]((r = e.errored) !== null && r !== void 0 ? r : new ge("end"));
        }
        Ue(e);
    }
    function At(e, t) {
        if (t.corked || t.bufferProcessing || t.destroyed || !t.constructed) return;
        let { buffered: n , bufferedIndex: r , objectMode: i  } = t, o = n.length - r;
        if (!o) return;
        let l = r;
        if (t.bufferProcessing = !0, o > 1 && e._writev) {
            t.pendingcb -= o - 1;
            let u = t.allNoop ? Et : (a)=>{
                for(let c = l; c < n.length; ++c)n[c].callback(a);
            }, f = t.allNoop && l === 0 ? n : br(n, l);
            f.allBuffers = t.allBuffers, cr(e, t, !0, t.length, f, "", u), Ue(t);
        } else {
            do {
                let { chunk: u , encoding: f , callback: a  } = n[l];
                n[l++] = null;
                let c = i ? 1 : u.length;
                cr(e, t, !1, c, u, f, a);
            }while (l < n.length && !t.writing)
            l === n.length ? Ue(t) : l > 256 ? (n.splice(0, l), t.bufferedIndex = 0) : t.bufferedIndex = l;
        }
        t.bufferProcessing = !1;
    }
    S.prototype._write = function(e, t, n) {
        if (this._writev) this._writev([
            {
                chunk: e,
                encoding: t
            }
        ], n);
        else throw new La("_write()");
    };
    S.prototype._writev = null;
    S.prototype.end = function(e, t, n) {
        let r = this._writableState;
        typeof e == "function" ? (n = e, e = null, t = null) : typeof t == "function" && (n = t, t = null);
        let i;
        if (e != null) {
            let o = Sr(this, e, t);
            o instanceof Aa && (i = o);
        }
        return r.corked && (r.corked = 1, this.uncork()), i || (!r.errored && !r.ending ? (r.ending = !0, mt(this, r, !0), r.ended = !0) : r.finished ? i = new ka("end") : r.destroyed && (i = new ge("end"))), typeof n == "function" && (i || r.finished ? te.nextTick(n, i) : r[de].push(n)), this;
    };
    function Fe(e) {
        return e.ending && !e.destroyed && e.constructed && e.length === 0 && !e.errored && e.buffered.length === 0 && !e.finished && !e.writing && !e.errorEmitted && !e.closeEmitted;
    }
    function Fa(e, t) {
        let n = !1;
        function r(i) {
            if (n) {
                se(e, i ?? yr());
                return;
            }
            if (n = !0, t.pendingcb--, i) {
                let o = t[de].splice(0);
                for(let l = 0; l < o.length; l++)o[l](i);
                se(e, i, t.sync);
            } else Fe(t) && (t.prefinished = !0, e.emit("prefinish"), t.pendingcb++, te.nextTick(St, e, t));
        }
        t.sync = !0, t.pendingcb++;
        try {
            e._final(r);
        } catch (i) {
            r(i);
        }
        t.sync = !1;
    }
    function Ua(e, t) {
        !t.prefinished && !t.finalCalled && (typeof e._final == "function" && !t.destroyed ? (t.finalCalled = !0, Fa(e, t)) : (t.prefinished = !0, e.emit("prefinish")));
    }
    function mt(e, t, n) {
        Fe(t) && (Ua(e, t), t.pendingcb === 0 && (n ? (t.pendingcb++, te.nextTick((r, i)=>{
            Fe(i) ? St(r, i) : i.pendingcb--;
        }, e, t)) : Fe(t) && (t.pendingcb++, St(e, t))));
    }
    function St(e, t) {
        t.pendingcb--, t.finished = !0;
        let n = t[de].splice(0);
        for(let r = 0; r < n.length; r++)n[r]();
        if (e.emit("finish"), t.autoDestroy) {
            let r = e._readableState;
            (!r || r.autoDestroy && (r.endEmitted || r.readable === !1)) && e.destroy();
        }
    }
    ma(S.prototype, {
        closed: {
            __proto__: null,
            get () {
                return this._writableState ? this._writableState.closed : !1;
            }
        },
        destroyed: {
            __proto__: null,
            get () {
                return this._writableState ? this._writableState.destroyed : !1;
            },
            set (e) {
                this._writableState && (this._writableState.destroyed = e);
            }
        },
        writable: {
            __proto__: null,
            get () {
                let e = this._writableState;
                return !!e && e.writable !== !1 && !e.destroyed && !e.errored && !e.ending && !e.ended;
            },
            set (e) {
                this._writableState && (this._writableState.writable = !!e);
            }
        },
        writableFinished: {
            __proto__: null,
            get () {
                return this._writableState ? this._writableState.finished : !1;
            }
        },
        writableObjectMode: {
            __proto__: null,
            get () {
                return this._writableState ? this._writableState.objectMode : !1;
            }
        },
        writableBuffer: {
            __proto__: null,
            get () {
                return this._writableState && this._writableState.getBuffer();
            }
        },
        writableEnded: {
            __proto__: null,
            get () {
                return this._writableState ? this._writableState.ending : !1;
            }
        },
        writableNeedDrain: {
            __proto__: null,
            get () {
                let e = this._writableState;
                return e ? !e.destroyed && !e.ending && e.needDrain : !1;
            }
        },
        writableHighWaterMark: {
            __proto__: null,
            get () {
                return this._writableState && this._writableState.highWaterMark;
            }
        },
        writableCorked: {
            __proto__: null,
            get () {
                return this._writableState ? this._writableState.corked : 0;
            }
        },
        writableLength: {
            __proto__: null,
            get () {
                return this._writableState && this._writableState.length;
            }
        },
        errored: {
            __proto__: null,
            enumerable: !1,
            get () {
                return this._writableState ? this._writableState.errored : null;
            }
        },
        writableAborted: {
            __proto__: null,
            enumerable: !1,
            get: function() {
                return !!(this._writableState.writable !== !1 && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished);
            }
        }
    });
    var Ba = Be.destroy;
    S.prototype.destroy = function(e, t) {
        let n = this._writableState;
        return !n.destroyed && (n.bufferedIndex < n.buffered.length || n[de].length) && te.nextTick(Rt, n), Ba.call(this, e, t), this;
    };
    S.prototype._undestroy = Be.undestroy;
    S.prototype._destroy = function(e, t) {
        t(e);
    };
    S.prototype[Na.captureRejectionSymbol] = function(e) {
        this.destroy(e);
    };
    var gt;
    function Rr() {
        return gt === void 0 && (gt = {}), gt;
    }
    S.fromWeb = function(e, t) {
        return Rr().newStreamWritableFromWritableStream(e, t);
    };
    S.toWeb = function(e) {
        return Rr().newWritableStreamFromStreamWritable(e);
    };
});
var kr = g((uu, Pr)=>{
    var It = __process$, Ga = __default3, { isReadable: Ha , isWritable: Va , isIterable: mr , isNodeStream: Ya , isReadableNodeStream: Tr , isWritableNodeStream: Ir , isDuplexNodeStream: Ka  } = V(), Mr = Y(), { AbortError: Lr , codes: { ERR_INVALID_ARG_TYPE: za , ERR_INVALID_RETURN_VALUE: Nr  }  } = O(), { destroyer: ce  } = Z(), Xa = v(), Ja = we(), { createDeferredPromise: Dr  } = j(), Or = ct(), qr = globalThis.Blob || Ga.Blob, Qa = typeof qr < "u" ? function(t) {
        return t instanceof qr;
    } : function(t) {
        return !1;
    }, Za = globalThis.AbortController, { FunctionPrototypeCall: xr  } = m(), ne = class extends Xa {
        constructor(t){
            super(t), t?.readable === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), t?.writable === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0);
        }
    };
    Pr.exports = function e(t, n) {
        if (Ka(t)) return t;
        if (Tr(t)) return Ge({
            readable: t
        });
        if (Ir(t)) return Ge({
            writable: t
        });
        if (Ya(t)) return Ge({
            writable: !1,
            readable: !1
        });
        if (typeof t == "function") {
            let { value: i , write: o , final: l , destroy: u  } = ef(t);
            if (mr(i)) return Or(ne, i, {
                objectMode: !0,
                write: o,
                final: l,
                destroy: u
            });
            let f = i?.then;
            if (typeof f == "function") {
                let a, c = xr(f, i, (s)=>{
                    if (s != null) throw new Nr("nully", "body", s);
                }, (s)=>{
                    ce(a, s);
                });
                return a = new ne({
                    objectMode: !0,
                    readable: !1,
                    write: o,
                    final (s) {
                        l(async ()=>{
                            try {
                                await c, It.nextTick(s, null);
                            } catch (b) {
                                It.nextTick(s, b);
                            }
                        });
                    },
                    destroy: u
                });
            }
            throw new Nr("Iterable, AsyncIterable or AsyncFunction", n, i);
        }
        if (Qa(t)) return e(t.arrayBuffer());
        if (mr(t)) return Or(ne, t, {
            objectMode: !0,
            writable: !1
        });
        if (typeof t?.writable == "object" || typeof t?.readable == "object") {
            let i = t != null && t.readable ? Tr(t?.readable) ? t?.readable : e(t.readable) : void 0, o = t != null && t.writable ? Ir(t?.writable) ? t?.writable : e(t.writable) : void 0;
            return Ge({
                readable: i,
                writable: o
            });
        }
        let r = t?.then;
        if (typeof r == "function") {
            let i;
            return xr(r, t, (o)=>{
                o != null && i.push(o), i.push(null);
            }, (o)=>{
                ce(i, o);
            }), i = new ne({
                objectMode: !0,
                writable: !1,
                read () {}
            });
        }
        throw new za(n, [
            "Blob",
            "ReadableStream",
            "WritableStream",
            "Stream",
            "Iterable",
            "AsyncIterable",
            "Function",
            "{ readable, writable } pair",
            "Promise"
        ], t);
    };
    function ef(e) {
        let { promise: t , resolve: n  } = Dr(), r = new Za, i = r.signal;
        return {
            value: e(async function*() {
                for(;;){
                    let l = t;
                    t = null;
                    let { chunk: u , done: f , cb: a  } = await l;
                    if (It.nextTick(a), f) return;
                    if (i.aborted) throw new Lr(void 0, {
                        cause: i.reason
                    });
                    ({ promise: t , resolve: n  } = Dr()), yield u;
                }
            }(), {
                signal: i
            }),
            write (l, u, f) {
                let a = n;
                n = null, a({
                    chunk: l,
                    done: !1,
                    cb: f
                });
            },
            final (l) {
                let u = n;
                n = null, u({
                    done: !0,
                    cb: l
                });
            },
            destroy (l, u) {
                r.abort(), u(l);
            }
        };
    }
    function Ge(e) {
        let t = e.readable && typeof e.readable.read != "function" ? Ja.wrap(e.readable) : e.readable, n = e.writable, r = !!Ha(t), i = !!Va(n), o, l, u, f, a;
        function c(s) {
            let b = f;
            f = null, b ? b(s) : s ? a.destroy(s) : !r && !i && a.destroy();
        }
        return a = new ne({
            readableObjectMode: !!(t != null && t.readableObjectMode),
            writableObjectMode: !!(n != null && n.writableObjectMode),
            readable: r,
            writable: i
        }), i && (Mr(n, (s)=>{
            i = !1, s && ce(t, s), c(s);
        }), a._write = function(s, b, d) {
            n.write(s, b) ? d() : o = d;
        }, a._final = function(s) {
            n.end(), l = s;
        }, n.on("drain", function() {
            if (o) {
                let s = o;
                o = null, s();
            }
        }), n.on("finish", function() {
            if (l) {
                let s = l;
                l = null, s();
            }
        })), r && (Mr(t, (s)=>{
            r = !1, s && ce(t, s), c(s);
        }), t.on("readable", function() {
            if (u) {
                let s = u;
                u = null, s();
            }
        }), t.on("end", function() {
            a.push(null);
        }), a._read = function() {
            for(;;){
                let s = t.read();
                if (s === null) {
                    u = a._read;
                    return;
                }
                if (!a.push(s)) return;
            }
        }), a._destroy = function(s, b) {
            !s && f !== null && (s = new Lr), u = null, o = null, l = null, f === null ? b(s) : (f = b, ce(n, s), ce(t, s));
        }, a;
    }
});
var v = g((su, jr)=>{
    "use strict";
    var { ObjectDefineProperties: tf , ObjectGetOwnPropertyDescriptor: B , ObjectKeys: nf , ObjectSetPrototypeOf: Wr  } = m();
    jr.exports = C;
    var Dt = we(), x = Tt();
    Wr(C.prototype, Dt.prototype);
    Wr(C, Dt);
    {
        let e = nf(x.prototype);
        for(let t = 0; t < e.length; t++){
            let n = e[t];
            C.prototype[n] || (C.prototype[n] = x.prototype[n]);
        }
    }
    function C(e) {
        if (!(this instanceof C)) return new C(e);
        Dt.call(this, e), x.call(this, e), e ? (this.allowHalfOpen = e.allowHalfOpen !== !1, e.readable === !1 && (this._readableState.readable = !1, this._readableState.ended = !0, this._readableState.endEmitted = !0), e.writable === !1 && (this._writableState.writable = !1, this._writableState.ending = !0, this._writableState.ended = !0, this._writableState.finished = !0)) : this.allowHalfOpen = !0;
    }
    tf(C.prototype, {
        writable: {
            __proto__: null,
            ...B(x.prototype, "writable")
        },
        writableHighWaterMark: {
            __proto__: null,
            ...B(x.prototype, "writableHighWaterMark")
        },
        writableObjectMode: {
            __proto__: null,
            ...B(x.prototype, "writableObjectMode")
        },
        writableBuffer: {
            __proto__: null,
            ...B(x.prototype, "writableBuffer")
        },
        writableLength: {
            __proto__: null,
            ...B(x.prototype, "writableLength")
        },
        writableFinished: {
            __proto__: null,
            ...B(x.prototype, "writableFinished")
        },
        writableCorked: {
            __proto__: null,
            ...B(x.prototype, "writableCorked")
        },
        writableEnded: {
            __proto__: null,
            ...B(x.prototype, "writableEnded")
        },
        writableNeedDrain: {
            __proto__: null,
            ...B(x.prototype, "writableNeedDrain")
        },
        destroyed: {
            __proto__: null,
            get () {
                return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
            },
            set (e) {
                this._readableState && this._writableState && (this._readableState.destroyed = e, this._writableState.destroyed = e);
            }
        }
    });
    var Mt;
    function Cr() {
        return Mt === void 0 && (Mt = {}), Mt;
    }
    C.fromWeb = function(e, t) {
        return Cr().newStreamDuplexFromReadableWritablePair(e, t);
    };
    C.toWeb = function(e) {
        return Cr().newReadableWritablePairFromDuplex(e);
    };
    var Nt;
    C.from = function(e) {
        return Nt || (Nt = kr()), Nt(e, "body");
    };
});
var xt = g((du, vr)=>{
    "use strict";
    var { ObjectSetPrototypeOf: $r , Symbol: rf  } = m();
    vr.exports = G;
    var { ERR_METHOD_NOT_IMPLEMENTED: of  } = O().codes, qt = v(), { getHighWaterMark: lf  } = Ce();
    $r(G.prototype, qt.prototype);
    $r(G, qt);
    var Ee = rf("kCallback");
    function G(e) {
        if (!(this instanceof G)) return new G(e);
        let t = e ? lf(this, e, "readableHighWaterMark", !0) : null;
        t === 0 && (e = {
            ...e,
            highWaterMark: null,
            readableHighWaterMark: t,
            writableHighWaterMark: e.writableHighWaterMark || 0
        }), qt.call(this, e), this._readableState.sync = !1, this[Ee] = null, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", af);
    }
    function Ot(e) {
        typeof this._flush == "function" && !this.destroyed ? this._flush((t, n)=>{
            if (t) {
                e ? e(t) : this.destroy(t);
                return;
            }
            n != null && this.push(n), this.push(null), e && e();
        }) : (this.push(null), e && e());
    }
    function af() {
        this._final !== Ot && Ot.call(this);
    }
    G.prototype._final = Ot;
    G.prototype._transform = function(e, t, n) {
        throw new of("_transform()");
    };
    G.prototype._write = function(e, t, n) {
        let r = this._readableState, i = this._writableState, o = r.length;
        this._transform(e, t, (l, u)=>{
            if (l) {
                n(l);
                return;
            }
            u != null && this.push(u), i.ended || o === r.length || r.length < r.highWaterMark ? n() : this[Ee] = n;
        });
    };
    G.prototype._read = function() {
        if (this[Ee]) {
            let e = this[Ee];
            this[Ee] = null, e();
        }
    };
});
var Pt = g((cu, Ur)=>{
    "use strict";
    var { ObjectSetPrototypeOf: Fr  } = m();
    Ur.exports = he;
    var Lt = xt();
    Fr(he.prototype, Lt.prototype);
    Fr(he, Lt);
    function he(e) {
        if (!(this instanceof he)) return new he(e);
        Lt.call(this, e);
    }
    he.prototype._transform = function(e, t, n) {
        n(null, e);
    };
});
var Ye = g((hu, zr)=>{
    var He = __process$, { ArrayIsArray: ff , Promise: uf , SymbolAsyncIterator: sf  } = m(), Ve = Y(), { once: df  } = j(), cf = Z(), Br = v(), { aggregateTwoErrors: hf , codes: { ERR_INVALID_ARG_TYPE: Yr , ERR_INVALID_RETURN_VALUE: kt , ERR_MISSING_ARGS: bf , ERR_STREAM_DESTROYED: _f , ERR_STREAM_PREMATURE_CLOSE: pf  } , AbortError: wf  } = O(), { validateFunction: yf , validateAbortSignal: gf  } = _e(), { isIterable: be , isReadable: Wt , isReadableNodeStream: $t , isNodeStream: Gr  } = V(), Sf = globalThis.AbortController, Ct, jt;
    function Hr(e, t, n) {
        let r = !1;
        e.on("close", ()=>{
            r = !0;
        });
        let i = Ve(e, {
            readable: t,
            writable: n
        }, (o)=>{
            r = !o;
        });
        return {
            destroy: (o)=>{
                r || (r = !0, cf.destroyer(e, o || new _f("pipe")));
            },
            cleanup: i
        };
    }
    function Ef(e) {
        return yf(e[e.length - 1], "streams[stream.length - 1]"), e.pop();
    }
    function Rf(e) {
        if (be(e)) return e;
        if ($t(e)) return Af(e);
        throw new Yr("val", [
            "Readable",
            "Iterable",
            "AsyncIterable"
        ], e);
    }
    async function* Af(e) {
        jt || (jt = we()), yield* jt.prototype[sf].call(e);
    }
    async function Vr(e, t, n, { end: r  }) {
        let i, o = null, l = (a)=>{
            if (a && (i = a), o) {
                let c = o;
                o = null, c();
            }
        }, u = ()=>new uf((a, c)=>{
                i ? c(i) : o = ()=>{
                    i ? c(i) : a();
                };
            });
        t.on("drain", l);
        let f = Ve(t, {
            readable: !1
        }, l);
        try {
            t.writableNeedDrain && await u();
            for await (let a of e)t.write(a) || await u();
            r && t.end(), await u(), n();
        } catch (a) {
            n(i !== a ? hf(i, a) : a);
        } finally{
            f(), t.off("drain", l);
        }
    }
    function mf(...e) {
        return Kr(e, df(Ef(e)));
    }
    function Kr(e, t, n) {
        if (e.length === 1 && ff(e[0]) && (e = e[0]), e.length < 2) throw new bf("streams");
        let r = new Sf, i = r.signal, o = n?.signal, l = [];
        gf(o, "options.signal");
        function u() {
            d(new wf);
        }
        o?.addEventListener("abort", u);
        let f, a, c = [], s = 0;
        function b(_) {
            d(_, --s === 0);
        }
        function d(_, p) {
            if (_ && (!f || f.code === "ERR_STREAM_PREMATURE_CLOSE") && (f = _), !(!f && !p)) {
                for(; c.length;)c.shift()(f);
                o?.removeEventListener("abort", u), r.abort(), p && (f || l.forEach((I)=>I()), He.nextTick(t, f, a));
            }
        }
        let h;
        for(let _ = 0; _ < e.length; _++){
            let p = e[_], I = _ < e.length - 1, M = _ > 0, F = I || n?.end !== !1, re = _ === e.length - 1;
            if (Gr(p)) {
                let P = function(U) {
                    U && U.name !== "AbortError" && U.code !== "ERR_STREAM_PREMATURE_CLOSE" && b(U);
                };
                if (F) {
                    let { destroy: U , cleanup: ze  } = Hr(p, I, M);
                    c.push(U), Wt(p) && re && l.push(ze);
                }
                p.on("error", P), Wt(p) && re && l.push(()=>{
                    p.removeListener("error", P);
                });
            }
            if (_ === 0) if (typeof p == "function") {
                if (h = p({
                    signal: i
                }), !be(h)) throw new kt("Iterable, AsyncIterable or Stream", "source", h);
            } else be(p) || $t(p) ? h = p : h = Br.from(p);
            else if (typeof p == "function") if (h = Rf(h), h = p(h, {
                signal: i
            }), I) {
                if (!be(h, !0)) throw new kt("AsyncIterable", `transform[${_ - 1}]`, h);
            } else {
                var D;
                Ct || (Ct = Pt());
                let P = new Ct({
                    objectMode: !0
                }), U = (D = h) === null || D === void 0 ? void 0 : D.then;
                if (typeof U == "function") s++, U.call(h, (ie)=>{
                    a = ie, ie != null && P.write(ie), F && P.end(), He.nextTick(b);
                }, (ie)=>{
                    P.destroy(ie), He.nextTick(b, ie);
                });
                else if (be(h, !0)) s++, Vr(h, P, b, {
                    end: F
                });
                else throw new kt("AsyncIterable or Promise", "destination", h);
                h = P;
                let { destroy: ze , cleanup: _i  } = Hr(h, !1, !0);
                c.push(ze), re && l.push(_i);
            }
            else if (Gr(p)) {
                if ($t(h)) {
                    s += 2;
                    let P = Tf(h, p, b, {
                        end: F
                    });
                    Wt(p) && re && l.push(P);
                } else if (be(h)) s++, Vr(h, p, b, {
                    end: F
                });
                else throw new Yr("val", [
                    "Readable",
                    "Iterable",
                    "AsyncIterable"
                ], h);
                h = p;
            } else h = Br.from(p);
        }
        return (i != null && i.aborted || o != null && o.aborted) && He.nextTick(u), h;
    }
    function Tf(e, t, n, { end: r  }) {
        let i = !1;
        return t.on("close", ()=>{
            i || n(new pf);
        }), e.pipe(t, {
            end: r
        }), r ? e.once("end", ()=>{
            i = !0, t.end();
        }) : n(), Ve(e, {
            readable: !0,
            writable: !1
        }, (o)=>{
            let l = e._readableState;
            o && o.code === "ERR_STREAM_PREMATURE_CLOSE" && l && l.ended && !l.errored && !l.errorEmitted ? e.once("end", n).once("error", n) : n(o);
        }), Ve(t, {
            readable: !1,
            writable: !0
        }, n);
    }
    zr.exports = {
        pipelineImpl: Kr,
        pipeline: mf
    };
});
var ei = g((bu, Zr)=>{
    "use strict";
    var { pipeline: If  } = Ye(), Ke = v(), { destroyer: Mf  } = Z(), { isNodeStream: Nf , isReadable: Xr , isWritable: Jr  } = V(), { AbortError: Df , codes: { ERR_INVALID_ARG_VALUE: Qr , ERR_MISSING_ARGS: Of  }  } = O();
    Zr.exports = function(...t) {
        if (t.length === 0) throw new Of("streams");
        if (t.length === 1) return Ke.from(t[0]);
        let n = [
            ...t
        ];
        if (typeof t[0] == "function" && (t[0] = Ke.from(t[0])), typeof t[t.length - 1] == "function") {
            let d = t.length - 1;
            t[d] = Ke.from(t[d]);
        }
        for(let d = 0; d < t.length; ++d)if (!!Nf(t[d])) {
            if (d < t.length - 1 && !Xr(t[d])) throw new Qr(`streams[${d}]`, n[d], "must be readable");
            if (d > 0 && !Jr(t[d])) throw new Qr(`streams[${d}]`, n[d], "must be writable");
        }
        let r, i, o, l, u;
        function f(d) {
            let h = l;
            l = null, h ? h(d) : d ? u.destroy(d) : !b && !s && u.destroy();
        }
        let a = t[0], c = If(t, f), s = !!Jr(a), b = !!Xr(c);
        return u = new Ke({
            writableObjectMode: !!(a != null && a.writableObjectMode),
            readableObjectMode: !!(c != null && c.writableObjectMode),
            writable: s,
            readable: b
        }), s && (u._write = function(d, h, D) {
            a.write(d, h) ? D() : r = D;
        }, u._final = function(d) {
            a.end(), i = d;
        }, a.on("drain", function() {
            if (r) {
                let d = r;
                r = null, d();
            }
        }), c.on("finish", function() {
            if (i) {
                let d = i;
                i = null, d();
            }
        })), b && (c.on("readable", function() {
            if (o) {
                let d = o;
                o = null, d();
            }
        }), c.on("end", function() {
            u.push(null);
        }), u._read = function() {
            for(;;){
                let d = c.read();
                if (d === null) {
                    o = u._read;
                    return;
                }
                if (!u.push(d)) return;
            }
        }), u._destroy = function(d, h) {
            !d && l !== null && (d = new Df), o = null, r = null, i = null, l === null ? h(d) : (l = h, Mf(c, d));
        }, u;
    };
});
var vt = g((_u, ti)=>{
    "use strict";
    var { ArrayPrototypePop: qf , Promise: xf  } = m(), { isIterable: Lf , isNodeStream: Pf  } = V(), { pipelineImpl: kf  } = Ye(), { finished: Wf  } = Y();
    function Cf(...e) {
        return new xf((t, n)=>{
            let r, i, o = e[e.length - 1];
            if (o && typeof o == "object" && !Pf(o) && !Lf(o)) {
                let l = qf(e);
                r = l.signal, i = l.end;
            }
            kf(e, (l, u)=>{
                l ? n(l) : t(u);
            }, {
                signal: r,
                end: i
            });
        });
    }
    ti.exports = {
        finished: Wf,
        pipeline: Cf
    };
});
var di = g((pu, si)=>{
    var { Buffer: jf  } = __default3, { ObjectDefineProperty: H , ObjectKeys: ii , ReflectApply: oi  } = m(), { promisify: { custom: li  }  } = j(), { streamReturningOperators: ni , promiseReturningOperators: ri  } = xn(), { codes: { ERR_ILLEGAL_CONSTRUCTOR: ai  }  } = O(), $f = ei(), { pipeline: fi  } = Ye(), { destroyer: vf  } = Z(), ui = Y(), Ft = vt(), Ut = V(), R = si.exports = Le().Stream;
    R.isDisturbed = Ut.isDisturbed;
    R.isErrored = Ut.isErrored;
    R.isReadable = Ut.isReadable;
    R.Readable = we();
    for (let e of ii(ni)){
        let n = function(...r) {
            if (new.target) throw ai();
            return R.Readable.from(oi(t, this, r));
        };
        n;
        let t = ni[e];
        H(n, "name", {
            __proto__: null,
            value: t.name
        }), H(n, "length", {
            __proto__: null,
            value: t.length
        }), H(R.Readable.prototype, e, {
            __proto__: null,
            value: n,
            enumerable: !1,
            configurable: !0,
            writable: !0
        });
    }
    for (let e of ii(ri)){
        let n = function(...i) {
            if (new.target) throw ai();
            return oi(t, this, i);
        };
        n;
        let t = ri[e];
        H(n, "name", {
            __proto__: null,
            value: t.name
        }), H(n, "length", {
            __proto__: null,
            value: t.length
        }), H(R.Readable.prototype, e, {
            __proto__: null,
            value: n,
            enumerable: !1,
            configurable: !0,
            writable: !0
        });
    }
    R.Writable = Tt();
    R.Duplex = v();
    R.Transform = xt();
    R.PassThrough = Pt();
    R.pipeline = fi;
    var { addAbortSignal: Ff  } = ke();
    R.addAbortSignal = Ff;
    R.finished = ui;
    R.destroy = vf;
    R.compose = $f;
    H(R, "promises", {
        __proto__: null,
        configurable: !0,
        enumerable: !0,
        get () {
            return Ft;
        }
    });
    H(fi, li, {
        __proto__: null,
        enumerable: !0,
        get () {
            return Ft.pipeline;
        }
    });
    H(ui, li, {
        __proto__: null,
        enumerable: !0,
        get () {
            return Ft.finished;
        }
    });
    R.Stream = R;
    R._isUint8Array = function(t) {
        return t instanceof Uint8Array;
    };
    R._uint8ArrayToBuffer = function(t) {
        return jf.from(t.buffer, t.byteOffset, t.byteLength);
    };
});
var ci = g((wu, A)=>{
    "use strict";
    var T = di(), Bf = vt(), Gf = T.Readable.destroy;
    A.exports = T.Readable;
    A.exports._uint8ArrayToBuffer = T._uint8ArrayToBuffer;
    A.exports._isUint8Array = T._isUint8Array;
    A.exports.isDisturbed = T.isDisturbed;
    A.exports.isErrored = T.isErrored;
    A.exports.isReadable = T.isReadable;
    A.exports.Readable = T.Readable;
    A.exports.Writable = T.Writable;
    A.exports.Duplex = T.Duplex;
    A.exports.Transform = T.Transform;
    A.exports.PassThrough = T.PassThrough;
    A.exports.addAbortSignal = T.addAbortSignal;
    A.exports.finished = T.finished;
    A.exports.destroy = T.destroy;
    A.exports.destroy = Gf;
    A.exports.pipeline = T.pipeline;
    A.exports.compose = T.compose;
    Object.defineProperty(T, "promises", {
        configurable: !0,
        enumerable: !0,
        get () {
            return Bf;
        }
    });
    A.exports.Stream = T.Stream;
    A.exports.default = A.exports;
});
var bi = Ri(ci()), { _uint8ArrayToBuffer: yu , _isUint8Array: gu , isDisturbed: Su , isErrored: Eu , isReadable: Ru , Readable: Au , Writable: mu , Duplex: Tu , Transform: Iu , PassThrough: Mu , addAbortSignal: Nu , finished: Du , destroy: Ou , pipeline: qu , compose: xu , Stream: Lu  } = bi, { default: hi , ...Hf } = bi;
const process1 = __process$;
const { Buffer: Buffer1  } = __default3;
const Readable = Au;
const Writable = mu;
const Duplex = Tu;
function isReadableStream(object) {
    return object instanceof ReadableStream;
}
function isWritableStream(object) {
    return object instanceof WritableStream;
}
Readable.fromWeb = function(readableStream, options = kEmptyObject) {
    if (!isReadableStream(readableStream)) {
        throw new ERR_INVALID_ARG_TYPE("readableStream", "ReadableStream", readableStream);
    }
    validateObject(options, "options");
    const { highWaterMark , encoding , objectMode =false , signal  } = options;
    if (encoding !== undefined && !Buffer1.isEncoding(encoding)) {
        throw new ERR_INVALID_ARG_VALUE(encoding, "options.encoding");
    }
    validateBoolean(objectMode, "options.objectMode");
    const reader = readableStream.getReader();
    let closed = false;
    const readable = new Readable({
        objectMode,
        highWaterMark,
        encoding,
        signal,
        read () {
            reader.read().then((chunk)=>{
                if (chunk.done) {
                    readable.push(null);
                } else {
                    readable.push(chunk.value);
                }
            }, (error)=>destroy.call(readable, error));
        },
        destroy (error, callback) {
            function done() {
                try {
                    callback(error);
                } catch (error) {
                    process1.nextTick(()=>{
                        throw error;
                    });
                }
            }
            if (!closed) {
                reader.cancel(error).then(done, done);
                return;
            }
            done();
        }
    });
    reader.closed.then(()=>{
        closed = true;
        if (!isReadableEnded1(readable)) {
            readable.push(null);
        }
    }, (error)=>{
        closed = true;
        destroy.call(readable, error);
    });
    return readable;
};
Writable.fromWeb = function(writableStream, options = kEmptyObject) {
    if (!isWritableStream(writableStream)) {
        throw new ERR_INVALID_ARG_TYPE("writableStream", "WritableStream", writableStream);
    }
    validateObject(options, "options");
    const { highWaterMark , decodeStrings =true , objectMode =false , signal  } = options;
    validateBoolean(objectMode, "options.objectMode");
    validateBoolean(decodeStrings, "options.decodeStrings");
    const writer = writableStream.getWriter();
    let closed = false;
    const writable = new Writable({
        highWaterMark,
        objectMode,
        decodeStrings,
        signal,
        writev (chunks, callback) {
            function done(error) {
                error = error.filter((e)=>e);
                try {
                    callback(error.length === 0 ? undefined : error);
                } catch (error) {
                    process1.nextTick(()=>destroy.call(writable, error));
                }
            }
            writer.ready.then(()=>Promise.all(chunks.map((data)=>writer.write(data.chunk))).then(done, done), done);
        },
        write (chunk, encoding, callback) {
            if (typeof chunk === "string" && decodeStrings && !objectMode) {
                chunk = Buffer1.from(chunk, encoding);
                chunk = new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            }
            function done(error) {
                try {
                    callback(error);
                } catch (error) {
                    destroy(this, duplex, error);
                }
            }
            writer.ready.then(()=>writer.write(chunk).then(done, done), done);
        },
        destroy (error, callback) {
            function done() {
                try {
                    callback(error);
                } catch (error) {
                    process1.nextTick(()=>{
                        throw error;
                    });
                }
            }
            if (!closed) {
                if (error != null) {
                    writer.abort(error).then(done, done);
                } else {
                    writer.close().then(done, done);
                }
                return;
            }
            done();
        },
        final (callback) {
            function done(error) {
                try {
                    callback(error);
                } catch (error) {
                    process1.nextTick(()=>destroy.call(writable, error));
                }
            }
            if (!closed) {
                writer.close().then(done, done);
            }
        }
    });
    writer.closed.then(()=>{
        closed = true;
        if (!isWritableEnded(writable)) {
            destroy.call(writable, new ERR_STREAM_PREMATURE_CLOSE());
        }
    }, (error)=>{
        closed = true;
        destroy.call(writable, error);
    });
    return writable;
};
Duplex.fromWeb = function(pair, options = kEmptyObject) {
    validateObject(pair, "pair");
    const { readable: readableStream , writable: writableStream  } = pair;
    if (!isReadableStream(readableStream)) {
        throw new ERR_INVALID_ARG_TYPE("pair.readable", "ReadableStream", readableStream);
    }
    if (!isWritableStream(writableStream)) {
        throw new ERR_INVALID_ARG_TYPE("pair.writable", "WritableStream", writableStream);
    }
    validateObject(options, "options");
    const { allowHalfOpen =false , objectMode =false , encoding , decodeStrings =true , highWaterMark , signal  } = options;
    validateBoolean(objectMode, "options.objectMode");
    if (encoding !== undefined && !Buffer1.isEncoding(encoding)) {
        throw new ERR_INVALID_ARG_VALUE(encoding, "options.encoding");
    }
    const writer = writableStream.getWriter();
    const reader = readableStream.getReader();
    let writableClosed = false;
    let readableClosed = false;
    const duplex1 = new Duplex({
        allowHalfOpen,
        highWaterMark,
        objectMode,
        encoding,
        decodeStrings,
        signal,
        writev (chunks, callback) {
            function done(error) {
                error = error.filter((e)=>e);
                try {
                    callback(error.length === 0 ? undefined : error);
                } catch (error) {
                    process1.nextTick(()=>destroy(duplex1, error));
                }
            }
            writer.ready.then(()=>Promise.all(chunks.map((data)=>writer.write(data.chunk))).then(done, done), done);
        },
        write (chunk, encoding, callback) {
            if (typeof chunk === "string" && decodeStrings && !objectMode) {
                chunk = Buffer1.from(chunk, encoding);
                chunk = new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
            }
            function done(error) {
                try {
                    callback(error);
                } catch (error) {
                    destroy(duplex1, error);
                }
            }
            writer.ready.then(()=>writer.write(chunk).then(done, done), done);
        },
        final (callback) {
            function done(error) {
                try {
                    callback(error);
                } catch (error) {
                    process1.nextTick(()=>destroy(duplex1, error));
                }
            }
            if (!writableClosed) {
                writer.close().then(done, done);
            }
        },
        read () {
            reader.read().then((chunk)=>{
                if (chunk.done) {
                    duplex1.push(null);
                } else {
                    duplex1.push(chunk.value);
                }
            }, (error)=>destroy(duplex1, error));
        },
        destroy (error, callback) {
            function done() {
                try {
                    callback(error);
                } catch (error) {
                    process1.nextTick(()=>{
                        throw error;
                    });
                }
            }
            async function closeWriter() {
                if (!writableClosed) {
                    await writer.abort(error);
                }
            }
            async function closeReader() {
                if (!readableClosed) {
                    await reader.cancel(error);
                }
            }
            if (!writableClosed || !readableClosed) {
                Promise.all([
                    closeWriter(),
                    closeReader()
                ]).then(done, done);
                return;
            }
            done();
        }
    });
    writer.closed.then(()=>{
        writableClosed = true;
        if (!isWritableEnded(duplex1)) {
            destroy(duplex1, new ERR_STREAM_PREMATURE_CLOSE());
        }
    }, (error)=>{
        writableClosed = true;
        readableClosed = true;
        destroy(duplex1, error);
    });
    reader.closed.then(()=>{
        readableClosed = true;
        if (!isReadableEnded1(duplex1)) {
            duplex1.push(null);
        }
    }, (error)=>{
        writableClosed = true;
        readableClosed = true;
        destroy(duplex1, error);
    });
    return duplex1;
};
delete Readable.Duplex;
delete Readable.PassThrough;
delete Readable.Readable;
delete Readable.Stream;
delete Readable.Transform;
delete Readable.Writable;
delete Readable._isUint8Array;
delete Readable._uint8ArrayToBuffer;
delete Readable.addAbortSignal;
delete Readable.compose;
delete Readable.destroy;
delete Readable.finished;
delete Readable.isDisturbed;
delete Readable.isErrored;
delete Readable.isReadable;
delete Readable.pipeline;
function newReadableStreamFromStreamReadable(streamReadable, options = kEmptyObject) {
    if (typeof streamReadable?._readableState !== "object") {
        throw new ERR_INVALID_ARG_TYPE("streamReadable", "stream.Readable", streamReadable);
    }
    if (isDestroyed(streamReadable) || !isReadable1(streamReadable)) {
        const readable = new ReadableStream();
        readable.cancel();
        return readable;
    }
    const objectMode = streamReadable.readableObjectMode;
    const highWaterMark = streamReadable.readableHighWaterMark;
    const evaluateStrategyOrFallback = (strategy)=>{
        if (strategy) {
            return strategy;
        }
        if (objectMode) {
            return new CountQueuingStrategy({
                highWaterMark
            });
        }
        return {
            highWaterMark
        };
    };
    const strategy = evaluateStrategyOrFallback(options?.strategy);
    let controller;
    function onData(chunk) {
        if (Buffer1.isBuffer(chunk) && !objectMode) {
            chunk = new Uint8Array(chunk);
        }
        controller.enqueue(chunk);
        if (controller.desiredSize <= 0) {
            streamReadable.pause();
        }
    }
    streamReadable.pause();
    const cleanup = eos(streamReadable, (error)=>{
        if (error?.code === "ERR_STREAM_PREMATURE_CLOSE") {
            const err = new AbortError(undefined, {
                cause: error
            });
            error = err;
        }
        cleanup();
        streamReadable.on("error", ()=>{});
        if (error) {
            return controller.error(error);
        }
        controller.close();
    });
    streamReadable.on("data", onData);
    return new ReadableStream({
        start (c) {
            controller = c;
        },
        pull () {
            streamReadable.resume();
        },
        cancel (reason) {
            destroy(streamReadable, reason);
        }
    }, strategy);
}
function newWritableStreamFromStreamWritable(streamWritable) {
    if (typeof streamWritable?._writableState !== "object") {
        throw new ERR_INVALID_ARG_TYPE("streamWritable", "stream.Writable", streamWritable);
    }
    if (isDestroyed(streamWritable) || !isWritable1(streamWritable)) {
        const writable = new WritableStream();
        writable.close();
        return writable;
    }
    const highWaterMark = streamWritable.writableHighWaterMark;
    const strategy = streamWritable.writableObjectMode ? new CountQueuingStrategy({
        highWaterMark
    }) : {
        highWaterMark
    };
    let controller;
    let backpressurePromise;
    let closed;
    function onDrain() {
        if (backpressurePromise !== undefined) {
            backpressurePromise.resolve();
        }
    }
    const cleanup = eos(streamWritable, (error)=>{
        if (error?.code === "ERR_STREAM_PREMATURE_CLOSE") {
            const err = new AbortError(undefined, {
                cause: error
            });
            error = err;
        }
        cleanup();
        streamWritable.on("error", ()=>{});
        if (error != null) {
            if (backpressurePromise !== undefined) {
                backpressurePromise.reject(error);
            }
            if (closed !== undefined) {
                closed.reject(error);
                closed = undefined;
            }
            controller.error(error);
            controller = undefined;
            return;
        }
        if (closed !== undefined) {
            closed.resolve();
            closed = undefined;
            return;
        }
        controller.error(new AbortError());
        controller = undefined;
    });
    streamWritable.on("drain", onDrain);
    return new WritableStream({
        start (c) {
            controller = c;
        },
        async write (chunk) {
            if (streamWritable.writableNeedDrain || !streamWritable.write(chunk)) {
                backpressurePromise = createDeferredPromise();
                return backpressurePromise.promise.finally(()=>{
                    backpressurePromise = undefined;
                });
            }
        },
        abort (reason) {
            destroy(streamWritable, reason);
        },
        close () {
            if (closed === undefined && !isWritableEnded(streamWritable)) {
                closed = createDeferredPromise();
                streamWritable.end();
                return closed.promise;
            }
            controller = undefined;
            return Promise.resolve();
        }
    }, strategy);
}
function newReadableWritablePairFromDuplex(duplex1) {
    if (typeof duplex1?._writableState !== "object" || typeof duplex1?._readableState !== "object") {
        throw new ERR_INVALID_ARG_TYPE("duplex", "stream.Duplex", duplex1);
    }
    if (isDestroyed(duplex1)) {
        const writable = new WritableStream();
        const readable = new ReadableStream();
        writable.close();
        readable.cancel();
        return {
            readable,
            writable
        };
    }
    const writable = isWritable1(duplex1) ? newWritableStreamFromStreamWritable(duplex1) : new WritableStream();
    if (!isWritable1(duplex1)) {
        writable.close();
    }
    const readable = isReadable1(duplex1) ? newReadableStreamFromStreamReadable(duplex1) : new ReadableStream();
    if (!isReadable1(duplex1)) {
        readable.cancel();
    }
    return {
        writable,
        readable
    };
}
Readable.toWeb = newReadableStreamFromStreamReadable;
Writable.toWeb = newWritableStreamFromStreamWritable;
Duplex.toWeb = newReadableWritablePairFromDuplex;
const hexTable = new TextEncoder().encode("0123456789abcdef");
function encode2(src) {
    const dst = new Uint8Array(src.length * 2);
    for(let i = 0; i < dst.length; i++){
        const v = src[i];
        dst[i * 2] = hexTable[v >> 4];
        dst[i * 2 + 1] = hexTable[v & 0x0f];
    }
    return dst;
}
const getArrayBufferOrView = hideStackFrames((buffer, name, encoding)=>{
    if (isAnyArrayBuffer1(buffer)) {
        return buffer;
    }
    if (typeof buffer === "string") {
        if (encoding === "buffer") {
            encoding = "utf8";
        }
        return Buffer.from(buffer, encoding);
    }
    if (!isArrayBufferView(buffer)) {
        throw new ERR_INVALID_ARG_TYPE(name, [
            "string",
            "ArrayBuffer",
            "Buffer",
            "TypedArray",
            "DataView"
        ], buffer);
    }
    return buffer;
});
function isKeyObject1(obj) {
    return isKeyObject(obj);
}
function isCryptoKey1(obj) {
    return isCryptoKey(obj);
}
class KeyObject {
    [kKeyType];
    [kHandle];
    constructor(type, handle){
        if (type !== "secret" && type !== "public" && type !== "private") {
            throw new ERR_INVALID_ARG_VALUE("type", type);
        }
        if (typeof handle !== "object") {
            throw new ERR_INVALID_ARG_TYPE("handle", "object", handle);
        }
        this[kKeyType] = type;
        Object.defineProperty(this, kHandle, {
            value: handle,
            enumerable: false,
            configurable: false,
            writable: false
        });
    }
    get type() {
        return this[kKeyType];
    }
    get asymmetricKeyDetails() {
        notImplemented("crypto.KeyObject.prototype.asymmetricKeyDetails");
        return undefined;
    }
    get asymmetricKeyType() {
        notImplemented("crypto.KeyObject.prototype.asymmetricKeyType");
        return undefined;
    }
    get symmetricKeySize() {
        notImplemented("crypto.KeyObject.prototype.symmetricKeySize");
        return undefined;
    }
    static from(key) {
        if (!isCryptoKey1(key)) {
            throw new ERR_INVALID_ARG_TYPE("key", "CryptoKey", key);
        }
        notImplemented("crypto.KeyObject.prototype.from");
    }
    equals(otherKeyObject) {
        if (!isKeyObject1(otherKeyObject)) {
            throw new ERR_INVALID_ARG_TYPE("otherKeyObject", "KeyObject", otherKeyObject);
        }
        notImplemented("crypto.KeyObject.prototype.equals");
    }
    export(_options) {
        notImplemented("crypto.KeyObject.prototype.asymmetricKeyType");
    }
}
function createPrivateKey(_key) {
    notImplemented("crypto.createPrivateKey");
}
function createPublicKey(_key) {
    notImplemented("crypto.createPublicKey");
}
function getKeyTypes(allowKeyObject, bufferOnly = false) {
    const types = [
        "ArrayBuffer",
        "Buffer",
        "TypedArray",
        "DataView",
        "string",
        "KeyObject",
        "CryptoKey"
    ];
    if (bufferOnly) {
        return types.slice(0, 4);
    } else if (!allowKeyObject) {
        return types.slice(0, 5);
    }
    return types;
}
function prepareSecretKey(key, encoding, bufferOnly = false) {
    if (!bufferOnly) {
        if (isKeyObject1(key)) {
            if (key.type !== "secret") {
                throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(key.type, "secret");
            }
            return key[kHandle];
        } else if (isCryptoKey1(key)) {
            if (key.type !== "secret") {
                throw new ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE(key.type, "secret");
            }
            return key[kKeyObject][kHandle];
        }
    }
    if (typeof key !== "string" && !isArrayBufferView(key) && !isAnyArrayBuffer1(key)) {
        throw new ERR_INVALID_ARG_TYPE("key", getKeyTypes(!bufferOnly, bufferOnly), key);
    }
    return getArrayBufferOrView(key, "key", encoding);
}
function createSecretKey(_key, _encoding) {
    notImplemented("crypto.createSecretKey");
}
const coerceToBytes = (data)=>{
    if (data instanceof Uint8Array) {
        return data;
    } else if (typeof data === "string") {
        return new TextEncoder().encode(data);
    } else if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
    } else if (data instanceof ArrayBuffer) {
        return new Uint8Array(data);
    } else {
        throw new TypeError("expected data to be string | BufferSource");
    }
};
class Hash extends Iu {
    #context;
    constructor(algorithm, _opts){
        super({
            transform (chunk, _encoding, callback) {
                context.update(coerceToBytes(chunk));
                callback();
            },
            flush (callback) {
                this.push(context.digest(undefined));
                callback();
            }
        });
        if (typeof algorithm === "string") {
            algorithm = algorithm.toUpperCase();
            if (opensslToWebCryptoDigestNames[algorithm]) {
                algorithm = opensslToWebCryptoDigestNames[algorithm];
            }
            this.#context = new (instantiate()).DigestContext(algorithm);
        } else {
            this.#context = algorithm;
        }
        const context = this.#context;
    }
    copy() {
        return new Hash(this.#context.clone());
    }
    update(data, _encoding) {
        let bytes;
        if (typeof data === "string") {
            data = new TextEncoder().encode(data);
            bytes = coerceToBytes(data);
        } else {
            bytes = coerceToBytes(data);
        }
        this.#context.update(bytes);
        return this;
    }
    digest(encoding) {
        const digest = this.#context.digest(undefined);
        if (encoding === undefined) {
            return Buffer.from(digest);
        }
        switch(encoding){
            case "hex":
                return new TextDecoder().decode(encode2(new Uint8Array(digest)));
            case "binary":
                return String.fromCharCode(...digest);
            case "base64":
                return encode(digest);
            case "base64url":
                return encode1(digest);
            case "buffer":
                return Buffer.from(digest);
            default:
                return Buffer.from(digest).toString(encoding);
        }
    }
}
function Hmac(hmac, key, options) {
    return new HmacImpl(hmac, key, options);
}
class HmacImpl extends Iu {
    #ipad;
    #opad;
    #ZEROES = Buffer.alloc(128);
    #algorithm;
    #hash;
    constructor(hmac, key, options){
        super({
            transform (chunk, encoding, callback) {
                self.update(coerceToBytes(chunk), encoding);
                callback();
            },
            flush (callback) {
                this.push(self.digest());
                callback();
            }
        });
        const self = this;
        if (key instanceof KeyObject) {
            notImplemented("Hmac: KeyObject key is not implemented");
        }
        validateString(hmac, "hmac");
        const u8Key = prepareSecretKey(key, options?.encoding);
        const alg = hmac.toLowerCase();
        this.#hash = new Hash(alg, options);
        this.#algorithm = alg;
        const blockSize = alg === "sha512" || alg === "sha384" ? 128 : 64;
        const keySize = u8Key.length;
        let bufKey;
        if (keySize > blockSize) {
            bufKey = this.#hash.update(u8Key).digest();
        } else {
            bufKey = Buffer.concat([
                u8Key,
                this.#ZEROES
            ], blockSize);
        }
        this.#ipad = Buffer.allocUnsafe(blockSize);
        this.#opad = Buffer.allocUnsafe(blockSize);
        for(let i = 0; i < blockSize; i++){
            this.#ipad[i] = bufKey[i] ^ 0x36;
            this.#opad[i] = bufKey[i] ^ 0x5C;
        }
        this.#hash = new Hash(alg);
        this.#hash.update(this.#ipad);
    }
    digest(encoding) {
        const result = this.#hash.digest();
        return new Hash(this.#algorithm).update(this.#opad).update(result).digest(encoding);
    }
    update(data, inputEncoding) {
        this.#hash.update(data, inputEncoding);
        return this;
    }
}
Hmac.prototype = HmacImpl.prototype;
const opensslToWebCryptoDigestNames = {
    BLAKE2B256: "BLAKE2B-256",
    BLAKE2B384: "BLAKE2B-384",
    BLAKE2B512: "BLAKE2B",
    BLAKE2S256: "BLAKE2S",
    RIPEMD160: "RIPEMD-160",
    RMD160: "RIPEMD-160",
    SHA1: "SHA-1",
    SHA224: "SHA-224",
    SHA256: "SHA-256",
    SHA384: "SHA-384",
    SHA512: "SHA-512"
};
function createHash(algorithm, opts) {
    return new Hash(algorithm, opts);
}
const MAX_ALLOC = Math.pow(2, 30) - 1;
const createHasher = (algorithm)=>(value)=>Buffer.from(createHash(algorithm).update(value).digest());
function getZeroes(zeros) {
    return Buffer.alloc(zeros);
}
const sizes = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
};
function toBuffer(bufferable) {
    if (bufferable instanceof Uint8Array || typeof bufferable === "string") {
        return Buffer.from(bufferable);
    } else {
        return Buffer.from(bufferable.buffer);
    }
}
class Hmac1 {
    hash;
    ipad1;
    opad;
    alg;
    blocksize;
    size;
    ipad2;
    constructor(alg, key, saltLen){
        this.hash = createHasher(alg);
        const blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
        if (key.length > blocksize) {
            key = this.hash(key);
        } else if (key.length < blocksize) {
            key = Buffer.concat([
                key,
                getZeroes(blocksize - key.length)
            ], blocksize);
        }
        const ipad = Buffer.allocUnsafe(blocksize + sizes[alg]);
        const opad = Buffer.allocUnsafe(blocksize + sizes[alg]);
        for(let i = 0; i < blocksize; i++){
            ipad[i] = key[i] ^ 0x36;
            opad[i] = key[i] ^ 0x5c;
        }
        const ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4);
        ipad.copy(ipad1, 0, 0, blocksize);
        this.ipad1 = ipad1;
        this.ipad2 = ipad;
        this.opad = opad;
        this.alg = alg;
        this.blocksize = blocksize;
        this.size = sizes[alg];
    }
    run(data, ipad) {
        data.copy(ipad, this.blocksize);
        const h = this.hash(ipad);
        h.copy(this.opad, this.blocksize);
        return this.hash(this.opad);
    }
}
function pbkdf2Sync(password, salt, iterations, keylen, digest = "sha1") {
    if (typeof iterations !== "number" || iterations < 0) {
        throw new TypeError("Bad iterations");
    }
    if (typeof keylen !== "number" || keylen < 0 || keylen > MAX_ALLOC) {
        throw new TypeError("Bad key length");
    }
    const bufferedPassword = toBuffer(password);
    const bufferedSalt = toBuffer(salt);
    const hmac = new Hmac1(digest, bufferedPassword, bufferedSalt.length);
    const DK = Buffer.allocUnsafe(keylen);
    const block1 = Buffer.allocUnsafe(bufferedSalt.length + 4);
    bufferedSalt.copy(block1, 0, 0, bufferedSalt.length);
    let destPos = 0;
    const hLen = sizes[digest];
    const l = Math.ceil(keylen / hLen);
    for(let i = 1; i <= l; i++){
        block1.writeUInt32BE(i, bufferedSalt.length);
        const T = hmac.run(block1, hmac.ipad1);
        let U = T;
        for(let j = 1; j < iterations; j++){
            U = hmac.run(U, hmac.ipad2);
            for(let k = 0; k < hLen; k++)T[k] ^= U[k];
        }
        T.copy(DK, destPos);
        destPos += hLen;
    }
    return DK;
}
function pbkdf2(password, salt, iterations, keylen, digest = "sha1", callback) {
    setTimeout(()=>{
        let err = null, res;
        try {
            res = pbkdf2Sync(password, salt, iterations, keylen, digest);
        } catch (e) {
            err = e;
        }
        if (err) {
            callback(err instanceof Error ? err : new Error("[non-error thrown]"));
        } else {
            callback(null, res);
        }
    }, 0);
}
const fixOpts = (opts)=>{
    const out = {
        N: 16384,
        p: 1,
        r: 8,
        maxmem: 32 << 20
    };
    if (!opts) return out;
    if (opts.N) out.N = opts.N;
    else if (opts.cost) out.N = opts.cost;
    if (opts.p) out.p = opts.p;
    else if (opts.parallelization) out.p = opts.parallelization;
    if (opts.r) out.r = opts.r;
    else if (opts.blockSize) out.r = opts.blockSize;
    if (opts.maxmem) out.maxmem = opts.maxmem;
    return out;
};
function blockxor(S, Si, D, Di, len) {
    let i = -1;
    while(++i < len)D[Di + i] ^= S[Si + i];
}
function arraycopy(src, srcPos, dest, destPos, length) {
    src.copy(dest, destPos, srcPos, srcPos + length);
}
const R = (a, b)=>a << b | a >>> 32 - b;
class ScryptRom {
    B;
    r;
    N;
    p;
    XY;
    V;
    B32;
    x;
    _X;
    constructor(b, r, N, p){
        this.B = b;
        this.r = r;
        this.N = N;
        this.p = p;
        this.XY = Buffer.allocUnsafe(256 * r);
        this.V = Buffer.allocUnsafe(128 * r * N);
        this.B32 = new Int32Array(16);
        this.x = new Int32Array(16);
        this._X = Buffer.allocUnsafe(64);
    }
    run() {
        const p = this.p | 0;
        const r = this.r | 0;
        for(let i = 0; i < p; i++)this.scryptROMix(i, r);
        return this.B;
    }
    scryptROMix(i, r) {
        const blockStart = i * 128 * r;
        const offset = (2 * r - 1) * 64;
        const blockLen = 128 * r;
        const B = this.B;
        const N = this.N | 0;
        const V = this.V;
        const XY = this.XY;
        B.copy(XY, 0, blockStart, blockStart + blockLen);
        for(let i1 = 0; i1 < N; i1++){
            XY.copy(V, i1 * blockLen, 0, blockLen);
            this.blockmix_salsa8(blockLen);
        }
        let j;
        for(let i2 = 0; i2 < N; i2++){
            j = XY.readUInt32LE(offset) & N - 1;
            blockxor(V, j * blockLen, XY, 0, blockLen);
            this.blockmix_salsa8(blockLen);
        }
        XY.copy(B, blockStart, 0, blockLen);
    }
    blockmix_salsa8(blockLen) {
        const BY = this.XY;
        const r = this.r;
        const _X = this._X;
        arraycopy(BY, (2 * r - 1) * 64, _X, 0, 64);
        let i;
        for(i = 0; i < 2 * r; i++){
            blockxor(BY, i * 64, _X, 0, 64);
            this.salsa20_8();
            arraycopy(_X, 0, BY, blockLen + i * 64, 64);
        }
        for(i = 0; i < r; i++){
            arraycopy(BY, blockLen + i * 2 * 64, BY, i * 64, 64);
            arraycopy(BY, blockLen + (i * 2 + 1) * 64, BY, (i + r) * 64, 64);
        }
    }
    salsa20_8() {
        const B32 = this.B32;
        const B = this._X;
        const x = this.x;
        let i;
        for(i = 0; i < 16; i++){
            B32[i] = (B[i * 4 + 0] & 0xff) << 0;
            B32[i] |= (B[i * 4 + 1] & 0xff) << 8;
            B32[i] |= (B[i * 4 + 2] & 0xff) << 16;
            B32[i] |= (B[i * 4 + 3] & 0xff) << 24;
        }
        for(i = 0; i < 16; i++)x[i] = B32[i];
        for(i = 0; i < 4; i++){
            x[4] ^= R(x[0] + x[12], 7);
            x[8] ^= R(x[4] + x[0], 9);
            x[12] ^= R(x[8] + x[4], 13);
            x[0] ^= R(x[12] + x[8], 18);
            x[9] ^= R(x[5] + x[1], 7);
            x[13] ^= R(x[9] + x[5], 9);
            x[1] ^= R(x[13] + x[9], 13);
            x[5] ^= R(x[1] + x[13], 18);
            x[14] ^= R(x[10] + x[6], 7);
            x[2] ^= R(x[14] + x[10], 9);
            x[6] ^= R(x[2] + x[14], 13);
            x[10] ^= R(x[6] + x[2], 18);
            x[3] ^= R(x[15] + x[11], 7);
            x[7] ^= R(x[3] + x[15], 9);
            x[11] ^= R(x[7] + x[3], 13);
            x[15] ^= R(x[11] + x[7], 18);
            x[1] ^= R(x[0] + x[3], 7);
            x[2] ^= R(x[1] + x[0], 9);
            x[3] ^= R(x[2] + x[1], 13);
            x[0] ^= R(x[3] + x[2], 18);
            x[6] ^= R(x[5] + x[4], 7);
            x[7] ^= R(x[6] + x[5], 9);
            x[4] ^= R(x[7] + x[6], 13);
            x[5] ^= R(x[4] + x[7], 18);
            x[11] ^= R(x[10] + x[9], 7);
            x[8] ^= R(x[11] + x[10], 9);
            x[9] ^= R(x[8] + x[11], 13);
            x[10] ^= R(x[9] + x[8], 18);
            x[12] ^= R(x[15] + x[14], 7);
            x[13] ^= R(x[12] + x[15], 9);
            x[14] ^= R(x[13] + x[12], 13);
            x[15] ^= R(x[14] + x[13], 18);
        }
        for(i = 0; i < 16; i++)B32[i] += x[i];
        let bi;
        for(i = 0; i < 16; i++){
            bi = i * 4;
            B[bi + 0] = B32[i] >> 0 & 0xff;
            B[bi + 1] = B32[i] >> 8 & 0xff;
            B[bi + 2] = B32[i] >> 16 & 0xff;
            B[bi + 3] = B32[i] >> 24 & 0xff;
        }
    }
    clean() {
        this.XY.fill(0);
        this.V.fill(0);
        this._X.fill(0);
        this.B.fill(0);
        for(let i = 0; i < 16; i++){
            this.B32[i] = 0;
            this.x[i] = 0;
        }
    }
}
function scryptSync(password, salt, keylen, _opts) {
    const { N , r , p , maxmem  } = fixOpts(_opts);
    const blen = p * 128 * r;
    if (32 * r * (N + 2) * 4 + blen > maxmem) {
        throw new Error("excedes max memory");
    }
    const b = pbkdf2Sync(password, salt, 1, blen, "sha256");
    const scryptRom = new ScryptRom(b, r, N, p);
    const out = scryptRom.run();
    const fin = pbkdf2Sync(password, out, 1, keylen, "sha256");
    scryptRom.clean();
    return fin;
}
function scrypt(password, salt, keylen, _opts, cb) {
    if (!cb) {
        cb = _opts;
        _opts = null;
    }
    const { N , r , p , maxmem  } = fixOpts(_opts);
    const blen = p * 128 * r;
    if (32 * r * (N + 2) * 4 + blen > maxmem) {
        throw new Error("excedes max memory");
    }
    try {
        const b = pbkdf2Sync(password, salt, 1, blen, "sha256");
        const scryptRom = new ScryptRom(b, r, N, p);
        const out = scryptRom.run();
        const result = pbkdf2Sync(password, out, 1, keylen, "sha256");
        scryptRom.clean();
        cb(null, result);
    } catch (err) {
        return cb(err);
    }
}
const encrypt = function(self, block) {
    return self._cipher.encryptBlock(block);
};
const decrypt = function(self, block) {
    return self._cipher.decryptBlock(block);
};
const mod10 = {
    encrypt: encrypt,
    decrypt: decrypt
};
function xor(a, b) {
    const length = Math.min(a.length, b.length);
    const buffer = Buffer.allocUnsafe(length);
    for(let i = 0; i < length; ++i){
        buffer[i] = a[i] ^ b[i];
    }
    return buffer;
}
const encrypt1 = function(self, block) {
    const data = xor(block, self._prev);
    self._prev = self._cipher.encryptBlock(data);
    return self._prev;
};
const decrypt1 = function(self, block) {
    const pad = self._prev;
    self._prev = block;
    const out = self._cipher.decryptBlock(block);
    return xor(out, pad);
};
const mod11 = {
    encrypt: encrypt1,
    decrypt: decrypt1
};
function encryptStart(self, data, decrypt) {
    const len = data.length;
    const out = xor(data, self._cache);
    self._cache = self._cache.slice(len);
    self._prev = Buffer.concat([
        self._prev,
        decrypt ? data : out
    ]);
    return out;
}
const encrypt2 = function(self, data, decrypt) {
    let out = Buffer.allocUnsafe(0);
    let len;
    while(data.length){
        if (self._cache.length === 0) {
            self._cache = self._cipher.encryptBlock(self._prev);
            self._prev = Buffer.allocUnsafe(0);
        }
        if (self._cache.length <= data.length) {
            len = self._cache.length;
            out = Buffer.concat([
                out,
                encryptStart(self, data.slice(0, len), decrypt)
            ]);
            data = data.slice(len);
        } else {
            out = Buffer.concat([
                out,
                encryptStart(self, data, decrypt)
            ]);
            break;
        }
    }
    return out;
};
const mod12 = {
    encrypt: encrypt2
};
function encryptByte(self, byteParam, decrypt) {
    const pad = self._cipher.encryptBlock(self._prev);
    const out = pad[0] ^ byteParam;
    self._prev = Buffer.concat([
        self._prev.slice(1),
        Buffer.from([
            decrypt ? byteParam : out
        ])
    ]);
    return out;
}
const encrypt3 = function(self, chunk, decrypt) {
    const len = chunk.length;
    const out = Buffer.allocUnsafe(len);
    let i = -1;
    while(++i < len){
        out[i] = encryptByte(self, chunk[i], decrypt);
    }
    return out;
};
const mod13 = {
    encrypt: encrypt3
};
function encryptByte1(self, byteParam, decrypt) {
    let pad;
    let i = -1;
    let out = 0;
    let bit, value;
    while(++i < 8){
        pad = self._cipher.encryptBlock(self._prev);
        bit = byteParam & 1 << 7 - i ? 0x80 : 0;
        value = pad[0] ^ bit;
        out += (value & 0x80) >> i % 8;
        self._prev = shiftIn(self._prev, decrypt ? bit : value);
    }
    return out;
}
function shiftIn(buffer, value) {
    const len = buffer.length;
    let i = -1;
    const out = Buffer.allocUnsafe(buffer.length);
    buffer = Buffer.concat([
        buffer,
        Buffer.from([
            value
        ])
    ]);
    while(++i < len){
        out[i] = buffer[i] << 1 | buffer[i + 1] >> 7;
    }
    return out;
}
const encrypt4 = function(self, chunk, decrypt) {
    const len = chunk.length;
    const out = Buffer.allocUnsafe(len);
    let i = -1;
    while(++i < len){
        out[i] = encryptByte1(self, chunk[i], decrypt);
    }
    return out;
};
const mod14 = {
    encrypt: encrypt4
};
function getBlock(self) {
    self._prev = self._cipher.encryptBlock(self._prev);
    return self._prev;
}
const encrypt5 = function(self, chunk) {
    while(self._cache.length < chunk.length){
        self._cache = Buffer.concat([
            self._cache,
            getBlock(self)
        ]);
    }
    const pad = self._cache.slice(0, chunk.length);
    self._cache = self._cache.slice(chunk.length);
    return xor(chunk, pad);
};
const mod15 = {
    encrypt: encrypt5
};
function incr32(iv) {
    let len = iv.length;
    let item;
    while(len--){
        item = iv.readUInt8(len);
        if (item === 255) {
            iv.writeUInt8(0, len);
        } else {
            item++;
            iv.writeUInt8(item, len);
            break;
        }
    }
}
function getBlock1(self) {
    const out = self._cipher.encryptBlockRaw(self._prev);
    incr32(self._prev);
    return out;
}
const blockSize = 16;
const encrypt6 = function(self, chunk) {
    const chunkNum = Math.ceil(chunk.length / 16);
    const start = self._cache.length;
    self._cache = Buffer.concat([
        self._cache,
        Buffer.allocUnsafe(chunkNum * blockSize)
    ]);
    for(let i = 0; i < chunkNum; i++){
        const out = getBlock1(self);
        const offset = start + i * 16;
        self._cache.writeUInt32BE(out[0], offset + 0);
        self._cache.writeUInt32BE(out[1], offset + 4);
        self._cache.writeUInt32BE(out[2], offset + 8);
        self._cache.writeUInt32BE(out[3], offset + 12);
    }
    const pad = self._cache.slice(0, chunk.length);
    self._cache = self._cache.slice(chunk.length);
    return xor(chunk, pad);
};
const mod16 = {
    encrypt: encrypt6
};
const modeModules = {
    ECB: mod10,
    CBC: mod11,
    CFB: mod12,
    CFB8: mod13,
    CFB1: mod14,
    OFB: mod15,
    CTR: mod16,
    GCM: mod16
};
const MODES = {
    "aes-128-ecb": {
        "cipher": "AES",
        "key": 128,
        "iv": 0,
        "mode": "ECB",
        "type": "block"
    },
    "aes-192-ecb": {
        "cipher": "AES",
        "key": 192,
        "iv": 0,
        "mode": "ECB",
        "type": "block"
    },
    "aes-256-ecb": {
        "cipher": "AES",
        "key": 256,
        "iv": 0,
        "mode": "ECB",
        "type": "block"
    },
    "aes-128-cbc": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes-192-cbc": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes-256-cbc": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes128": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes192": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes256": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CBC",
        "type": "block"
    },
    "aes-128-cfb": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CFB",
        "type": "stream"
    },
    "aes-192-cfb": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CFB",
        "type": "stream"
    },
    "aes-256-cfb": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CFB",
        "type": "stream"
    },
    "aes-128-cfb8": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CFB8",
        "type": "stream"
    },
    "aes-192-cfb8": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CFB8",
        "type": "stream"
    },
    "aes-256-cfb8": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CFB8",
        "type": "stream"
    },
    "aes-128-cfb1": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CFB1",
        "type": "stream"
    },
    "aes-192-cfb1": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CFB1",
        "type": "stream"
    },
    "aes-256-cfb1": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CFB1",
        "type": "stream"
    },
    "aes-128-ofb": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "OFB",
        "type": "stream"
    },
    "aes-192-ofb": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "OFB",
        "type": "stream"
    },
    "aes-256-ofb": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "OFB",
        "type": "stream"
    },
    "aes-128-ctr": {
        "cipher": "AES",
        "key": 128,
        "iv": 16,
        "mode": "CTR",
        "type": "stream"
    },
    "aes-192-ctr": {
        "cipher": "AES",
        "key": 192,
        "iv": 16,
        "mode": "CTR",
        "type": "stream"
    },
    "aes-256-ctr": {
        "cipher": "AES",
        "key": 256,
        "iv": 16,
        "mode": "CTR",
        "type": "stream"
    },
    "aes-128-gcm": {
        "cipher": "AES",
        "key": 128,
        "iv": 12,
        "mode": "GCM",
        "type": "auth"
    },
    "aes-192-gcm": {
        "cipher": "AES",
        "key": 192,
        "iv": 12,
        "mode": "GCM",
        "type": "auth"
    },
    "aes-256-gcm": {
        "cipher": "AES",
        "key": 256,
        "iv": 12,
        "mode": "GCM",
        "type": "auth"
    }
};
for (const mode of Object.values(MODES)){
    mode.module = modeModules[mode.mode];
}
function asUInt32Array(buf) {
    if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
    var len = buf.length / 4 | 0;
    var out = new Array(len);
    for(var i = 0; i < len; i++){
        out[i] = buf.readUInt32BE(i * 4);
    }
    return out;
}
function scrubVec(v) {
    for(var i = 0; i < v.length; v++){
        v[i] = 0;
    }
}
function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {
    var SUB_MIX0 = SUB_MIX[0];
    var SUB_MIX1 = SUB_MIX[1];
    var SUB_MIX2 = SUB_MIX[2];
    var SUB_MIX3 = SUB_MIX[3];
    var s0 = M[0] ^ keySchedule[0];
    var s1 = M[1] ^ keySchedule[1];
    var s2 = M[2] ^ keySchedule[2];
    var s3 = M[3] ^ keySchedule[3];
    var t0, t1, t2, t3;
    var ksRow = 4;
    for(var round = 1; round < nRounds; round++){
        t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 0xff] ^ SUB_MIX2[s2 >>> 8 & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++];
        t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 0xff] ^ SUB_MIX2[s3 >>> 8 & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++];
        t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 0xff] ^ SUB_MIX2[s0 >>> 8 & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++];
        t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 0xff] ^ SUB_MIX2[s1 >>> 8 & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++];
        s0 = t0;
        s1 = t1;
        s2 = t2;
        s3 = t3;
    }
    t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 0xff] << 16 | SBOX[s2 >>> 8 & 0xff] << 8 | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
    t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 0xff] << 16 | SBOX[s3 >>> 8 & 0xff] << 8 | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
    t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 0xff] << 16 | SBOX[s0 >>> 8 & 0xff] << 8 | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
    t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 0xff] << 16 | SBOX[s1 >>> 8 & 0xff] << 8 | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
    t0 = t0 >>> 0;
    t1 = t1 >>> 0;
    t2 = t2 >>> 0;
    t3 = t3 >>> 0;
    return [
        t0,
        t1,
        t2,
        t3
    ];
}
var RCON = [
    0x00,
    0x01,
    0x02,
    0x04,
    0x08,
    0x10,
    0x20,
    0x40,
    0x80,
    0x1b,
    0x36
];
var G = function() {
    var d = new Array(256);
    for(var j = 0; j < 256; j++){
        if (j < 128) {
            d[j] = j << 1;
        } else {
            d[j] = j << 1 ^ 0x11b;
        }
    }
    var SBOX = [];
    var INV_SBOX = [];
    var SUB_MIX = [
        [],
        [],
        [],
        []
    ];
    var INV_SUB_MIX = [
        [],
        [],
        [],
        []
    ];
    var x = 0;
    var xi = 0;
    for(var i = 0; i < 256; ++i){
        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
        SBOX[x] = sx;
        INV_SBOX[sx] = x;
        var x2 = d[x];
        var x4 = d[x2];
        var x8 = d[x4];
        var t = d[sx] * 0x101 ^ sx * 0x1010100;
        SUB_MIX[0][x] = t << 24 | t >>> 8;
        SUB_MIX[1][x] = t << 16 | t >>> 16;
        SUB_MIX[2][x] = t << 8 | t >>> 24;
        SUB_MIX[3][x] = t;
        t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
        INV_SUB_MIX[0][sx] = t << 24 | t >>> 8;
        INV_SUB_MIX[1][sx] = t << 16 | t >>> 16;
        INV_SUB_MIX[2][sx] = t << 8 | t >>> 24;
        INV_SUB_MIX[3][sx] = t;
        if (x === 0) {
            x = xi = 1;
        } else {
            x = x2 ^ d[d[d[x8 ^ x2]]];
            xi ^= d[d[xi]];
        }
    }
    return {
        SBOX: SBOX,
        INV_SBOX: INV_SBOX,
        SUB_MIX: SUB_MIX,
        INV_SUB_MIX: INV_SUB_MIX
    };
}();
function AES(key) {
    this._key = asUInt32Array(key);
    this._reset();
}
AES.blockSize = 4 * 4;
AES.keySize = 256 / 8;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;
AES.prototype._reset = function() {
    var keyWords = this._key;
    var keySize = keyWords.length;
    var nRounds = keySize + 6;
    var ksRows = (nRounds + 1) * 4;
    var keySchedule = [];
    for(var k = 0; k < keySize; k++){
        keySchedule[k] = keyWords[k];
    }
    for(k = keySize; k < ksRows; k++){
        var t = keySchedule[k - 1];
        if (k % keySize === 0) {
            t = t << 8 | t >>> 24;
            t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 0xff] << 16 | G.SBOX[t >>> 8 & 0xff] << 8 | G.SBOX[t & 0xff];
            t ^= RCON[k / keySize | 0] << 24;
        } else if (keySize > 6 && k % keySize === 4) {
            t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 0xff] << 16 | G.SBOX[t >>> 8 & 0xff] << 8 | G.SBOX[t & 0xff];
        }
        keySchedule[k] = keySchedule[k - keySize] ^ t;
    }
    var invKeySchedule = [];
    for(var ik = 0; ik < ksRows; ik++){
        var ksR = ksRows - ik;
        var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];
        if (ik < 4 || ksR <= 4) {
            invKeySchedule[ik] = tt;
        } else {
            invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt >>> 16 & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[tt >>> 8 & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]];
        }
    }
    this._nRounds = nRounds;
    this._keySchedule = keySchedule;
    this._invKeySchedule = invKeySchedule;
};
AES.prototype.encryptBlockRaw = function(M) {
    M = asUInt32Array(M);
    return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
};
AES.prototype.encryptBlock = function(M) {
    var out = this.encryptBlockRaw(M);
    var buf = Buffer.allocUnsafe(16);
    buf.writeUInt32BE(out[0], 0);
    buf.writeUInt32BE(out[1], 4);
    buf.writeUInt32BE(out[2], 8);
    buf.writeUInt32BE(out[3], 12);
    return buf;
};
AES.prototype.decryptBlock = function(M) {
    M = asUInt32Array(M);
    var m1 = M[1];
    M[1] = M[3];
    M[3] = m1;
    var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds);
    var buf = Buffer.allocUnsafe(16);
    buf.writeUInt32BE(out[0], 0);
    buf.writeUInt32BE(out[3], 4);
    buf.writeUInt32BE(out[2], 8);
    buf.writeUInt32BE(out[1], 12);
    return buf;
};
AES.prototype.scrub = function() {
    scrubVec(this._keySchedule);
    scrubVec(this._invKeySchedule);
    scrubVec(this._key);
};
function CipherBase(hashMode) {
    Iu.call(this);
    this.hashMode = typeof hashMode === "string";
    if (this.hashMode) {
        this[hashMode] = this._finalOrDigest;
    } else {
        this.final = this._finalOrDigest;
    }
    if (this._final) {
        this.__final = this._final;
        this._final = null;
    }
    this._decoder = null;
    this._encoding = null;
}
CipherBase.prototype = Object.create(Iu.prototype, {
    constructor: {
        value: CipherBase,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
CipherBase.prototype.update = function(data, inputEnc, outputEnc) {
    if (typeof data === "string") {
        data = Buffer.from(data, inputEnc);
    }
    var outData = this._update(data);
    if (this.hashMode) return this;
    if (outputEnc) {
        outData = this._toString(outData, outputEnc);
    }
    return outData;
};
CipherBase.prototype.setAutoPadding = function() {};
CipherBase.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
};
CipherBase.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
};
CipherBase.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
};
CipherBase.prototype._transform = function(data, _, next) {
    var err;
    try {
        if (this.hashMode) {
            this._update(data);
        } else {
            this.push(this._update(data));
        }
    } catch (e) {
        err = e;
    } finally{
        next(err);
    }
};
CipherBase.prototype._flush = function(done) {
    var err;
    try {
        this.push(this.__final());
    } catch (e) {
        err = e;
    }
    done(err);
};
CipherBase.prototype._finalOrDigest = function(outputEnc) {
    var outData = this.__final() || Buffer.alloc(0);
    if (outputEnc) {
        outData = this._toString(outData, outputEnc, true);
    }
    return outData;
};
CipherBase.prototype._toString = function(value, enc, fin) {
    if (!this._decoder) {
        this._decoder = new StringDecoder(enc);
        this._encoding = enc;
    }
    if (this._encoding !== enc) throw new Error("can't switch encodings");
    var out = this._decoder.write(value);
    if (fin) {
        out += this._decoder.end();
    }
    return out;
};
var ZEROES = Buffer.alloc(16, 0);
function toArray(buf) {
    return [
        buf.readUInt32BE(0),
        buf.readUInt32BE(4),
        buf.readUInt32BE(8),
        buf.readUInt32BE(12)
    ];
}
function fromArray(out) {
    var buf = Buffer.allocUnsafe(16);
    buf.writeUInt32BE(out[0] >>> 0, 0);
    buf.writeUInt32BE(out[1] >>> 0, 4);
    buf.writeUInt32BE(out[2] >>> 0, 8);
    buf.writeUInt32BE(out[3] >>> 0, 12);
    return buf;
}
function GHASH(key) {
    this.h = key;
    this.state = Buffer.alloc(16, 0);
    this.cache = Buffer.allocUnsafe(0);
}
GHASH.prototype.ghash = function(block) {
    var i = -1;
    while(++i < block.length){
        this.state[i] ^= block[i];
    }
    this._multiply();
};
GHASH.prototype._multiply = function() {
    var Vi = toArray(this.h);
    var Zi = [
        0,
        0,
        0,
        0
    ];
    var j, xi, lsbVi;
    var i = -1;
    while(++i < 128){
        xi = (this.state[~~(i / 8)] & 1 << 7 - i % 8) !== 0;
        if (xi) {
            Zi[0] ^= Vi[0];
            Zi[1] ^= Vi[1];
            Zi[2] ^= Vi[2];
            Zi[3] ^= Vi[3];
        }
        lsbVi = (Vi[3] & 1) !== 0;
        for(j = 3; j > 0; j--){
            Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;
        }
        Vi[0] = Vi[0] >>> 1;
        if (lsbVi) {
            Vi[0] = Vi[0] ^ 0xe1 << 24;
        }
    }
    this.state = fromArray(Zi);
};
GHASH.prototype.update = function(buf) {
    this.cache = Buffer.concat([
        this.cache,
        buf
    ]);
    var chunk;
    while(this.cache.length >= 16){
        chunk = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        this.ghash(chunk);
    }
};
GHASH.prototype.final = function(abl, bl) {
    if (this.cache.length) {
        this.ghash(Buffer.concat([
            this.cache,
            ZEROES
        ], 16));
    }
    this.ghash(fromArray([
        0,
        abl,
        0,
        bl
    ]));
    return this.state;
};
function xorTest(a, b) {
    var out = 0;
    if (a.length !== b.length) out++;
    var len = Math.min(a.length, b.length);
    for(var i = 0; i < len; ++i){
        out += a[i] ^ b[i];
    }
    return out;
}
function calcIv(self, iv, ck) {
    if (iv.length === 12) {
        self._finID = Buffer.concat([
            iv,
            Buffer.from([
                0,
                0,
                0,
                1
            ])
        ]);
        return Buffer.concat([
            iv,
            Buffer.from([
                0,
                0,
                0,
                2
            ])
        ]);
    }
    var ghash = new GHASH(ck);
    var len = iv.length;
    var toPad = len % 16;
    ghash.update(iv);
    if (toPad) {
        toPad = 16 - toPad;
        ghash.update(Buffer.alloc(toPad, 0));
    }
    ghash.update(Buffer.alloc(8, 0));
    var ivBits = len * 8;
    var tail = Buffer.alloc(8);
    tail.writeUIntBE(ivBits, 2, 6);
    ghash.update(tail);
    self._finID = ghash.state;
    var out = Buffer.from(self._finID);
    incr32(out);
    return out;
}
function StreamCipher(mode, key, iv, decrypt) {
    CipherBase.call(this);
    var h = Buffer.alloc(4, 0);
    this._cipher = new AES(key);
    var ck = this._cipher.encryptBlock(h);
    this._ghash = new GHASH(ck);
    iv = calcIv(this, iv, ck);
    this._prev = Buffer.from(iv);
    this._cache = Buffer.allocUnsafe(0);
    this._secCache = Buffer.allocUnsafe(0);
    this._decrypt = decrypt;
    this._alen = 0;
    this._len = 0;
    this._mode = mode;
    this._authTag = null;
    this._called = false;
}
StreamCipher.prototype = Object.create(CipherBase.prototype, {
    constructor: {
        value: StreamCipher,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
StreamCipher.prototype._update = function(chunk) {
    if (!this._called && this._alen) {
        var rump = 16 - this._alen % 16;
        if (rump < 16) {
            rump = Buffer.alloc(rump, 0);
            this._ghash.update(rump);
        }
    }
    this._called = true;
    var out = this._mode.encrypt(this, chunk);
    if (this._decrypt) {
        this._ghash.update(chunk);
    } else {
        this._ghash.update(out);
    }
    this._len += chunk.length;
    return out;
};
StreamCipher.prototype._final = function() {
    if (this._decrypt && !this._authTag) {
        throw new Error("Unsupported state or unable to authenticate data");
    }
    var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && xorTest(tag, this._authTag)) {
        throw new Error("Unsupported state or unable to authenticate data");
    }
    this._authTag = tag;
    this._cipher.scrub();
};
StreamCipher.prototype.getAuthTag = function getAuthTag() {
    if (this._decrypt || !Buffer.isBuffer(this._authTag)) {
        throw new Error("Attempting to get auth tag in unsupported state");
    }
    return this._authTag;
};
StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
    if (!this._decrypt) {
        throw new Error("Attempting to set auth tag in unsupported state");
    }
    this._authTag = tag;
};
StreamCipher.prototype.setAAD = function setAAD(buf) {
    if (this._called) {
        throw new Error("Attempting to set AAD in unsupported state");
    }
    this._ghash.update(buf);
    this._alen += buf.length;
};
function StreamCipher1(mode, key, iv, decrypt) {
    CipherBase.call(this);
    this._cipher = new AES(key);
    this._prev = Buffer.from(iv);
    this._cache = Buffer.allocUnsafe(0);
    this._secCache = Buffer.allocUnsafe(0);
    this._decrypt = decrypt;
    this._mode = mode;
}
StreamCipher1.prototype = Object.create(CipherBase.prototype, {
    constructor: {
        value: StreamCipher1,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
StreamCipher1.prototype._update = function(chunk) {
    return this._mode.encrypt(this, chunk, this._decrypt);
};
StreamCipher1.prototype._final = function() {
    this._cipher.scrub();
};
function EVP_BytesToKey(password, salt, keyBits, ivLen) {
    if (!Buffer.isBuffer(password)) password = Buffer.from(password, "binary");
    if (salt) {
        if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, "binary");
        if (salt.length !== 8) {
            throw new RangeError("salt should be Buffer with 8 byte length");
        }
    }
    let keyLen = keyBits / 8;
    const key = Buffer.alloc(keyLen);
    const iv = Buffer.alloc(ivLen || 0);
    let tmp = Buffer.alloc(0);
    while(keyLen > 0 || ivLen > 0){
        const hash = createHash("md5");
        hash.update(tmp);
        hash.update(password);
        if (salt) hash.update(salt);
        tmp = hash.digest();
        let used = 0;
        if (keyLen > 0) {
            const keyStart = key.length - keyLen;
            used = Math.min(keyLen, tmp.length);
            tmp.copy(key, keyStart, 0, used);
            keyLen -= used;
        }
        if (used < tmp.length && ivLen > 0) {
            const ivStart = iv.length - ivLen;
            const length = Math.min(ivLen, tmp.length - used);
            tmp.copy(iv, ivStart, used, used + length);
            ivLen -= length;
        }
    }
    tmp.fill(0);
    return {
        key,
        iv
    };
}
function Cipher(mode, key, iv) {
    CipherBase.call(this);
    this._cache = new Splitter();
    this._cipher = new AES(key);
    this._prev = Buffer.from(iv);
    this._mode = mode;
    this._autopadding = true;
}
Cipher.prototype = Object.create(CipherBase.prototype, {
    constructor: {
        value: Cipher,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
Cipher.prototype._update = function(data) {
    this._cache.add(data);
    var chunk;
    var thing;
    var out = [];
    while(chunk = this._cache.get()){
        thing = this._mode.encrypt(this, chunk);
        out.push(thing);
    }
    return Buffer.concat(out);
};
var PADDING = Buffer.alloc(16, 0x10);
Cipher.prototype._final = function() {
    var chunk = this._cache.flush();
    if (this._autopadding) {
        chunk = this._mode.encrypt(this, chunk);
        this._cipher.scrub();
        return chunk;
    }
    if (!chunk.equals(PADDING)) {
        this._cipher.scrub();
        throw new Error("data not multiple of block length");
    }
};
Cipher.prototype.setAutoPadding = function(setTo) {
    this._autopadding = !!setTo;
    return this;
};
function Splitter() {
    this.cache = Buffer.allocUnsafe(0);
}
Splitter.prototype.add = function(data) {
    this.cache = Buffer.concat([
        this.cache,
        data
    ]);
};
Splitter.prototype.get = function() {
    if (this.cache.length > 15) {
        const out = this.cache.slice(0, 16);
        this.cache = this.cache.slice(16);
        return out;
    }
    return null;
};
Splitter.prototype.flush = function() {
    var len = 16 - this.cache.length;
    var padBuff = Buffer.allocUnsafe(len);
    var i = -1;
    while(++i < len){
        padBuff.writeUInt8(len, i);
    }
    return Buffer.concat([
        this.cache,
        padBuff
    ]);
};
function Decipher(mode, key, iv) {
    CipherBase.call(this);
    this._cache = new Splitter1();
    this._last = void 0;
    this._cipher = new AES(key);
    this._prev = Buffer.from(iv);
    this._mode = mode;
    this._autopadding = true;
}
Decipher.prototype = Object.create(CipherBase.prototype, {
    constructor: {
        value: Decipher,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
Decipher.prototype._update = function(data) {
    this._cache.add(data);
    var chunk;
    var thing;
    var out = [];
    while(chunk = this._cache.get(this._autopadding)){
        thing = this._mode.decrypt(this, chunk);
        out.push(thing);
    }
    return Buffer.concat(out);
};
Decipher.prototype._final = function() {
    var chunk = this._cache.flush();
    if (this._autopadding) {
        return unpad(this._mode.decrypt(this, chunk));
    } else if (chunk) {
        throw new Error("data not multiple of block length");
    }
};
Decipher.prototype.setAutoPadding = function(setTo) {
    this._autopadding = !!setTo;
    return this;
};
function Splitter1() {
    this.cache = Buffer.allocUnsafe(0);
}
Splitter1.prototype.add = function(data) {
    this.cache = Buffer.concat([
        this.cache,
        data
    ]);
};
Splitter1.prototype.get = function(autoPadding) {
    var out;
    if (autoPadding) {
        if (this.cache.length > 16) {
            out = this.cache.slice(0, 16);
            this.cache = this.cache.slice(16);
            return out;
        }
    } else {
        if (this.cache.length >= 16) {
            out = this.cache.slice(0, 16);
            this.cache = this.cache.slice(16);
            return out;
        }
    }
    return null;
};
Splitter1.prototype.flush = function() {
    if (this.cache.length) return this.cache;
};
function unpad(last) {
    var padded = last[15];
    if (padded < 1 || padded > 16) {
        throw new Error("unable to decrypt data");
    }
    var i = -1;
    while(++i < padded){
        if (last[i + (16 - padded)] !== padded) {
            throw new Error("unable to decrypt data");
        }
    }
    if (padded === 16) return;
    return last.slice(0, 16 - padded);
}
function createDecipheriv(suite, password, iv) {
    var config = MODES[suite.toLowerCase()];
    if (!config) throw new TypeError("invalid suite type");
    if (typeof iv === "string") iv = Buffer.from(iv);
    if (config.mode !== "GCM" && iv.length !== config.iv) {
        throw new TypeError("invalid iv length " + iv.length);
    }
    if (typeof password === "string") password = Buffer.from(password);
    if (password.length !== config.key / 8) {
        throw new TypeError("invalid key length " + password.length);
    }
    if (config.type === "stream") {
        return new StreamCipher1(config.module, password, iv, true);
    } else if (config.type === "auth") {
        return new StreamCipher(config.module, password, iv, true);
    }
    return new Decipher(config.module, password, iv);
}
function getCiphers() {
    return Object.keys(MODES);
}
const digestAlgorithms = [
    "blake2b256",
    "blake2b384",
    "blake2b",
    "blake2s",
    "blake3",
    "keccak-224",
    "keccak-256",
    "keccak-384",
    "keccak-512",
    "sha384",
    "sha3-224",
    "sha3-256",
    "sha3-384",
    "sha3-512",
    "shake128",
    "shake256",
    "tiger",
    "rmd160",
    "sha224",
    "sha256",
    "sha512",
    "md4",
    "md5",
    "sha1"
];
let defaultEncoding = "buffer";
function getDefaultEncoding() {
    return defaultEncoding;
}
function toBuf(val, encoding) {
    if (typeof val === "string") {
        if (encoding === "buffer") {
            encoding = "utf8";
        }
        return Buffer.from(val, encoding);
    }
    return val;
}
const validateByteSource = hideStackFrames((val, name)=>{
    val = toBuf(val);
    if (isAnyArrayBuffer1(val) || isArrayBufferView(val)) {
        return;
    }
    throw new ERR_INVALID_ARG_TYPE(name, [
        "string",
        "ArrayBuffer",
        "TypedArray",
        "DataView",
        "Buffer"
    ], val);
});
function getHashes() {
    return digestAlgorithms;
}
function getCurves() {
    notImplemented("crypto.getCurves");
}
function secureHeapUsed() {
    notImplemented("crypto.secureHeapUsed");
}
function setEngine(_engine, _flags) {
    notImplemented("crypto.setEngine");
}
const validateParameters = hideStackFrames((hash, key, salt, info, length)=>{
    key = prepareKey(key);
    salt = toBuf(salt);
    info = toBuf(info);
    validateString(hash, "digest");
    validateByteSource(salt, "salt");
    validateByteSource(info, "info");
    validateInteger(length, "length", 0, 2147483647);
    if (info.byteLength > 1024) {
        throw new ERR_OUT_OF_RANGE("info", "must not contain more than 1024 bytes", info.byteLength);
    }
    return {
        hash,
        key,
        salt,
        info,
        length
    };
});
function prepareKey(key) {
    if (isKeyObject1(key)) {
        return key;
    }
    if (isAnyArrayBuffer1(key)) {
        return createSecretKey(new Uint8Array(key));
    }
    key = toBuf(key);
    if (!isArrayBufferView(key)) {
        throw new ERR_INVALID_ARG_TYPE("ikm", [
            "string",
            "SecretKeyObject",
            "ArrayBuffer",
            "TypedArray",
            "DataView",
            "Buffer"
        ], key);
    }
    return createSecretKey(key);
}
function hkdf(hash, key, salt, info, length, callback) {
    ({ hash , key , salt , info , length  } = validateParameters(hash, key, salt, info, length));
    validateFunction(callback, "callback");
    notImplemented("crypto.hkdf");
}
function hkdfSync(hash, key, salt, info, length) {
    ({ hash , key , salt , info , length  } = validateParameters(hash, key, salt, info, length));
    notImplemented("crypto.hkdfSync");
}
function generateKey(_type, _options, _callback) {
    notImplemented("crypto.generateKey");
}
function generateKeyPair(_type, _options, _callback) {
    notImplemented("crypto.generateKeyPair");
}
function generateKeyPairSync(_type, _options) {
    notImplemented("crypto.generateKeyPairSync");
}
function generateKeySync(_type, _options) {
    notImplemented("crypto.generateKeySync");
}
const DH_GENERATOR = 2;
class DiffieHellman {
    verifyError;
    constructor(sizeOrKey, keyEncoding, generator, genEncoding){
        if (typeof sizeOrKey !== "number" && typeof sizeOrKey !== "string" && !isArrayBufferView(sizeOrKey) && !isAnyArrayBuffer1(sizeOrKey)) {
            throw new ERR_INVALID_ARG_TYPE("sizeOrKey", [
                "number",
                "string",
                "ArrayBuffer",
                "Buffer",
                "TypedArray",
                "DataView"
            ], sizeOrKey);
        }
        if (typeof sizeOrKey === "number") {
            validateInt32(sizeOrKey, "sizeOrKey");
        }
        if (keyEncoding && !Buffer.isEncoding(keyEncoding) && keyEncoding !== "buffer") {
            genEncoding = generator;
            generator = keyEncoding;
            keyEncoding = false;
        }
        const encoding = getDefaultEncoding();
        keyEncoding = keyEncoding || encoding;
        genEncoding = genEncoding || encoding;
        if (typeof sizeOrKey !== "number") {
            sizeOrKey = toBuf(sizeOrKey, keyEncoding);
        }
        if (!generator) {
            generator = DH_GENERATOR;
        } else if (typeof generator === "number") {
            validateInt32(generator, "generator");
        } else if (typeof generator === "string") {
            generator = toBuf(generator, genEncoding);
        } else if (!isArrayBufferView(generator) && !isAnyArrayBuffer1(generator)) {
            throw new ERR_INVALID_ARG_TYPE("generator", [
                "number",
                "string",
                "ArrayBuffer",
                "Buffer",
                "TypedArray",
                "DataView"
            ], generator);
        }
        notImplemented("crypto.DiffieHellman");
    }
    computeSecret(_otherPublicKey, _inputEncoding, _outputEncoding) {
        notImplemented("crypto.DiffieHellman.prototype.computeSecret");
    }
    generateKeys(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.generateKeys");
    }
    getGenerator(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getGenerator");
    }
    getPrime(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getPrime");
    }
    getPrivateKey(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getPrivateKey");
    }
    getPublicKey(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getPublicKey");
    }
    setPrivateKey(_privateKey, _encoding) {
        notImplemented("crypto.DiffieHellman.prototype.setPrivateKey");
    }
    setPublicKey(_publicKey, _encoding) {
        notImplemented("crypto.DiffieHellman.prototype.setPublicKey");
    }
}
class DiffieHellmanGroup {
    verifyError;
    constructor(_name){
        notImplemented("crypto.DiffieHellmanGroup");
    }
    computeSecret(_otherPublicKey, _inputEncoding, _outputEncoding) {
        notImplemented("crypto.DiffieHellman.prototype.computeSecret");
    }
    generateKeys(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.generateKeys");
    }
    getGenerator(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getGenerator");
    }
    getPrime(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getPrime");
    }
    getPrivateKey(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getPrivateKey");
    }
    getPublicKey(_encoding) {
        notImplemented("crypto.DiffieHellman.prototype.getPublicKey");
    }
}
class ECDH {
    constructor(curve){
        validateString(curve, "curve");
        notImplemented("crypto.ECDH");
    }
    static convertKey(_key, _curve, _inputEncoding, _outputEncoding, _format) {
        notImplemented("crypto.ECDH.prototype.convertKey");
    }
    computeSecret(_otherPublicKey, _inputEncoding, _outputEncoding) {
        notImplemented("crypto.ECDH.prototype.computeSecret");
    }
    generateKeys(_encoding, _format) {
        notImplemented("crypto.ECDH.prototype.generateKeys");
    }
    getPrivateKey(_encoding) {
        notImplemented("crypto.ECDH.prototype.getPrivateKey");
    }
    getPublicKey(_encoding, _format) {
        notImplemented("crypto.ECDH.prototype.getPublicKey");
    }
    setPrivateKey(_privateKey, _encoding) {
        notImplemented("crypto.ECDH.prototype.setPrivateKey");
    }
}
function diffieHellman(_options) {
    notImplemented("crypto.diffieHellman");
}
function assert2(val, msg) {
    if (!val) throw new Error(msg || "Assertion failed");
}
function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function() {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
}
function BN(number, base, endian) {
    if (BN.isBN(number)) {
        return number;
    }
    this.negative = 0;
    this.words = null;
    this.length = 0;
    this.red = null;
    if (number !== null) {
        if (base === "le" || base === "be") {
            endian = base;
            base = 10;
        }
        this._init(number || 0, base || 10, endian || "be");
    }
}
BN.BN = BN;
BN.wordSize = 26;
BN.isBN = function isBN(num) {
    if (num instanceof BN) {
        return true;
    }
    return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
};
BN.max = function max(left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
};
BN.min = function min(left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
};
BN.prototype._init = function init(number, base, endian) {
    if (typeof number === "number") {
        return this._initNumber(number, base, endian);
    }
    if (typeof number === "object") {
        return this._initArray(number, base, endian);
    }
    if (base === "hex") {
        base = 16;
    }
    assert2(base === (base | 0) && base >= 2 && base <= 36);
    number = number.toString().replace(/\s+/g, "");
    var start = 0;
    if (number[0] === "-") {
        start++;
        this.negative = 1;
    }
    if (start < number.length) {
        if (base === 16) {
            this._parseHex(number, start, endian);
        } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
                this._initArray(this.toArray(), base, endian);
            }
        }
    }
};
BN.prototype._initNumber = function _initNumber(number, base, endian) {
    if (number < 0) {
        this.negative = 1;
        number = -number;
    }
    if (number < 0x4000000) {
        this.words = [
            number & 0x3ffffff
        ];
        this.length = 1;
    } else if (number < 0x10000000000000) {
        this.words = [
            number & 0x3ffffff,
            number / 0x4000000 & 0x3ffffff
        ];
        this.length = 2;
    } else {
        assert2(number < 0x20000000000000);
        this.words = [
            number & 0x3ffffff,
            number / 0x4000000 & 0x3ffffff,
            1
        ];
        this.length = 3;
    }
    if (endian !== "le") return;
    this._initArray(this.toArray(), base, endian);
};
BN.prototype._initArray = function _initArray(number, base, endian) {
    assert2(typeof number.length === "number");
    if (number.length <= 0) {
        this.words = [
            0
        ];
        this.length = 1;
        return this;
    }
    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for(var i = 0; i < this.length; i++){
        this.words[i] = 0;
    }
    var j, w;
    var off = 0;
    if (endian === "be") {
        for(i = number.length - 1, j = 0; i >= 0; i -= 3){
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
    } else if (endian === "le") {
        for(i = 0, j = 0; i < number.length; i += 3){
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;
            if (off >= 26) {
                off -= 26;
                j++;
            }
        }
    }
    return this._strip();
};
function parseHex4Bits(string, index) {
    var c = string.charCodeAt(index);
    if (c >= 48 && c <= 57) {
        return c - 48;
    } else if (c >= 65 && c <= 70) {
        return c - 55;
    } else if (c >= 97 && c <= 102) {
        return c - 87;
    } else {
        assert2(false, "Invalid character in " + string);
    }
}
function parseHexByte(string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
        r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
}
BN.prototype._parseHex = function _parseHex(number, start, endian) {
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for(var i = 0; i < this.length; i++){
        this.words[i] = 0;
    }
    var off = 0;
    var j = 0;
    var w;
    if (endian === "be") {
        for(i = number.length - 1; i >= start; i -= 2){
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 0x3ffffff;
            if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
            } else {
                off += 8;
            }
        }
    } else {
        var parseLength = number.length - start;
        for(i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2){
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 0x3ffffff;
            if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
            } else {
                off += 8;
            }
        }
    }
    this._strip();
};
function parseBase(str, start, end, mul) {
    var r = 0;
    var b = 0;
    var len = Math.min(str.length, end);
    for(var i = start; i < len; i++){
        var c = str.charCodeAt(i) - 48;
        r *= mul;
        if (c >= 49) {
            b = c - 49 + 0xa;
        } else if (c >= 17) {
            b = c - 17 + 0xa;
        } else {
            b = c;
        }
        assert2(c >= 0 && b < mul, "Invalid character");
        r += b;
    }
    return r;
}
BN.prototype._parseBase = function _parseBase(number, base, start) {
    this.words = [
        0
    ];
    this.length = 1;
    for(var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base){
        limbLen++;
    }
    limbLen--;
    limbPow = limbPow / base | 0;
    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;
    var word = 0;
    for(var i = start; i < end; i += limbLen){
        word = parseBase(number, i, i + limbLen, base);
        this.imuln(limbPow);
        if (this.words[0] + word < 0x4000000) {
            this.words[0] += word;
        } else {
            this._iaddn(word);
        }
    }
    if (mod !== 0) {
        var pow = 1;
        word = parseBase(number, i, number.length, base);
        for(i = 0; i < mod; i++){
            pow *= base;
        }
        this.imuln(pow);
        if (this.words[0] + word < 0x4000000) {
            this.words[0] += word;
        } else {
            this._iaddn(word);
        }
    }
    this._strip();
};
BN.prototype.copy = function copy(dest) {
    dest.words = new Array(this.length);
    for(var i = 0; i < this.length; i++){
        dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
};
function move(dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
}
BN.prototype._move = function _move(dest) {
    move(dest, this);
};
BN.prototype.clone = function clone() {
    var r = new BN(null);
    this.copy(r);
    return r;
};
BN.prototype._expand = function _expand(size) {
    while(this.length < size){
        this.words[this.length++] = 0;
    }
    return this;
};
BN.prototype._strip = function strip() {
    while(this.length > 1 && this.words[this.length - 1] === 0){
        this.length--;
    }
    return this._normSign();
};
BN.prototype._normSign = function _normSign() {
    if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
    }
    return this;
};
if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
    try {
        BN.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect1;
    } catch (e) {
        BN.prototype.inspect = inspect1;
    }
} else {
    BN.prototype.inspect = inspect1;
}
function inspect1() {
    return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
}
var zeros = [
    "",
    "0",
    "00",
    "000",
    "0000",
    "00000",
    "000000",
    "0000000",
    "00000000",
    "000000000",
    "0000000000",
    "00000000000",
    "000000000000",
    "0000000000000",
    "00000000000000",
    "000000000000000",
    "0000000000000000",
    "00000000000000000",
    "000000000000000000",
    "0000000000000000000",
    "00000000000000000000",
    "000000000000000000000",
    "0000000000000000000000",
    "00000000000000000000000",
    "000000000000000000000000",
    "0000000000000000000000000"
];
var groupSizes = [
    0,
    0,
    25,
    16,
    12,
    11,
    10,
    9,
    8,
    8,
    7,
    7,
    7,
    7,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5
];
var groupBases = [
    0,
    0,
    33554432,
    43046721,
    16777216,
    48828125,
    60466176,
    40353607,
    16777216,
    43046721,
    10000000,
    19487171,
    35831808,
    62748517,
    7529536,
    11390625,
    16777216,
    24137569,
    34012224,
    47045881,
    64000000,
    4084101,
    5153632,
    6436343,
    7962624,
    9765625,
    11881376,
    14348907,
    17210368,
    20511149,
    24300000,
    28629151,
    33554432,
    39135393,
    45435424,
    52521875,
    60466176
];
BN.prototype.toString = function toString(base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;
    var out;
    if (base === 16 || base === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for(var i = 0; i < this.length; i++){
            var w = this.words[i];
            var word = ((w << off | carry) & 0xffffff).toString(16);
            carry = w >>> 24 - off & 0xffffff;
            if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
            } else {
                out = word + out;
            }
            off += 2;
            if (off >= 26) {
                off -= 26;
                i--;
            }
        }
        if (carry !== 0) {
            out = carry.toString(16) + out;
        }
        while(out.length % padding !== 0){
            out = "0" + out;
        }
        if (this.negative !== 0) {
            out = "-" + out;
        }
        return out;
    }
    if (base === (base | 0) && base >= 2 && base <= 36) {
        var groupSize = groupSizes[base];
        var groupBase = groupBases[base];
        out = "";
        var c = this.clone();
        c.negative = 0;
        while(!c.isZero()){
            var r = c.modrn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
            } else {
                out = r + out;
            }
        }
        if (this.isZero()) {
            out = "0" + out;
        }
        while(out.length % padding !== 0){
            out = "0" + out;
        }
        if (this.negative !== 0) {
            out = "-" + out;
        }
        return out;
    }
    assert2(false, "Base should be between 2 and 36");
};
BN.prototype.toNumber = function toNumber() {
    var ret = this.words[0];
    if (this.length === 2) {
        ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
        ret += 0x10000000000000 + this.words[1] * 0x4000000;
    } else if (this.length > 2) {
        assert2(false, "Number can only safely store up to 53 bits");
    }
    return this.negative !== 0 ? -ret : ret;
};
BN.prototype.toJSON = function toJSON() {
    return this.toString(16, 2);
};
if (Buffer) {
    BN.prototype.toBuffer = function toBuffer(endian, length) {
        return this.toArrayLike(Buffer, endian, length);
    };
}
BN.prototype.toArray = function toArray(endian, length) {
    return this.toArrayLike(Array, endian, length);
};
var allocate = function allocate(ArrayType, size) {
    if (ArrayType.allocUnsafe) {
        return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
};
BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
    this._strip();
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert2(byteLength <= reqLength, "byte array longer than desired length");
    assert2(reqLength > 0, "Requested array length <= 0");
    var res = allocate(ArrayType, reqLength);
    var postfix = endian === "le" ? "LE" : "BE";
    this["_toArrayLike" + postfix](res, byteLength);
    return res;
};
BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
    var position = 0;
    var carry = 0;
    for(var i = 0, shift = 0; i < this.length; i++){
        var word = this.words[i] << shift | carry;
        res[position++] = word & 0xff;
        if (position < res.length) {
            res[position++] = word >> 8 & 0xff;
        }
        if (position < res.length) {
            res[position++] = word >> 16 & 0xff;
        }
        if (shift === 6) {
            if (position < res.length) {
                res[position++] = word >> 24 & 0xff;
            }
            carry = 0;
            shift = 0;
        } else {
            carry = word >>> 24;
            shift += 2;
        }
    }
    if (position < res.length) {
        res[position++] = carry;
        while(position < res.length){
            res[position++] = 0;
        }
    }
};
BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
    var position = res.length - 1;
    var carry = 0;
    for(var i = 0, shift = 0; i < this.length; i++){
        var word = this.words[i] << shift | carry;
        res[position--] = word & 0xff;
        if (position >= 0) {
            res[position--] = word >> 8 & 0xff;
        }
        if (position >= 0) {
            res[position--] = word >> 16 & 0xff;
        }
        if (shift === 6) {
            if (position >= 0) {
                res[position--] = word >> 24 & 0xff;
            }
            carry = 0;
            shift = 0;
        } else {
            carry = word >>> 24;
            shift += 2;
        }
    }
    if (position >= 0) {
        res[position--] = carry;
        while(position >= 0){
            res[position--] = 0;
        }
    }
};
if (Math.clz32) {
    BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
    };
} else {
    BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 0x1000) {
            r += 13;
            t >>>= 13;
        }
        if (t >= 0x40) {
            r += 7;
            t >>>= 7;
        }
        if (t >= 0x8) {
            r += 4;
            t >>>= 4;
        }
        if (t >= 0x02) {
            r += 2;
            t >>>= 2;
        }
        return r + t;
    };
}
BN.prototype._zeroBits = function _zeroBits(w) {
    if (w === 0) return 26;
    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
        r += 13;
        t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
        r += 7;
        t >>>= 7;
    }
    if ((t & 0xf) === 0) {
        r += 4;
        t >>>= 4;
    }
    if ((t & 0x3) === 0) {
        r += 2;
        t >>>= 2;
    }
    if ((t & 0x1) === 0) {
        r++;
    }
    return r;
};
BN.prototype.bitLength = function bitLength() {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
};
function toBitArray(num) {
    var w = new Array(num.bitLength());
    for(var bit = 0; bit < w.length; bit++){
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = num.words[off] >>> wbit & 0x01;
    }
    return w;
}
BN.prototype.zeroBits = function zeroBits() {
    if (this.isZero()) return 0;
    var r = 0;
    for(var i = 0; i < this.length; i++){
        var b = this._zeroBits(this.words[i]);
        r += b;
        if (b !== 26) break;
    }
    return r;
};
BN.prototype.byteLength = function byteLength() {
    return Math.ceil(this.bitLength() / 8);
};
BN.prototype.toTwos = function toTwos(width) {
    if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
};
BN.prototype.fromTwos = function fromTwos(width) {
    if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
};
BN.prototype.isNeg = function isNeg() {
    return this.negative !== 0;
};
BN.prototype.neg = function neg() {
    return this.clone().ineg();
};
BN.prototype.ineg = function ineg() {
    if (!this.isZero()) {
        this.negative ^= 1;
    }
    return this;
};
BN.prototype.iuor = function iuor(num) {
    while(this.length < num.length){
        this.words[this.length++] = 0;
    }
    for(var i = 0; i < num.length; i++){
        this.words[i] = this.words[i] | num.words[i];
    }
    return this._strip();
};
BN.prototype.ior = function ior(num) {
    assert2((this.negative | num.negative) === 0);
    return this.iuor(num);
};
BN.prototype.or = function or(num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
};
BN.prototype.uor = function uor(num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
};
BN.prototype.iuand = function iuand(num) {
    var b;
    if (this.length > num.length) {
        b = num;
    } else {
        b = this;
    }
    for(var i = 0; i < b.length; i++){
        this.words[i] = this.words[i] & num.words[i];
    }
    this.length = b.length;
    return this._strip();
};
BN.prototype.iand = function iand(num) {
    assert2((this.negative | num.negative) === 0);
    return this.iuand(num);
};
BN.prototype.and = function and(num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
};
BN.prototype.uand = function uand(num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
};
BN.prototype.iuxor = function iuxor(num) {
    var a;
    var b;
    if (this.length > num.length) {
        a = this;
        b = num;
    } else {
        a = num;
        b = this;
    }
    for(var i = 0; i < b.length; i++){
        this.words[i] = a.words[i] ^ b.words[i];
    }
    if (this !== a) {
        for(; i < a.length; i++){
            this.words[i] = a.words[i];
        }
    }
    this.length = a.length;
    return this._strip();
};
BN.prototype.ixor = function ixor(num) {
    assert2((this.negative | num.negative) === 0);
    return this.iuxor(num);
};
BN.prototype.xor = function xor(num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
};
BN.prototype.uxor = function uxor(num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
};
BN.prototype.inotn = function inotn(width) {
    assert2(typeof width === "number" && width >= 0);
    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;
    this._expand(bytesNeeded);
    if (bitsLeft > 0) {
        bytesNeeded--;
    }
    for(var i = 0; i < bytesNeeded; i++){
        this.words[i] = ~this.words[i] & 0x3ffffff;
    }
    if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
    }
    return this._strip();
};
BN.prototype.notn = function notn(width) {
    return this.clone().inotn(width);
};
BN.prototype.setn = function setn(bit, val) {
    assert2(typeof bit === "number" && bit >= 0);
    var off = bit / 26 | 0;
    var wbit = bit % 26;
    this._expand(off + 1);
    if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
    } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
    }
    return this._strip();
};
BN.prototype.iadd = function iadd(num) {
    var r;
    if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
    } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r = this.isub(num);
        num.negative = 1;
        return r._normSign();
    }
    var a, b;
    if (this.length > num.length) {
        a = this;
        b = num;
    } else {
        a = num;
        b = this;
    }
    var carry = 0;
    for(var i = 0; i < b.length; i++){
        r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
        this.words[i] = r & 0x3ffffff;
        carry = r >>> 26;
    }
    for(; carry !== 0 && i < a.length; i++){
        r = (a.words[i] | 0) + carry;
        this.words[i] = r & 0x3ffffff;
        carry = r >>> 26;
    }
    this.length = a.length;
    if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
    } else if (a !== this) {
        for(; i < a.length; i++){
            this.words[i] = a.words[i];
        }
    }
    return this;
};
BN.prototype.add = function add(num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
    } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
    }
    if (this.length > num.length) return this.clone().iadd(num);
    return num.clone().iadd(this);
};
BN.prototype.isub = function isub(num) {
    if (num.negative !== 0) {
        num.negative = 0;
        var r = this.iadd(num);
        num.negative = 1;
        return r._normSign();
    } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
    }
    var cmp = this.cmp(num);
    if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
    }
    var a, b;
    if (cmp > 0) {
        a = this;
        b = num;
    } else {
        a = num;
        b = this;
    }
    var carry = 0;
    for(var i = 0; i < b.length; i++){
        r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 0x3ffffff;
    }
    for(; carry !== 0 && i < a.length; i++){
        r = (a.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 0x3ffffff;
    }
    if (carry === 0 && i < a.length && a !== this) {
        for(; i < a.length; i++){
            this.words[i] = a.words[i];
        }
    }
    this.length = Math.max(this.length, i);
    if (a !== this) {
        this.negative = 1;
    }
    return this._strip();
};
BN.prototype.sub = function sub(num) {
    return this.clone().isub(num);
};
function smallMulTo(self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = self.length + num.length | 0;
    out.length = len;
    len = len - 1 | 0;
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;
    var lo = r & 0x3ffffff;
    var carry = r / 0x4000000 | 0;
    out.words[0] = lo;
    for(var k = 1; k < len; k++){
        var ncarry = carry >>> 26;
        var rword = carry & 0x3ffffff;
        var maxJ = Math.min(k, num.length - 1);
        for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
            var i = k - j | 0;
            a = self.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 0x4000000 | 0;
            rword = r & 0x3ffffff;
        }
        out.words[k] = rword | 0;
        carry = ncarry | 0;
    }
    if (carry !== 0) {
        out.words[k] = carry | 0;
    } else {
        out.length--;
    }
    return out._strip();
}
var comb10MulTo = function comb10MulTo(self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;
    out.negative = self.negative ^ num.negative;
    out.length = 19;
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = mid + Math.imul(ah0, bl0) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
    w0 &= 0x3ffffff;
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = mid + Math.imul(ah1, bl0) | 0;
    hi = Math.imul(ah1, bh0);
    lo = lo + Math.imul(al0, bl1) | 0;
    mid = mid + Math.imul(al0, bh1) | 0;
    mid = mid + Math.imul(ah0, bl1) | 0;
    hi = hi + Math.imul(ah0, bh1) | 0;
    var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
    w1 &= 0x3ffffff;
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = mid + Math.imul(ah2, bl0) | 0;
    hi = Math.imul(ah2, bh0);
    lo = lo + Math.imul(al1, bl1) | 0;
    mid = mid + Math.imul(al1, bh1) | 0;
    mid = mid + Math.imul(ah1, bl1) | 0;
    hi = hi + Math.imul(ah1, bh1) | 0;
    lo = lo + Math.imul(al0, bl2) | 0;
    mid = mid + Math.imul(al0, bh2) | 0;
    mid = mid + Math.imul(ah0, bl2) | 0;
    hi = hi + Math.imul(ah0, bh2) | 0;
    var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
    w2 &= 0x3ffffff;
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = mid + Math.imul(ah3, bl0) | 0;
    hi = Math.imul(ah3, bh0);
    lo = lo + Math.imul(al2, bl1) | 0;
    mid = mid + Math.imul(al2, bh1) | 0;
    mid = mid + Math.imul(ah2, bl1) | 0;
    hi = hi + Math.imul(ah2, bh1) | 0;
    lo = lo + Math.imul(al1, bl2) | 0;
    mid = mid + Math.imul(al1, bh2) | 0;
    mid = mid + Math.imul(ah1, bl2) | 0;
    hi = hi + Math.imul(ah1, bh2) | 0;
    lo = lo + Math.imul(al0, bl3) | 0;
    mid = mid + Math.imul(al0, bh3) | 0;
    mid = mid + Math.imul(ah0, bl3) | 0;
    hi = hi + Math.imul(ah0, bh3) | 0;
    var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
    w3 &= 0x3ffffff;
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = mid + Math.imul(ah4, bl0) | 0;
    hi = Math.imul(ah4, bh0);
    lo = lo + Math.imul(al3, bl1) | 0;
    mid = mid + Math.imul(al3, bh1) | 0;
    mid = mid + Math.imul(ah3, bl1) | 0;
    hi = hi + Math.imul(ah3, bh1) | 0;
    lo = lo + Math.imul(al2, bl2) | 0;
    mid = mid + Math.imul(al2, bh2) | 0;
    mid = mid + Math.imul(ah2, bl2) | 0;
    hi = hi + Math.imul(ah2, bh2) | 0;
    lo = lo + Math.imul(al1, bl3) | 0;
    mid = mid + Math.imul(al1, bh3) | 0;
    mid = mid + Math.imul(ah1, bl3) | 0;
    hi = hi + Math.imul(ah1, bh3) | 0;
    lo = lo + Math.imul(al0, bl4) | 0;
    mid = mid + Math.imul(al0, bh4) | 0;
    mid = mid + Math.imul(ah0, bl4) | 0;
    hi = hi + Math.imul(ah0, bh4) | 0;
    var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
    w4 &= 0x3ffffff;
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = mid + Math.imul(ah5, bl0) | 0;
    hi = Math.imul(ah5, bh0);
    lo = lo + Math.imul(al4, bl1) | 0;
    mid = mid + Math.imul(al4, bh1) | 0;
    mid = mid + Math.imul(ah4, bl1) | 0;
    hi = hi + Math.imul(ah4, bh1) | 0;
    lo = lo + Math.imul(al3, bl2) | 0;
    mid = mid + Math.imul(al3, bh2) | 0;
    mid = mid + Math.imul(ah3, bl2) | 0;
    hi = hi + Math.imul(ah3, bh2) | 0;
    lo = lo + Math.imul(al2, bl3) | 0;
    mid = mid + Math.imul(al2, bh3) | 0;
    mid = mid + Math.imul(ah2, bl3) | 0;
    hi = hi + Math.imul(ah2, bh3) | 0;
    lo = lo + Math.imul(al1, bl4) | 0;
    mid = mid + Math.imul(al1, bh4) | 0;
    mid = mid + Math.imul(ah1, bl4) | 0;
    hi = hi + Math.imul(ah1, bh4) | 0;
    lo = lo + Math.imul(al0, bl5) | 0;
    mid = mid + Math.imul(al0, bh5) | 0;
    mid = mid + Math.imul(ah0, bl5) | 0;
    hi = hi + Math.imul(ah0, bh5) | 0;
    var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
    w5 &= 0x3ffffff;
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = mid + Math.imul(ah6, bl0) | 0;
    hi = Math.imul(ah6, bh0);
    lo = lo + Math.imul(al5, bl1) | 0;
    mid = mid + Math.imul(al5, bh1) | 0;
    mid = mid + Math.imul(ah5, bl1) | 0;
    hi = hi + Math.imul(ah5, bh1) | 0;
    lo = lo + Math.imul(al4, bl2) | 0;
    mid = mid + Math.imul(al4, bh2) | 0;
    mid = mid + Math.imul(ah4, bl2) | 0;
    hi = hi + Math.imul(ah4, bh2) | 0;
    lo = lo + Math.imul(al3, bl3) | 0;
    mid = mid + Math.imul(al3, bh3) | 0;
    mid = mid + Math.imul(ah3, bl3) | 0;
    hi = hi + Math.imul(ah3, bh3) | 0;
    lo = lo + Math.imul(al2, bl4) | 0;
    mid = mid + Math.imul(al2, bh4) | 0;
    mid = mid + Math.imul(ah2, bl4) | 0;
    hi = hi + Math.imul(ah2, bh4) | 0;
    lo = lo + Math.imul(al1, bl5) | 0;
    mid = mid + Math.imul(al1, bh5) | 0;
    mid = mid + Math.imul(ah1, bl5) | 0;
    hi = hi + Math.imul(ah1, bh5) | 0;
    lo = lo + Math.imul(al0, bl6) | 0;
    mid = mid + Math.imul(al0, bh6) | 0;
    mid = mid + Math.imul(ah0, bl6) | 0;
    hi = hi + Math.imul(ah0, bh6) | 0;
    var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
    w6 &= 0x3ffffff;
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = mid + Math.imul(ah7, bl0) | 0;
    hi = Math.imul(ah7, bh0);
    lo = lo + Math.imul(al6, bl1) | 0;
    mid = mid + Math.imul(al6, bh1) | 0;
    mid = mid + Math.imul(ah6, bl1) | 0;
    hi = hi + Math.imul(ah6, bh1) | 0;
    lo = lo + Math.imul(al5, bl2) | 0;
    mid = mid + Math.imul(al5, bh2) | 0;
    mid = mid + Math.imul(ah5, bl2) | 0;
    hi = hi + Math.imul(ah5, bh2) | 0;
    lo = lo + Math.imul(al4, bl3) | 0;
    mid = mid + Math.imul(al4, bh3) | 0;
    mid = mid + Math.imul(ah4, bl3) | 0;
    hi = hi + Math.imul(ah4, bh3) | 0;
    lo = lo + Math.imul(al3, bl4) | 0;
    mid = mid + Math.imul(al3, bh4) | 0;
    mid = mid + Math.imul(ah3, bl4) | 0;
    hi = hi + Math.imul(ah3, bh4) | 0;
    lo = lo + Math.imul(al2, bl5) | 0;
    mid = mid + Math.imul(al2, bh5) | 0;
    mid = mid + Math.imul(ah2, bl5) | 0;
    hi = hi + Math.imul(ah2, bh5) | 0;
    lo = lo + Math.imul(al1, bl6) | 0;
    mid = mid + Math.imul(al1, bh6) | 0;
    mid = mid + Math.imul(ah1, bl6) | 0;
    hi = hi + Math.imul(ah1, bh6) | 0;
    lo = lo + Math.imul(al0, bl7) | 0;
    mid = mid + Math.imul(al0, bh7) | 0;
    mid = mid + Math.imul(ah0, bl7) | 0;
    hi = hi + Math.imul(ah0, bh7) | 0;
    var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
    w7 &= 0x3ffffff;
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = mid + Math.imul(ah8, bl0) | 0;
    hi = Math.imul(ah8, bh0);
    lo = lo + Math.imul(al7, bl1) | 0;
    mid = mid + Math.imul(al7, bh1) | 0;
    mid = mid + Math.imul(ah7, bl1) | 0;
    hi = hi + Math.imul(ah7, bh1) | 0;
    lo = lo + Math.imul(al6, bl2) | 0;
    mid = mid + Math.imul(al6, bh2) | 0;
    mid = mid + Math.imul(ah6, bl2) | 0;
    hi = hi + Math.imul(ah6, bh2) | 0;
    lo = lo + Math.imul(al5, bl3) | 0;
    mid = mid + Math.imul(al5, bh3) | 0;
    mid = mid + Math.imul(ah5, bl3) | 0;
    hi = hi + Math.imul(ah5, bh3) | 0;
    lo = lo + Math.imul(al4, bl4) | 0;
    mid = mid + Math.imul(al4, bh4) | 0;
    mid = mid + Math.imul(ah4, bl4) | 0;
    hi = hi + Math.imul(ah4, bh4) | 0;
    lo = lo + Math.imul(al3, bl5) | 0;
    mid = mid + Math.imul(al3, bh5) | 0;
    mid = mid + Math.imul(ah3, bl5) | 0;
    hi = hi + Math.imul(ah3, bh5) | 0;
    lo = lo + Math.imul(al2, bl6) | 0;
    mid = mid + Math.imul(al2, bh6) | 0;
    mid = mid + Math.imul(ah2, bl6) | 0;
    hi = hi + Math.imul(ah2, bh6) | 0;
    lo = lo + Math.imul(al1, bl7) | 0;
    mid = mid + Math.imul(al1, bh7) | 0;
    mid = mid + Math.imul(ah1, bl7) | 0;
    hi = hi + Math.imul(ah1, bh7) | 0;
    lo = lo + Math.imul(al0, bl8) | 0;
    mid = mid + Math.imul(al0, bh8) | 0;
    mid = mid + Math.imul(ah0, bl8) | 0;
    hi = hi + Math.imul(ah0, bh8) | 0;
    var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
    w8 &= 0x3ffffff;
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = mid + Math.imul(ah9, bl0) | 0;
    hi = Math.imul(ah9, bh0);
    lo = lo + Math.imul(al8, bl1) | 0;
    mid = mid + Math.imul(al8, bh1) | 0;
    mid = mid + Math.imul(ah8, bl1) | 0;
    hi = hi + Math.imul(ah8, bh1) | 0;
    lo = lo + Math.imul(al7, bl2) | 0;
    mid = mid + Math.imul(al7, bh2) | 0;
    mid = mid + Math.imul(ah7, bl2) | 0;
    hi = hi + Math.imul(ah7, bh2) | 0;
    lo = lo + Math.imul(al6, bl3) | 0;
    mid = mid + Math.imul(al6, bh3) | 0;
    mid = mid + Math.imul(ah6, bl3) | 0;
    hi = hi + Math.imul(ah6, bh3) | 0;
    lo = lo + Math.imul(al5, bl4) | 0;
    mid = mid + Math.imul(al5, bh4) | 0;
    mid = mid + Math.imul(ah5, bl4) | 0;
    hi = hi + Math.imul(ah5, bh4) | 0;
    lo = lo + Math.imul(al4, bl5) | 0;
    mid = mid + Math.imul(al4, bh5) | 0;
    mid = mid + Math.imul(ah4, bl5) | 0;
    hi = hi + Math.imul(ah4, bh5) | 0;
    lo = lo + Math.imul(al3, bl6) | 0;
    mid = mid + Math.imul(al3, bh6) | 0;
    mid = mid + Math.imul(ah3, bl6) | 0;
    hi = hi + Math.imul(ah3, bh6) | 0;
    lo = lo + Math.imul(al2, bl7) | 0;
    mid = mid + Math.imul(al2, bh7) | 0;
    mid = mid + Math.imul(ah2, bl7) | 0;
    hi = hi + Math.imul(ah2, bh7) | 0;
    lo = lo + Math.imul(al1, bl8) | 0;
    mid = mid + Math.imul(al1, bh8) | 0;
    mid = mid + Math.imul(ah1, bl8) | 0;
    hi = hi + Math.imul(ah1, bh8) | 0;
    lo = lo + Math.imul(al0, bl9) | 0;
    mid = mid + Math.imul(al0, bh9) | 0;
    mid = mid + Math.imul(ah0, bl9) | 0;
    hi = hi + Math.imul(ah0, bh9) | 0;
    var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
    w9 &= 0x3ffffff;
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = mid + Math.imul(ah9, bl1) | 0;
    hi = Math.imul(ah9, bh1);
    lo = lo + Math.imul(al8, bl2) | 0;
    mid = mid + Math.imul(al8, bh2) | 0;
    mid = mid + Math.imul(ah8, bl2) | 0;
    hi = hi + Math.imul(ah8, bh2) | 0;
    lo = lo + Math.imul(al7, bl3) | 0;
    mid = mid + Math.imul(al7, bh3) | 0;
    mid = mid + Math.imul(ah7, bl3) | 0;
    hi = hi + Math.imul(ah7, bh3) | 0;
    lo = lo + Math.imul(al6, bl4) | 0;
    mid = mid + Math.imul(al6, bh4) | 0;
    mid = mid + Math.imul(ah6, bl4) | 0;
    hi = hi + Math.imul(ah6, bh4) | 0;
    lo = lo + Math.imul(al5, bl5) | 0;
    mid = mid + Math.imul(al5, bh5) | 0;
    mid = mid + Math.imul(ah5, bl5) | 0;
    hi = hi + Math.imul(ah5, bh5) | 0;
    lo = lo + Math.imul(al4, bl6) | 0;
    mid = mid + Math.imul(al4, bh6) | 0;
    mid = mid + Math.imul(ah4, bl6) | 0;
    hi = hi + Math.imul(ah4, bh6) | 0;
    lo = lo + Math.imul(al3, bl7) | 0;
    mid = mid + Math.imul(al3, bh7) | 0;
    mid = mid + Math.imul(ah3, bl7) | 0;
    hi = hi + Math.imul(ah3, bh7) | 0;
    lo = lo + Math.imul(al2, bl8) | 0;
    mid = mid + Math.imul(al2, bh8) | 0;
    mid = mid + Math.imul(ah2, bl8) | 0;
    hi = hi + Math.imul(ah2, bh8) | 0;
    lo = lo + Math.imul(al1, bl9) | 0;
    mid = mid + Math.imul(al1, bh9) | 0;
    mid = mid + Math.imul(ah1, bl9) | 0;
    hi = hi + Math.imul(ah1, bh9) | 0;
    var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
    w10 &= 0x3ffffff;
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = mid + Math.imul(ah9, bl2) | 0;
    hi = Math.imul(ah9, bh2);
    lo = lo + Math.imul(al8, bl3) | 0;
    mid = mid + Math.imul(al8, bh3) | 0;
    mid = mid + Math.imul(ah8, bl3) | 0;
    hi = hi + Math.imul(ah8, bh3) | 0;
    lo = lo + Math.imul(al7, bl4) | 0;
    mid = mid + Math.imul(al7, bh4) | 0;
    mid = mid + Math.imul(ah7, bl4) | 0;
    hi = hi + Math.imul(ah7, bh4) | 0;
    lo = lo + Math.imul(al6, bl5) | 0;
    mid = mid + Math.imul(al6, bh5) | 0;
    mid = mid + Math.imul(ah6, bl5) | 0;
    hi = hi + Math.imul(ah6, bh5) | 0;
    lo = lo + Math.imul(al5, bl6) | 0;
    mid = mid + Math.imul(al5, bh6) | 0;
    mid = mid + Math.imul(ah5, bl6) | 0;
    hi = hi + Math.imul(ah5, bh6) | 0;
    lo = lo + Math.imul(al4, bl7) | 0;
    mid = mid + Math.imul(al4, bh7) | 0;
    mid = mid + Math.imul(ah4, bl7) | 0;
    hi = hi + Math.imul(ah4, bh7) | 0;
    lo = lo + Math.imul(al3, bl8) | 0;
    mid = mid + Math.imul(al3, bh8) | 0;
    mid = mid + Math.imul(ah3, bl8) | 0;
    hi = hi + Math.imul(ah3, bh8) | 0;
    lo = lo + Math.imul(al2, bl9) | 0;
    mid = mid + Math.imul(al2, bh9) | 0;
    mid = mid + Math.imul(ah2, bl9) | 0;
    hi = hi + Math.imul(ah2, bh9) | 0;
    var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
    w11 &= 0x3ffffff;
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = mid + Math.imul(ah9, bl3) | 0;
    hi = Math.imul(ah9, bh3);
    lo = lo + Math.imul(al8, bl4) | 0;
    mid = mid + Math.imul(al8, bh4) | 0;
    mid = mid + Math.imul(ah8, bl4) | 0;
    hi = hi + Math.imul(ah8, bh4) | 0;
    lo = lo + Math.imul(al7, bl5) | 0;
    mid = mid + Math.imul(al7, bh5) | 0;
    mid = mid + Math.imul(ah7, bl5) | 0;
    hi = hi + Math.imul(ah7, bh5) | 0;
    lo = lo + Math.imul(al6, bl6) | 0;
    mid = mid + Math.imul(al6, bh6) | 0;
    mid = mid + Math.imul(ah6, bl6) | 0;
    hi = hi + Math.imul(ah6, bh6) | 0;
    lo = lo + Math.imul(al5, bl7) | 0;
    mid = mid + Math.imul(al5, bh7) | 0;
    mid = mid + Math.imul(ah5, bl7) | 0;
    hi = hi + Math.imul(ah5, bh7) | 0;
    lo = lo + Math.imul(al4, bl8) | 0;
    mid = mid + Math.imul(al4, bh8) | 0;
    mid = mid + Math.imul(ah4, bl8) | 0;
    hi = hi + Math.imul(ah4, bh8) | 0;
    lo = lo + Math.imul(al3, bl9) | 0;
    mid = mid + Math.imul(al3, bh9) | 0;
    mid = mid + Math.imul(ah3, bl9) | 0;
    hi = hi + Math.imul(ah3, bh9) | 0;
    var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
    w12 &= 0x3ffffff;
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = mid + Math.imul(ah9, bl4) | 0;
    hi = Math.imul(ah9, bh4);
    lo = lo + Math.imul(al8, bl5) | 0;
    mid = mid + Math.imul(al8, bh5) | 0;
    mid = mid + Math.imul(ah8, bl5) | 0;
    hi = hi + Math.imul(ah8, bh5) | 0;
    lo = lo + Math.imul(al7, bl6) | 0;
    mid = mid + Math.imul(al7, bh6) | 0;
    mid = mid + Math.imul(ah7, bl6) | 0;
    hi = hi + Math.imul(ah7, bh6) | 0;
    lo = lo + Math.imul(al6, bl7) | 0;
    mid = mid + Math.imul(al6, bh7) | 0;
    mid = mid + Math.imul(ah6, bl7) | 0;
    hi = hi + Math.imul(ah6, bh7) | 0;
    lo = lo + Math.imul(al5, bl8) | 0;
    mid = mid + Math.imul(al5, bh8) | 0;
    mid = mid + Math.imul(ah5, bl8) | 0;
    hi = hi + Math.imul(ah5, bh8) | 0;
    lo = lo + Math.imul(al4, bl9) | 0;
    mid = mid + Math.imul(al4, bh9) | 0;
    mid = mid + Math.imul(ah4, bl9) | 0;
    hi = hi + Math.imul(ah4, bh9) | 0;
    var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
    w13 &= 0x3ffffff;
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = mid + Math.imul(ah9, bl5) | 0;
    hi = Math.imul(ah9, bh5);
    lo = lo + Math.imul(al8, bl6) | 0;
    mid = mid + Math.imul(al8, bh6) | 0;
    mid = mid + Math.imul(ah8, bl6) | 0;
    hi = hi + Math.imul(ah8, bh6) | 0;
    lo = lo + Math.imul(al7, bl7) | 0;
    mid = mid + Math.imul(al7, bh7) | 0;
    mid = mid + Math.imul(ah7, bl7) | 0;
    hi = hi + Math.imul(ah7, bh7) | 0;
    lo = lo + Math.imul(al6, bl8) | 0;
    mid = mid + Math.imul(al6, bh8) | 0;
    mid = mid + Math.imul(ah6, bl8) | 0;
    hi = hi + Math.imul(ah6, bh8) | 0;
    lo = lo + Math.imul(al5, bl9) | 0;
    mid = mid + Math.imul(al5, bh9) | 0;
    mid = mid + Math.imul(ah5, bl9) | 0;
    hi = hi + Math.imul(ah5, bh9) | 0;
    var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
    w14 &= 0x3ffffff;
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = mid + Math.imul(ah9, bl6) | 0;
    hi = Math.imul(ah9, bh6);
    lo = lo + Math.imul(al8, bl7) | 0;
    mid = mid + Math.imul(al8, bh7) | 0;
    mid = mid + Math.imul(ah8, bl7) | 0;
    hi = hi + Math.imul(ah8, bh7) | 0;
    lo = lo + Math.imul(al7, bl8) | 0;
    mid = mid + Math.imul(al7, bh8) | 0;
    mid = mid + Math.imul(ah7, bl8) | 0;
    hi = hi + Math.imul(ah7, bh8) | 0;
    lo = lo + Math.imul(al6, bl9) | 0;
    mid = mid + Math.imul(al6, bh9) | 0;
    mid = mid + Math.imul(ah6, bl9) | 0;
    hi = hi + Math.imul(ah6, bh9) | 0;
    var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
    w15 &= 0x3ffffff;
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = mid + Math.imul(ah9, bl7) | 0;
    hi = Math.imul(ah9, bh7);
    lo = lo + Math.imul(al8, bl8) | 0;
    mid = mid + Math.imul(al8, bh8) | 0;
    mid = mid + Math.imul(ah8, bl8) | 0;
    hi = hi + Math.imul(ah8, bh8) | 0;
    lo = lo + Math.imul(al7, bl9) | 0;
    mid = mid + Math.imul(al7, bh9) | 0;
    mid = mid + Math.imul(ah7, bl9) | 0;
    hi = hi + Math.imul(ah7, bh9) | 0;
    var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
    w16 &= 0x3ffffff;
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = mid + Math.imul(ah9, bl8) | 0;
    hi = Math.imul(ah9, bh8);
    lo = lo + Math.imul(al8, bl9) | 0;
    mid = mid + Math.imul(al8, bh9) | 0;
    mid = mid + Math.imul(ah8, bl9) | 0;
    hi = hi + Math.imul(ah8, bh9) | 0;
    var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
    w17 &= 0x3ffffff;
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = mid + Math.imul(ah9, bl9) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
        o[19] = c;
        out.length++;
    }
    return out;
};
if (!Math.imul) {
    comb10MulTo = smallMulTo;
}
function bigMulTo(self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;
    var carry = 0;
    var hncarry = 0;
    for(var k = 0; k < out.length - 1; k++){
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 0x3ffffff;
        var maxJ = Math.min(k, num.length - 1);
        for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
            var i = k - j;
            var a = self.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 0x3ffffff;
            ncarry = ncarry + (r / 0x4000000 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 0x3ffffff;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 0x3ffffff;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
    }
    if (carry !== 0) {
        out.words[k] = carry;
    } else {
        out.length--;
    }
    return out._strip();
}
function jumboMulTo(self, num, out) {
    return bigMulTo(self, num, out);
}
BN.prototype.mulTo = function mulTo(num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
    } else if (len < 63) {
        res = smallMulTo(this, num, out);
    } else if (len < 1024) {
        res = bigMulTo(this, num, out);
    } else {
        res = jumboMulTo(this, num, out);
    }
    return res;
};
function FFTM(x, y) {
    this.x = x;
    this.y = y;
}
FFTM.prototype.makeRBT = function makeRBT(N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for(var i = 0; i < N; i++){
        t[i] = this.revBin(i, l, N);
    }
    return t;
};
FFTM.prototype.revBin = function revBin(x, l, N) {
    if (x === 0 || x === N - 1) return x;
    var rb = 0;
    for(var i = 0; i < l; i++){
        rb |= (x & 1) << l - i - 1;
        x >>= 1;
    }
    return rb;
};
FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
    for(var i = 0; i < N; i++){
        rtws[i] = rws[rbt[i]];
        itws[i] = iws[rbt[i]];
    }
};
FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);
    for(var s = 1; s < N; s <<= 1){
        var l = s << 1;
        var rtwdf = Math.cos(2 * Math.PI / l);
        var itwdf = Math.sin(2 * Math.PI / l);
        for(var p = 0; p < N; p += l){
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for(var j = 0; j < s; j++){
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                    rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                    itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                    rtwdf_ = rx;
                }
            }
        }
    }
};
FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for(N = N / 2 | 0; N; N = N >>> 1){
        i++;
    }
    return 1 << i + 1 + odd;
};
FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
    if (N <= 1) return;
    for(var i = 0; i < N / 2; i++){
        var t = rws[i];
        rws[i] = rws[N - i - 1];
        rws[N - i - 1] = t;
        t = iws[i];
        iws[i] = -iws[N - i - 1];
        iws[N - i - 1] = -t;
    }
};
FFTM.prototype.normalize13b = function normalize13b(ws, N) {
    var carry = 0;
    for(var i = 0; i < N / 2; i++){
        var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
        ws[i] = w & 0x3ffffff;
        if (w < 0x4000000) {
            carry = 0;
        } else {
            carry = w / 0x4000000 | 0;
        }
    }
    return ws;
};
FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
    var carry = 0;
    for(var i = 0; i < len; i++){
        carry = carry + (ws[i] | 0);
        rws[2 * i] = carry & 0x1fff;
        carry = carry >>> 13;
        rws[2 * i + 1] = carry & 0x1fff;
        carry = carry >>> 13;
    }
    for(i = 2 * len; i < N; ++i){
        rws[i] = 0;
    }
    assert2(carry === 0);
    assert2((carry & ~0x1fff) === 0);
};
FFTM.prototype.stub = function stub(N) {
    var ph = new Array(N);
    for(var i = 0; i < N; i++){
        ph[i] = 0;
    }
    return ph;
};
FFTM.prototype.mulp = function mulp(x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);
    var rbt = this.makeRBT(N);
    var _ = this.stub(N);
    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);
    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);
    var rmws = out.words;
    rmws.length = N;
    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);
    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);
    for(var i = 0; i < N; i++){
        var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
        iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
        rwst[i] = rx;
    }
    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);
    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out._strip();
};
BN.prototype.mul = function mul(num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
};
BN.prototype.mulf = function mulf(num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
};
BN.prototype.imul = function imul(num) {
    return this.clone().mulTo(num, this);
};
BN.prototype.imuln = function imuln(num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;
    assert2(typeof num === "number");
    assert2(num < 0x4000000);
    var carry = 0;
    for(var i = 0; i < this.length; i++){
        var w = (this.words[i] | 0) * num;
        var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
        carry >>= 26;
        carry += w / 0x4000000 | 0;
        carry += lo >>> 26;
        this.words[i] = lo & 0x3ffffff;
    }
    if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
    }
    return isNegNum ? this.ineg() : this;
};
BN.prototype.muln = function muln(num) {
    return this.clone().imuln(num);
};
BN.prototype.sqr = function sqr() {
    return this.mul(this);
};
BN.prototype.isqr = function isqr() {
    return this.imul(this.clone());
};
BN.prototype.pow = function pow(num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);
    var res = this;
    for(var i = 0; i < w.length; i++, res = res.sqr()){
        if (w[i] !== 0) break;
    }
    if (++i < w.length) {
        for(var q = res.sqr(); i < w.length; i++, q = q.sqr()){
            if (w[i] === 0) continue;
            res = res.mul(q);
        }
    }
    return res;
};
BN.prototype.iushln = function iushln(bits) {
    assert2(typeof bits === "number" && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
    var i;
    if (r !== 0) {
        var carry = 0;
        for(i = 0; i < this.length; i++){
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
        }
        if (carry) {
            this.words[i] = carry;
            this.length++;
        }
    }
    if (s !== 0) {
        for(i = this.length - 1; i >= 0; i--){
            this.words[i + s] = this.words[i];
        }
        for(i = 0; i < s; i++){
            this.words[i] = 0;
        }
        this.length += s;
    }
    return this._strip();
};
BN.prototype.ishln = function ishln(bits) {
    assert2(this.negative === 0);
    return this.iushln(bits);
};
BN.prototype.iushrn = function iushrn(bits, hint, extended) {
    assert2(typeof bits === "number" && bits >= 0);
    var h;
    if (hint) {
        h = (hint - hint % 26) / 26;
    } else {
        h = 0;
    }
    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
    var maskedWords = extended;
    h -= s;
    h = Math.max(0, h);
    if (maskedWords) {
        for(var i = 0; i < s; i++){
            maskedWords.words[i] = this.words[i];
        }
        maskedWords.length = s;
    }
    if (s === 0) {} else if (this.length > s) {
        this.length -= s;
        for(i = 0; i < this.length; i++){
            this.words[i] = this.words[i + s];
        }
    } else {
        this.words[0] = 0;
        this.length = 1;
    }
    var carry = 0;
    for(i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--){
        var word = this.words[i] | 0;
        this.words[i] = carry << 26 - r | word >>> r;
        carry = word & mask;
    }
    if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
    }
    if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
    }
    return this._strip();
};
BN.prototype.ishrn = function ishrn(bits, hint, extended) {
    assert2(this.negative === 0);
    return this.iushrn(bits, hint, extended);
};
BN.prototype.shln = function shln(bits) {
    return this.clone().ishln(bits);
};
BN.prototype.ushln = function ushln(bits) {
    return this.clone().iushln(bits);
};
BN.prototype.shrn = function shrn(bits) {
    return this.clone().ishrn(bits);
};
BN.prototype.ushrn = function ushrn(bits) {
    return this.clone().iushrn(bits);
};
BN.prototype.testn = function testn(bit) {
    assert2(typeof bit === "number" && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;
    if (this.length <= s) return false;
    var w = this.words[s];
    return !!(w & q);
};
BN.prototype.imaskn = function imaskn(bits) {
    assert2(typeof bits === "number" && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    assert2(this.negative === 0, "imaskn works only with positive numbers");
    if (this.length <= s) {
        return this;
    }
    if (r !== 0) {
        s++;
    }
    this.length = Math.min(s, this.length);
    if (r !== 0) {
        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
        this.words[this.length - 1] &= mask;
    }
    return this._strip();
};
BN.prototype.maskn = function maskn(bits) {
    return this.clone().imaskn(bits);
};
BN.prototype.iaddn = function iaddn(num) {
    assert2(typeof num === "number");
    assert2(num < 0x4000000);
    if (num < 0) return this.isubn(-num);
    if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
    }
    return this._iaddn(num);
};
BN.prototype._iaddn = function _iaddn(num) {
    this.words[0] += num;
    for(var i = 0; i < this.length && this.words[i] >= 0x4000000; i++){
        this.words[i] -= 0x4000000;
        if (i === this.length - 1) {
            this.words[i + 1] = 1;
        } else {
            this.words[i + 1]++;
        }
    }
    this.length = Math.max(this.length, i + 1);
    return this;
};
BN.prototype.isubn = function isubn(num) {
    assert2(typeof num === "number");
    assert2(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);
    if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
    }
    this.words[0] -= num;
    if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
    } else {
        for(var i = 0; i < this.length && this.words[i] < 0; i++){
            this.words[i] += 0x4000000;
            this.words[i + 1] -= 1;
        }
    }
    return this._strip();
};
BN.prototype.addn = function addn(num) {
    return this.clone().iaddn(num);
};
BN.prototype.subn = function subn(num) {
    return this.clone().isubn(num);
};
BN.prototype.iabs = function iabs() {
    this.negative = 0;
    return this;
};
BN.prototype.abs = function abs() {
    return this.clone().iabs();
};
BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
    var len = num.length + shift;
    var i;
    this._expand(len);
    var w;
    var carry = 0;
    for(i = 0; i < num.length; i++){
        w = (this.words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul;
        w -= right & 0x3ffffff;
        carry = (w >> 26) - (right / 0x4000000 | 0);
        this.words[i + shift] = w & 0x3ffffff;
    }
    for(; i < this.length - shift; i++){
        w = (this.words[i + shift] | 0) + carry;
        carry = w >> 26;
        this.words[i + shift] = w & 0x3ffffff;
    }
    if (carry === 0) return this._strip();
    assert2(carry === -1);
    carry = 0;
    for(i = 0; i < this.length; i++){
        w = -(this.words[i] | 0) + carry;
        carry = w >> 26;
        this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;
    return this._strip();
};
BN.prototype._wordDiv = function _wordDiv(num, mode) {
    var shift = this.length - num.length;
    var a = this.clone();
    var b = num;
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
        b = b.ushln(shift);
        a.iushln(shift);
        bhi = b.words[b.length - 1] | 0;
    }
    var m = a.length - b.length;
    var q;
    if (mode !== "mod") {
        q = new BN(null);
        q.length = m + 1;
        q.words = new Array(q.length);
        for(var i = 0; i < q.length; i++){
            q.words[i] = 0;
        }
    }
    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
        a = diff;
        if (q) {
            q.words[m] = 1;
        }
    }
    for(var j = m - 1; j >= 0; j--){
        var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0);
        qj = Math.min(qj / bhi | 0, 0x3ffffff);
        a._ishlnsubmul(b, qj, j);
        while(a.negative !== 0){
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
                a.negative ^= 1;
            }
        }
        if (q) {
            q.words[j] = qj;
        }
    }
    if (q) {
        q._strip();
    }
    a._strip();
    if (mode !== "div" && shift !== 0) {
        a.iushrn(shift);
    }
    return {
        div: q || null,
        mod: a
    };
};
BN.prototype.divmod = function divmod(num, mode, positive) {
    assert2(!num.isZero());
    if (this.isZero()) {
        return {
            div: new BN(0),
            mod: new BN(0)
        };
    }
    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
            div = res.div.neg();
        }
        if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
                mod.iadd(num);
            }
        }
        return {
            div: div,
            mod: mod
        };
    }
    if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
            div = res.div.neg();
        }
        return {
            div: div,
            mod: res.mod
        };
    }
    if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
                mod.isub(num);
            }
        }
        return {
            div: res.div,
            mod: mod
        };
    }
    if (num.length > this.length || this.cmp(num) < 0) {
        return {
            div: new BN(0),
            mod: this
        };
    }
    if (num.length === 1) {
        if (mode === "div") {
            return {
                div: this.divn(num.words[0]),
                mod: null
            };
        }
        if (mode === "mod") {
            return {
                div: null,
                mod: new BN(this.modrn(num.words[0]))
            };
        }
        return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modrn(num.words[0]))
        };
    }
    return this._wordDiv(num, mode);
};
BN.prototype.div = function div(num) {
    return this.divmod(num, "div", false).div;
};
BN.prototype.mod = function mod(num) {
    return this.divmod(num, "mod", false).mod;
};
BN.prototype.umod = function umod(num) {
    return this.divmod(num, "mod", true).mod;
};
BN.prototype.divRound = function divRound(num) {
    var dm = this.divmod(num);
    if (dm.mod.isZero()) return dm.div;
    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
};
BN.prototype.modrn = function modrn(num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;
    assert2(num <= 0x3ffffff);
    var p = (1 << 26) % num;
    var acc = 0;
    for(var i = this.length - 1; i >= 0; i--){
        acc = (p * acc + (this.words[i] | 0)) % num;
    }
    return isNegNum ? -acc : acc;
};
BN.prototype.modn = function modn(num) {
    return this.modrn(num);
};
BN.prototype.idivn = function idivn(num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;
    assert2(num <= 0x3ffffff);
    var carry = 0;
    for(var i = this.length - 1; i >= 0; i--){
        var w = (this.words[i] | 0) + carry * 0x4000000;
        this.words[i] = w / num | 0;
        carry = w % num;
    }
    this._strip();
    return isNegNum ? this.ineg() : this;
};
BN.prototype.divn = function divn(num) {
    return this.clone().idivn(num);
};
BN.prototype.egcd = function egcd(p) {
    assert2(p.negative === 0);
    assert2(!p.isZero());
    var x = this;
    var y = p.clone();
    if (x.negative !== 0) {
        x = x.umod(p);
    } else {
        x = x.clone();
    }
    var A = new BN(1);
    var B = new BN(0);
    var C = new BN(0);
    var D = new BN(1);
    var g = 0;
    while(x.isEven() && y.isEven()){
        x.iushrn(1);
        y.iushrn(1);
        ++g;
    }
    var yp = y.clone();
    var xp = x.clone();
    while(!x.isZero()){
        for(var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
        if (i > 0) {
            x.iushrn(i);
            while(i-- > 0){
                if (A.isOdd() || B.isOdd()) {
                    A.iadd(yp);
                    B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
            }
        }
        for(var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
        if (j > 0) {
            y.iushrn(j);
            while(j-- > 0){
                if (C.isOdd() || D.isOdd()) {
                    C.iadd(yp);
                    D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
            }
        }
        if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
        } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
        }
    }
    return {
        a: C,
        b: D,
        gcd: y.iushln(g)
    };
};
BN.prototype._invmp = function _invmp(p) {
    assert2(p.negative === 0);
    assert2(!p.isZero());
    var a = this;
    var b = p.clone();
    if (a.negative !== 0) {
        a = a.umod(p);
    } else {
        a = a.clone();
    }
    var x1 = new BN(1);
    var x2 = new BN(0);
    var delta = b.clone();
    while(a.cmpn(1) > 0 && b.cmpn(1) > 0){
        for(var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
        if (i > 0) {
            a.iushrn(i);
            while(i-- > 0){
                if (x1.isOdd()) {
                    x1.iadd(delta);
                }
                x1.iushrn(1);
            }
        }
        for(var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
        if (j > 0) {
            b.iushrn(j);
            while(j-- > 0){
                if (x2.isOdd()) {
                    x2.iadd(delta);
                }
                x2.iushrn(1);
            }
        }
        if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
        } else {
            b.isub(a);
            x2.isub(x1);
        }
    }
    var res;
    if (a.cmpn(1) === 0) {
        res = x1;
    } else {
        res = x2;
    }
    if (res.cmpn(0) < 0) {
        res.iadd(p);
    }
    return res;
};
BN.prototype.gcd = function gcd(num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();
    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;
    for(var shift = 0; a.isEven() && b.isEven(); shift++){
        a.iushrn(1);
        b.iushrn(1);
    }
    do {
        while(a.isEven()){
            a.iushrn(1);
        }
        while(b.isEven()){
            b.iushrn(1);
        }
        var r = a.cmp(b);
        if (r < 0) {
            var t = a;
            a = b;
            b = t;
        } else if (r === 0 || b.cmpn(1) === 0) {
            break;
        }
        a.isub(b);
    }while (true)
    return b.iushln(shift);
};
BN.prototype.invm = function invm(num) {
    return this.egcd(num).a.umod(num);
};
BN.prototype.isEven = function isEven() {
    return (this.words[0] & 1) === 0;
};
BN.prototype.isOdd = function isOdd() {
    return (this.words[0] & 1) === 1;
};
BN.prototype.andln = function andln(num) {
    return this.words[0] & num;
};
BN.prototype.bincn = function bincn(bit) {
    assert2(typeof bit === "number");
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;
    if (this.length <= s) {
        this._expand(s + 1);
        this.words[s] |= q;
        return this;
    }
    var carry = q;
    for(var i = s; carry !== 0 && i < this.length; i++){
        var w = this.words[i] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 0x3ffffff;
        this.words[i] = w;
    }
    if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
    }
    return this;
};
BN.prototype.isZero = function isZero() {
    return this.length === 1 && this.words[0] === 0;
};
BN.prototype.cmpn = function cmpn(num) {
    var negative = num < 0;
    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;
    this._strip();
    var res;
    if (this.length > 1) {
        res = 1;
    } else {
        if (negative) {
            num = -num;
        }
        assert2(num <= 0x3ffffff, "Number is too big");
        var w = this.words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
};
BN.prototype.cmp = function cmp(num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;
    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
};
BN.prototype.ucmp = function ucmp(num) {
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;
    var res = 0;
    for(var i = this.length - 1; i >= 0; i--){
        var a = this.words[i] | 0;
        var b = num.words[i] | 0;
        if (a === b) continue;
        if (a < b) {
            res = -1;
        } else if (a > b) {
            res = 1;
        }
        break;
    }
    return res;
};
BN.prototype.gtn = function gtn(num) {
    return this.cmpn(num) === 1;
};
BN.prototype.gt = function gt(num) {
    return this.cmp(num) === 1;
};
BN.prototype.gten = function gten(num) {
    return this.cmpn(num) >= 0;
};
BN.prototype.gte = function gte(num) {
    return this.cmp(num) >= 0;
};
BN.prototype.ltn = function ltn(num) {
    return this.cmpn(num) === -1;
};
BN.prototype.lt = function lt(num) {
    return this.cmp(num) === -1;
};
BN.prototype.lten = function lten(num) {
    return this.cmpn(num) <= 0;
};
BN.prototype.lte = function lte(num) {
    return this.cmp(num) <= 0;
};
BN.prototype.eqn = function eqn(num) {
    return this.cmpn(num) === 0;
};
BN.prototype.eq = function eq(num) {
    return this.cmp(num) === 0;
};
BN.red = function red(num) {
    return new Red(num);
};
BN.prototype.toRed = function toRed(ctx) {
    assert2(!this.red, "Already a number in reduction context");
    assert2(this.negative === 0, "red works only with positives");
    return ctx.convertTo(this)._forceRed(ctx);
};
BN.prototype.fromRed = function fromRed() {
    assert2(this.red, "fromRed works only with numbers in reduction context");
    return this.red.convertFrom(this);
};
BN.prototype._forceRed = function _forceRed(ctx) {
    this.red = ctx;
    return this;
};
BN.prototype.forceRed = function forceRed(ctx) {
    assert2(!this.red, "Already a number in reduction context");
    return this._forceRed(ctx);
};
BN.prototype.redAdd = function redAdd(num) {
    assert2(this.red, "redAdd works only with red numbers");
    return this.red.add(this, num);
};
BN.prototype.redIAdd = function redIAdd(num) {
    assert2(this.red, "redIAdd works only with red numbers");
    return this.red.iadd(this, num);
};
BN.prototype.redSub = function redSub(num) {
    assert2(this.red, "redSub works only with red numbers");
    return this.red.sub(this, num);
};
BN.prototype.redISub = function redISub(num) {
    assert2(this.red, "redISub works only with red numbers");
    return this.red.isub(this, num);
};
BN.prototype.redShl = function redShl(num) {
    assert2(this.red, "redShl works only with red numbers");
    return this.red.shl(this, num);
};
BN.prototype.redMul = function redMul(num) {
    assert2(this.red, "redMul works only with red numbers");
    this.red._verify2(this, num);
    return this.red.mul(this, num);
};
BN.prototype.redIMul = function redIMul(num) {
    assert2(this.red, "redMul works only with red numbers");
    this.red._verify2(this, num);
    return this.red.imul(this, num);
};
BN.prototype.redSqr = function redSqr() {
    assert2(this.red, "redSqr works only with red numbers");
    this.red._verify1(this);
    return this.red.sqr(this);
};
BN.prototype.redISqr = function redISqr() {
    assert2(this.red, "redISqr works only with red numbers");
    this.red._verify1(this);
    return this.red.isqr(this);
};
BN.prototype.redSqrt = function redSqrt() {
    assert2(this.red, "redSqrt works only with red numbers");
    this.red._verify1(this);
    return this.red.sqrt(this);
};
BN.prototype.redInvm = function redInvm() {
    assert2(this.red, "redInvm works only with red numbers");
    this.red._verify1(this);
    return this.red.invm(this);
};
BN.prototype.redNeg = function redNeg() {
    assert2(this.red, "redNeg works only with red numbers");
    this.red._verify1(this);
    return this.red.neg(this);
};
BN.prototype.redPow = function redPow(num) {
    assert2(this.red && !num.red, "redPow(normalNum)");
    this.red._verify1(this);
    return this.red.pow(this, num);
};
var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
};
function MPrime(name, p) {
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);
    this.tmp = this._tmp();
}
MPrime.prototype._tmp = function _tmp() {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
};
MPrime.prototype.ireduce = function ireduce(num) {
    var r = num;
    var rlen;
    do {
        this.split(r, this.tmp);
        r = this.imulK(r);
        r = r.iadd(this.tmp);
        rlen = r.bitLength();
    }while (rlen > this.n)
    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
        r.words[0] = 0;
        r.length = 1;
    } else if (cmp > 0) {
        r.isub(this.p);
    } else {
        if (r.strip !== undefined) {
            r.strip();
        } else {
            r._strip();
        }
    }
    return r;
};
MPrime.prototype.split = function split(input, out) {
    input.iushrn(this.n, 0, out);
};
MPrime.prototype.imulK = function imulK(num) {
    return num.imul(this.k);
};
function K256() {
    MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
}
inherits(K256, MPrime);
K256.prototype.split = function split(input, output) {
    var mask = 0x3fffff;
    var outLen = Math.min(input.length, 9);
    for(var i = 0; i < outLen; i++){
        output.words[i] = input.words[i];
    }
    output.length = outLen;
    if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
    }
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;
    for(i = 10; i < input.length; i++){
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
        input.length -= 10;
    } else {
        input.length -= 9;
    }
};
K256.prototype.imulK = function imulK(num) {
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;
    var lo = 0;
    for(var i = 0; i < num.length; i++){
        var w = num.words[i] | 0;
        lo += w * 0x3d1;
        num.words[i] = lo & 0x3ffffff;
        lo = w * 0x40 + (lo / 0x4000000 | 0);
    }
    if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
            num.length--;
        }
    }
    return num;
};
function P224() {
    MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
}
inherits(P224, MPrime);
function P192() {
    MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
}
inherits(P192, MPrime);
function P25519() {
    MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
}
inherits(P25519, MPrime);
P25519.prototype.imulK = function imulK(num) {
    var carry = 0;
    for(var i = 0; i < num.length; i++){
        var hi = (num.words[i] | 0) * 0x13 + carry;
        var lo = hi & 0x3ffffff;
        hi >>>= 26;
        num.words[i] = lo;
        carry = hi;
    }
    if (carry !== 0) {
        num.words[num.length++] = carry;
    }
    return num;
};
BN._prime = function prime(name) {
    if (primes[name]) return primes[name];
    var prime;
    if (name === "k256") {
        prime = new K256();
    } else if (name === "p224") {
        prime = new P224();
    } else if (name === "p192") {
        prime = new P192();
    } else if (name === "p25519") {
        prime = new P25519();
    } else {
        throw new Error("Unknown prime " + name);
    }
    primes[name] = prime;
    return prime;
};
function Red(m) {
    if (typeof m === "string") {
        var prime = BN._prime(m);
        this.m = prime.p;
        this.prime = prime;
    } else {
        assert2(m.gtn(1), "modulus must be greater than 1");
        this.m = m;
        this.prime = null;
    }
}
Red.prototype._verify1 = function _verify1(a) {
    assert2(a.negative === 0, "red works only with positives");
    assert2(a.red, "red works only with red numbers");
};
Red.prototype._verify2 = function _verify2(a, b) {
    assert2((a.negative | b.negative) === 0, "red works only with positives");
    assert2(a.red && a.red === b.red, "red works only with red numbers");
};
Red.prototype.imod = function imod(a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    move(a, a.umod(this.m)._forceRed(this));
    return a;
};
Red.prototype.neg = function neg(a) {
    if (a.isZero()) {
        return a.clone();
    }
    return this.m.sub(a)._forceRed(this);
};
Red.prototype.add = function add(a, b) {
    this._verify2(a, b);
    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
    }
    return res._forceRed(this);
};
Red.prototype.iadd = function iadd(a, b) {
    this._verify2(a, b);
    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
    }
    return res;
};
Red.prototype.sub = function sub(a, b) {
    this._verify2(a, b);
    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
        res.iadd(this.m);
    }
    return res._forceRed(this);
};
Red.prototype.isub = function isub(a, b) {
    this._verify2(a, b);
    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
        res.iadd(this.m);
    }
    return res;
};
Red.prototype.shl = function shl(a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
};
Red.prototype.imul = function imul(a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
};
Red.prototype.mul = function mul(a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
};
Red.prototype.isqr = function isqr(a) {
    return this.imul(a, a.clone());
};
Red.prototype.sqr = function sqr(a) {
    return this.mul(a, a);
};
Red.prototype.sqrt = function sqrt(a) {
    if (a.isZero()) return a.clone();
    var mod3 = this.m.andln(3);
    assert2(mod3 % 2 === 1);
    if (mod3 === 3) {
        var pow = this.m.add(new BN(1)).iushrn(2);
        return this.pow(a, pow);
    }
    var q = this.m.subn(1);
    var s = 0;
    while(!q.isZero() && q.andln(1) === 0){
        s++;
        q.iushrn(1);
    }
    assert2(!q.isZero());
    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);
    while(this.pow(z, lpow).cmp(nOne) !== 0){
        z.redIAdd(nOne);
    }
    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while(t.cmp(one) !== 0){
        var tmp = t;
        for(var i = 0; tmp.cmp(one) !== 0; i++){
            tmp = tmp.redSqr();
        }
        assert2(i < m);
        var b = this.pow(c, new BN(1).iushln(m - i - 1));
        r = r.redMul(b);
        c = b.redSqr();
        t = t.redMul(c);
        m = i;
    }
    return r;
};
Red.prototype.invm = function invm(a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
    } else {
        return this.imod(inv);
    }
};
Red.prototype.pow = function pow(a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();
    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for(var i = 2; i < wnd.length; i++){
        wnd[i] = this.mul(wnd[i - 1], a);
    }
    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
        start = 26;
    }
    for(i = num.length - 1; i >= 0; i--){
        var word = num.words[i];
        for(var j = start - 1; j >= 0; j--){
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
                res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
        }
        start = 26;
    }
    return res;
};
Red.prototype.convertTo = function convertTo(num) {
    var r = num.umod(this.m);
    return r === num ? r.clone() : r;
};
Red.prototype.convertFrom = function convertFrom(num) {
    var res = num.clone();
    res.red = null;
    return res;
};
BN.mont = function mont(num) {
    return new Mont(num);
};
function Mont(m) {
    Red.call(this, m);
    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
    }
    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);
    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
}
inherits(Mont, Red);
Mont.prototype.convertTo = function convertTo(num) {
    return this.imod(num.ushln(this.shift));
};
Mont.prototype.convertFrom = function convertFrom(num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
};
Mont.prototype.imul = function imul(a, b) {
    if (a.isZero() || b.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
    }
    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
    }
    return res._forceRed(this);
};
Mont.prototype.mul = function mul(a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
    }
    return res._forceRed(this);
};
Mont.prototype.invm = function invm(a) {
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
};
function Reporter(options) {
    this._reporterState = {
        obj: null,
        path: [],
        options: options || {},
        errors: []
    };
}
Reporter.prototype.isError = function isError(obj) {
    return obj instanceof ReporterError;
};
Reporter.prototype.save = function save() {
    const state = this._reporterState;
    return {
        obj: state.obj,
        pathLen: state.path.length
    };
};
Reporter.prototype.restore = function restore(data) {
    const state = this._reporterState;
    state.obj = data.obj;
    state.path = state.path.slice(0, data.pathLen);
};
Reporter.prototype.enterKey = function enterKey(key) {
    return this._reporterState.path.push(key);
};
Reporter.prototype.exitKey = function exitKey(index) {
    const state = this._reporterState;
    state.path = state.path.slice(0, index - 1);
};
Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
    const state = this._reporterState;
    this.exitKey(index);
    if (state.obj !== null) {
        state.obj[key] = value;
    }
};
Reporter.prototype.path = function path() {
    return this._reporterState.path.join("/");
};
Reporter.prototype.enterObject = function enterObject() {
    const state = this._reporterState;
    const prev = state.obj;
    state.obj = {};
    return prev;
};
Reporter.prototype.leaveObject = function leaveObject(prev) {
    const state = this._reporterState;
    const now = state.obj;
    state.obj = prev;
    return now;
};
Reporter.prototype.error = function error(msg) {
    let err;
    const state = this._reporterState;
    const inherited = msg instanceof ReporterError;
    if (inherited) {
        err = msg;
    } else {
        err = new ReporterError(state.path.map(function(elem) {
            return "[" + JSON.stringify(elem) + "]";
        }).join(""), msg.message || msg, msg.stack);
    }
    if (!state.options.partial) {
        throw err;
    }
    if (!inherited) {
        state.errors.push(err);
    }
    return err;
};
Reporter.prototype.wrapResult = function wrapResult(result) {
    const state = this._reporterState;
    if (!state.options.partial) {
        return result;
    }
    return {
        result: this.isError(result) ? null : result,
        errors: state.errors
    };
};
function ReporterError(path, msg) {
    this.path = path;
    this.rethrow(msg);
}
ReporterError.prototype = Object.create(Error.prototype, {
    constructor: {
        value: ReporterError,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
ReporterError.prototype.rethrow = function rethrow(msg) {
    this.message = msg + " at: " + (this.path || "(shallow)");
    if (Error.captureStackTrace) {
        Error.captureStackTrace(this, ReporterError);
    }
    if (!this.stack) {
        try {
            throw new Error(this.message);
        } catch (e) {
            this.stack = e.stack;
        }
    }
    return this;
};
function DecoderBuffer(base, options) {
    Reporter.call(this, options);
    if (!Buffer.isBuffer(base)) {
        this.error("Input not Buffer");
        return;
    }
    this.base = base;
    this.offset = 0;
    this.length = base.length;
}
DecoderBuffer.prototype = Object.create(Reporter.prototype, {
    constructor: {
        value: DecoderBuffer,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
    if (data instanceof DecoderBuffer) {
        return true;
    }
    const isCompatible = typeof data === "object" && Buffer.isBuffer(data.base) && data.constructor.name === "DecoderBuffer" && typeof data.offset === "number" && typeof data.length === "number" && typeof data.save === "function" && typeof data.restore === "function" && typeof data.isEmpty === "function" && typeof data.readUInt8 === "function" && typeof data.skip === "function" && typeof data.raw === "function";
    return isCompatible;
};
DecoderBuffer.prototype.save = function save() {
    return {
        offset: this.offset,
        reporter: Reporter.prototype.save.call(this)
    };
};
DecoderBuffer.prototype.restore = function restore(save) {
    const res = new DecoderBuffer(this.base);
    res.offset = save.offset;
    res.length = this.offset;
    this.offset = save.offset;
    Reporter.prototype.restore.call(this, save.reporter);
    return res;
};
DecoderBuffer.prototype.isEmpty = function isEmpty() {
    return this.offset === this.length;
};
DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
    if (this.offset + 1 <= this.length) {
        return this.base.readUInt8(this.offset++, true);
    } else {
        return this.error(fail || "DecoderBuffer overrun");
    }
};
DecoderBuffer.prototype.skip = function skip(bytes, fail) {
    if (!(this.offset + bytes <= this.length)) {
        return this.error(fail || "DecoderBuffer overrun");
    }
    const res = new DecoderBuffer(this.base);
    res._reporterState = this._reporterState;
    res.offset = this.offset;
    res.length = this.offset + bytes;
    this.offset += bytes;
    return res;
};
DecoderBuffer.prototype.raw = function raw(save) {
    return this.base.slice(save ? save.offset : this.offset, this.length);
};
function EncoderBuffer(value, reporter) {
    if (Array.isArray(value)) {
        this.length = 0;
        this.value = value.map(function(item) {
            if (!EncoderBuffer.isEncoderBuffer(item)) {
                item = new EncoderBuffer(item, reporter);
            }
            this.length += item.length;
            return item;
        }, this);
    } else if (typeof value === "number") {
        if (!(0 <= value && value <= 0xff)) {
            return reporter.error("non-byte EncoderBuffer value");
        }
        this.value = value;
        this.length = 1;
    } else if (typeof value === "string") {
        this.value = value;
        this.length = Buffer.byteLength(value);
    } else if (Buffer.isBuffer(value)) {
        this.value = value;
        this.length = value.length;
    } else {
        return reporter.error("Unsupported type: " + typeof value);
    }
}
EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
    if (data instanceof EncoderBuffer) {
        return true;
    }
    const isCompatible = typeof data === "object" && data.constructor.name === "EncoderBuffer" && typeof data.length === "number" && typeof data.join === "function";
    return isCompatible;
};
EncoderBuffer.prototype.join = function join(out, offset) {
    if (!out) {
        out = Buffer.alloc(this.length);
    }
    if (!offset) {
        offset = 0;
    }
    if (this.length === 0) {
        return out;
    }
    if (Array.isArray(this.value)) {
        this.value.forEach(function(item) {
            item.join(out, offset);
            offset += item.length;
        });
    } else {
        if (typeof this.value === "number") {
            out[offset] = this.value;
        } else if (typeof this.value === "string") {
            out.write(this.value, offset);
        } else if (Buffer.isBuffer(this.value)) {
            this.value.copy(out, offset);
        }
        offset += this.length;
    }
    return out;
};
const tags = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
];
const methods = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
].concat(tags);
const overrided = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
];
function Node(enc, parent, name) {
    const state = {};
    this._baseState = state;
    state.name = name;
    state.enc = enc;
    state.parent = parent || null;
    state.children = null;
    state.tag = null;
    state.args = null;
    state.reverseArgs = null;
    state.choice = null;
    state.optional = false;
    state.any = false;
    state.obj = false;
    state.use = null;
    state.useDecoder = null;
    state.key = null;
    state["default"] = null;
    state.explicit = null;
    state.implicit = null;
    state.contains = null;
    if (!state.parent) {
        state.children = [];
        this._wrap();
    }
}
const stateProps = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
];
Node.prototype.clone = function clone() {
    const state = this._baseState;
    const cstate = {};
    stateProps.forEach(function(prop) {
        cstate[prop] = state[prop];
    });
    const res = new this.constructor(cstate.parent);
    res._baseState = cstate;
    return res;
};
Node.prototype._wrap = function wrap() {
    const state = this._baseState;
    methods.forEach(function(method) {
        this[method] = function _wrappedMethod() {
            const clone = new this.constructor(this);
            state.children.push(clone);
            return clone[method].apply(clone, arguments);
        };
    }, this);
};
Node.prototype._init = function init(body) {
    const state = this._baseState;
    assert1(state.parent === null);
    body.call(this);
    state.children = state.children.filter(function(child) {
        return child._baseState.parent === this;
    }, this);
    assert1(state.children.length === 1, "Root node can have only one child");
};
Node.prototype._useArgs = function useArgs(args) {
    const state = this._baseState;
    const children = args.filter(function(arg) {
        return arg instanceof this.constructor;
    }, this);
    args = args.filter(function(arg) {
        return !(arg instanceof this.constructor);
    }, this);
    if (children.length !== 0) {
        assert1(state.children === null);
        state.children = children;
        children.forEach(function(child) {
            child._baseState.parent = this;
        }, this);
    }
    if (args.length !== 0) {
        assert1(state.args === null);
        state.args = args;
        state.reverseArgs = args.map(function(arg) {
            if (typeof arg !== "object" || arg.constructor !== Object) {
                return arg;
            }
            const res = {};
            Object.keys(arg).forEach(function(key) {
                if (key == (key | 0)) {
                    key |= 0;
                }
                const value = arg[key];
                res[value] = key;
            });
            return res;
        });
    }
};
overrided.forEach(function(method) {
    Node.prototype[method] = function _overrided() {
        const state = this._baseState;
        throw new Error(method + " not implemented for encoding: " + state.enc);
    };
});
tags.forEach(function(tag) {
    Node.prototype[tag] = function _tagMethod() {
        const state = this._baseState;
        const args = Array.prototype.slice.call(arguments);
        assert1(state.tag === null);
        state.tag = tag;
        this._useArgs(args);
        return this;
    };
});
Node.prototype.use = function use(item) {
    assert1(item);
    const state = this._baseState;
    assert1(state.use === null);
    state.use = item;
    return this;
};
Node.prototype.optional = function optional() {
    const state = this._baseState;
    state.optional = true;
    return this;
};
Node.prototype.def = function def(val) {
    const state = this._baseState;
    assert1(state["default"] === null);
    state["default"] = val;
    state.optional = true;
    return this;
};
Node.prototype.explicit = function explicit(num) {
    const state = this._baseState;
    assert1(state.explicit === null && state.implicit === null);
    state.explicit = num;
    return this;
};
Node.prototype.implicit = function implicit(num) {
    const state = this._baseState;
    assert1(state.explicit === null && state.implicit === null);
    state.implicit = num;
    return this;
};
Node.prototype.obj = function obj() {
    const state = this._baseState;
    const args = Array.prototype.slice.call(arguments);
    state.obj = true;
    if (args.length !== 0) {
        this._useArgs(args);
    }
    return this;
};
Node.prototype.key = function key(newKey) {
    const state = this._baseState;
    assert1(state.key === null);
    state.key = newKey;
    return this;
};
Node.prototype.any = function any() {
    const state = this._baseState;
    state.any = true;
    return this;
};
Node.prototype.choice = function choice(obj) {
    const state = this._baseState;
    assert1(state.choice === null);
    state.choice = obj;
    this._useArgs(Object.keys(obj).map(function(key) {
        return obj[key];
    }));
    return this;
};
Node.prototype.contains = function contains(item) {
    const state = this._baseState;
    assert1(state.use === null);
    state.contains = item;
    return this;
};
Node.prototype._decode = function decode(input, options) {
    const state = this._baseState;
    if (state.parent === null) {
        return input.wrapResult(state.children[0]._decode(input, options));
    }
    let result = state["default"];
    let present = true;
    let prevKey = null;
    if (state.key !== null) {
        prevKey = input.enterKey(state.key);
    }
    if (state.optional) {
        let tag = null;
        if (state.explicit !== null) {
            tag = state.explicit;
        } else if (state.implicit !== null) {
            tag = state.implicit;
        } else if (state.tag !== null) {
            tag = state.tag;
        }
        if (tag === null && !state.any) {
            const save = input.save();
            try {
                if (state.choice === null) {
                    this._decodeGeneric(state.tag, input, options);
                } else {
                    this._decodeChoice(input, options);
                }
                present = true;
            } catch (_e) {
                present = false;
            }
            input.restore(save);
        } else {
            present = this._peekTag(input, tag, state.any);
            if (input.isError(present)) {
                return present;
            }
        }
    }
    let prevObj;
    if (state.obj && present) {
        prevObj = input.enterObject();
    }
    if (present) {
        if (state.explicit !== null) {
            const explicit = this._decodeTag(input, state.explicit);
            if (input.isError(explicit)) {
                return explicit;
            }
            input = explicit;
        }
        const start = input.offset;
        if (state.use === null && state.choice === null) {
            let save;
            if (state.any) {
                save = input.save();
            }
            const body = this._decodeTag(input, state.implicit !== null ? state.implicit : state.tag, state.any);
            if (input.isError(body)) {
                return body;
            }
            if (state.any) {
                result = input.raw(save);
            } else {
                input = body;
            }
        }
        if (options && options.track && state.tag !== null) {
            options.track(input.path(), start, input.length, "tagged");
        }
        if (options && options.track && state.tag !== null) {
            options.track(input.path(), input.offset, input.length, "content");
        }
        if (state.any) {} else if (state.choice === null) {
            result = this._decodeGeneric(state.tag, input, options);
        } else {
            result = this._decodeChoice(input, options);
        }
        if (input.isError(result)) {
            return result;
        }
        if (!state.any && state.choice === null && state.children !== null) {
            state.children.forEach(function decodeChildren(child) {
                child._decode(input, options);
            });
        }
        if (state.contains && (state.tag === "octstr" || state.tag === "bitstr")) {
            const data = new DecoderBuffer(result);
            result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
        }
    }
    if (state.obj && present) {
        result = input.leaveObject(prevObj);
    }
    if (state.key !== null && (result !== null || present === true)) {
        input.leaveKey(prevKey, state.key, result);
    } else if (prevKey !== null) {
        input.exitKey(prevKey);
    }
    return result;
};
Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
    const state = this._baseState;
    if (tag === "seq" || tag === "set") {
        return null;
    }
    if (tag === "seqof" || tag === "setof") {
        return this._decodeList(input, tag, state.args[0], options);
    } else if (/str$/.test(tag)) {
        return this._decodeStr(input, tag, options);
    } else if (tag === "objid" && state.args) {
        return this._decodeObjid(input, state.args[0], state.args[1], options);
    } else if (tag === "objid") {
        return this._decodeObjid(input, null, null, options);
    } else if (tag === "gentime" || tag === "utctime") {
        return this._decodeTime(input, tag, options);
    } else if (tag === "null_") {
        return this._decodeNull(input, options);
    } else if (tag === "bool") {
        return this._decodeBool(input, options);
    } else if (tag === "objDesc") {
        return this._decodeStr(input, tag, options);
    } else if (tag === "int" || tag === "enum") {
        return this._decodeInt(input, state.args && state.args[0], options);
    }
    if (state.use !== null) {
        return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
    } else {
        return input.error("unknown tag: " + tag);
    }
};
Node.prototype._getUse = function _getUse(entity, obj) {
    const state = this._baseState;
    state.useDecoder = this._use(entity, obj);
    assert1(state.useDecoder._baseState.parent === null);
    state.useDecoder = state.useDecoder._baseState.children[0];
    if (state.implicit !== state.useDecoder._baseState.implicit) {
        state.useDecoder = state.useDecoder.clone();
        state.useDecoder._baseState.implicit = state.implicit;
    }
    return state.useDecoder;
};
Node.prototype._decodeChoice = function decodeChoice(input, options) {
    const state = this._baseState;
    let result = null;
    let match = false;
    Object.keys(state.choice).some(function(key) {
        const save = input.save();
        const node = state.choice[key];
        try {
            const value = node._decode(input, options);
            if (input.isError(value)) {
                return false;
            }
            result = {
                type: key,
                value: value
            };
            match = true;
        } catch (_e) {
            input.restore(save);
            return false;
        }
        return true;
    }, this);
    if (!match) {
        return input.error("Choice not matched");
    }
    return result;
};
Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
    return new EncoderBuffer(data, this.reporter);
};
Node.prototype._encode = function encode(data, reporter, parent) {
    const state = this._baseState;
    if (state["default"] !== null && state["default"] === data) {
        return;
    }
    const result = this._encodeValue(data, reporter, parent);
    if (result === undefined) {
        return;
    }
    if (this._skipDefault(result, reporter, parent)) {
        return;
    }
    return result;
};
Node.prototype._encodeValue = function encode(data, reporter, parent) {
    const state = this._baseState;
    if (state.parent === null) {
        return state.children[0]._encode(data, reporter || new Reporter());
    }
    let result = null;
    this.reporter = reporter;
    if (state.optional && data === undefined) {
        if (state["default"] !== null) {
            data = state["default"];
        } else {
            return;
        }
    }
    let content = null;
    let primitive = false;
    if (state.any) {
        result = this._createEncoderBuffer(data);
    } else if (state.choice) {
        result = this._encodeChoice(data, reporter);
    } else if (state.contains) {
        content = this._getUse(state.contains, parent)._encode(data, reporter);
        primitive = true;
    } else if (state.children) {
        content = state.children.map(function(child) {
            if (child._baseState.tag === "null_") {
                return child._encode(null, reporter, data);
            }
            if (child._baseState.key === null) {
                return reporter.error("Child should have a key");
            }
            const prevKey = reporter.enterKey(child._baseState.key);
            if (typeof data !== "object") {
                return reporter.error("Child expected, but input is not object");
            }
            const res = child._encode(data[child._baseState.key], reporter, data);
            reporter.leaveKey(prevKey);
            return res;
        }, this).filter(function(child) {
            return child;
        });
        content = this._createEncoderBuffer(content);
    } else {
        if (state.tag === "seqof" || state.tag === "setof") {
            if (!(state.args && state.args.length === 1)) {
                return reporter.error("Too many args for : " + state.tag);
            }
            if (!Array.isArray(data)) {
                return reporter.error("seqof/setof, but data is not Array");
            }
            const child = this.clone();
            child._baseState.implicit = null;
            content = this._createEncoderBuffer(data.map(function(item) {
                const state = this._baseState;
                return this._getUse(state.args[0], data)._encode(item, reporter);
            }, child));
        } else if (state.use !== null) {
            result = this._getUse(state.use, parent)._encode(data, reporter);
        } else {
            content = this._encodePrimitive(state.tag, data);
            primitive = true;
        }
    }
    if (!state.any && state.choice === null) {
        const tag = state.implicit !== null ? state.implicit : state.tag;
        const cls = state.implicit === null ? "universal" : "context";
        if (tag === null) {
            if (state.use === null) {
                reporter.error("Tag could be omitted only for .use()");
            }
        } else {
            if (state.use === null) {
                result = this._encodeComposite(tag, primitive, cls, content);
            }
        }
    }
    if (state.explicit !== null) {
        result = this._encodeComposite(state.explicit, false, "context", result);
    }
    return result;
};
Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
    const state = this._baseState;
    const node = state.choice[data.type];
    if (!node) {
        assert1(false, data.type + " not found in " + JSON.stringify(Object.keys(state.choice)));
    }
    return node._encode(data.value, reporter);
};
Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
    const state = this._baseState;
    if (/str$/.test(tag)) {
        return this._encodeStr(data, tag);
    } else if (tag === "objid" && state.args) {
        return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
    } else if (tag === "objid") {
        return this._encodeObjid(data, null, null);
    } else if (tag === "gentime" || tag === "utctime") {
        return this._encodeTime(data, tag);
    } else if (tag === "null_") {
        return this._encodeNull();
    } else if (tag === "int" || tag === "enum") {
        return this._encodeInt(data, state.args && state.reverseArgs[0]);
    } else if (tag === "bool") {
        return this._encodeBool(data);
    } else if (tag === "objDesc") {
        return this._encodeStr(data, tag);
    } else {
        throw new Error("Unsupported tag: " + tag);
    }
};
Node.prototype._isNumstr = function isNumstr(str) {
    return /^[0-9 ]*$/.test(str);
};
Node.prototype._isPrintstr = function isPrintstr(str) {
    return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
};
function reverse(map) {
    const res = {};
    Object.keys(map).forEach(function(key) {
        if ((key | 0) == key) {
            key = key | 0;
        }
        const value = map[key];
        res[value] = key;
    });
    return res;
}
const tagClass = {
    0: "universal",
    1: "application",
    2: "context",
    3: "private"
};
const tagClassByName = reverse(tagClass);
const tag = {
    0x00: "end",
    0x01: "bool",
    0x02: "int",
    0x03: "bitstr",
    0x04: "octstr",
    0x05: "null_",
    0x06: "objid",
    0x07: "objDesc",
    0x08: "external",
    0x09: "real",
    0x0a: "enum",
    0x0b: "embed",
    0x0c: "utf8str",
    0x0d: "relativeOid",
    0x10: "seq",
    0x11: "set",
    0x12: "numstr",
    0x13: "printstr",
    0x14: "t61str",
    0x15: "videostr",
    0x16: "ia5str",
    0x17: "utctime",
    0x18: "gentime",
    0x19: "graphstr",
    0x1a: "iso646str",
    0x1b: "genstr",
    0x1c: "unistr",
    0x1d: "charstr",
    0x1e: "bmpstr"
};
const tagByName = reverse(tag);
const mod17 = {
    tagClass: tagClass,
    tagClassByName: tagClassByName,
    tag: tag,
    tagByName: tagByName
};
function DEREncoder(entity) {
    this.enc = "der";
    this.name = entity.name;
    this.entity = entity;
    this.tree = new DERNode();
    this.tree._init(entity.body);
}
DEREncoder.prototype.encode = function encode(data, reporter) {
    return this.tree._encode(data, reporter).join();
};
function DERNode(parent) {
    Node.call(this, "der", parent);
}
DERNode.prototype = Object.create(Node.prototype, {
    constructor: {
        value: DERNode,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
    const encodedTag = encodeTag(tag, primitive, cls, this.reporter);
    if (content.length < 0x80) {
        const header = Buffer.alloc(2);
        header[0] = encodedTag;
        header[1] = content.length;
        return this._createEncoderBuffer([
            header,
            content
        ]);
    }
    let lenOctets = 1;
    for(let i = content.length; i >= 0x100; i >>= 8){
        lenOctets++;
    }
    const header = Buffer.alloc(1 + 1 + lenOctets);
    header[0] = encodedTag;
    header[1] = 0x80 | lenOctets;
    for(let i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8){
        header[i] = j & 0xff;
    }
    return this._createEncoderBuffer([
        header,
        content
    ]);
};
DERNode.prototype._encodeStr = function encodeStr(str, tag) {
    if (tag === "bitstr") {
        return this._createEncoderBuffer([
            str.unused | 0,
            str.data
        ]);
    } else if (tag === "bmpstr") {
        const buf = Buffer.alloc(str.length * 2);
        for(let i = 0; i < str.length; i++){
            buf.writeUInt16BE(str.charCodeAt(i), i * 2);
        }
        return this._createEncoderBuffer(buf);
    } else if (tag === "numstr") {
        if (!this._isNumstr(str)) {
            return this.reporter.error("Encoding of string type: numstr supports " + "only digits and space");
        }
        return this._createEncoderBuffer(str);
    } else if (tag === "printstr") {
        if (!this._isPrintstr(str)) {
            return this.reporter.error("Encoding of string type: printstr supports " + "only latin upper and lower case letters, " + "digits, space, apostrophe, left and rigth " + "parenthesis, plus sign, comma, hyphen, " + "dot, slash, colon, equal sign, " + "question mark");
        }
        return this._createEncoderBuffer(str);
    } else if (/str$/.test(tag)) {
        return this._createEncoderBuffer(str);
    } else if (tag === "objDesc") {
        return this._createEncoderBuffer(str);
    } else {
        return this.reporter.error("Encoding of string type: " + tag + " unsupported");
    }
};
DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
    if (typeof id === "string") {
        if (!values) {
            return this.reporter.error("string objid given, but no values map found");
        }
        if (!values.hasOwnProperty(id)) {
            return this.reporter.error("objid not found in values map");
        }
        id = values[id].split(/[\s.]+/g);
        for(let i = 0; i < id.length; i++){
            id[i] |= 0;
        }
    } else if (Array.isArray(id)) {
        id = id.slice();
        for(let i = 0; i < id.length; i++){
            id[i] |= 0;
        }
    }
    if (!Array.isArray(id)) {
        return this.reporter.error("objid() should be either array or string, " + "got: " + JSON.stringify(id));
    }
    if (!relative) {
        if (id[1] >= 40) {
            return this.reporter.error("Second objid identifier OOB");
        }
        id.splice(0, 2, id[0] * 40 + id[1]);
    }
    let size = 0;
    for(let i = 0; i < id.length; i++){
        let ident = id[i];
        for(size++; ident >= 0x80; ident >>= 7){
            size++;
        }
    }
    const objid = Buffer.alloc(size);
    let offset = objid.length - 1;
    for(let i = id.length - 1; i >= 0; i--){
        let ident = id[i];
        objid[offset--] = ident & 0x7f;
        while((ident >>= 7) > 0){
            objid[offset--] = 0x80 | ident & 0x7f;
        }
    }
    return this._createEncoderBuffer(objid);
};
function two(num) {
    if (num < 10) {
        return "0" + num;
    } else {
        return num;
    }
}
DERNode.prototype._encodeTime = function encodeTime(time, tag) {
    let str;
    const date = new Date(time);
    if (tag === "gentime") {
        str = [
            two(date.getUTCFullYear()),
            two(date.getUTCMonth() + 1),
            two(date.getUTCDate()),
            two(date.getUTCHours()),
            two(date.getUTCMinutes()),
            two(date.getUTCSeconds()),
            "Z"
        ].join("");
    } else if (tag === "utctime") {
        str = [
            two(date.getUTCFullYear() % 100),
            two(date.getUTCMonth() + 1),
            two(date.getUTCDate()),
            two(date.getUTCHours()),
            two(date.getUTCMinutes()),
            two(date.getUTCSeconds()),
            "Z"
        ].join("");
    } else {
        this.reporter.error("Encoding " + tag + " time is not supported yet");
    }
    return this._encodeStr(str, "octstr");
};
DERNode.prototype._encodeNull = function encodeNull() {
    return this._createEncoderBuffer("");
};
DERNode.prototype._encodeInt = function encodeInt(num, values) {
    if (typeof num === "string") {
        if (!values) {
            return this.reporter.error("String int or enum given, but no values map");
        }
        if (!values.hasOwnProperty(num)) {
            return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
        }
        num = values[num];
    }
    if (typeof num !== "number" && !Buffer.isBuffer(num)) {
        const numArray = num.toArray();
        if (!num.sign && numArray[0] & 0x80) {
            numArray.unshift(0);
        }
        num = Buffer.from(numArray);
    }
    if (Buffer.isBuffer(num)) {
        let size = num.length;
        if (num.length === 0) {
            size++;
        }
        const out = Buffer.alloc(size);
        num.copy(out);
        if (num.length === 0) {
            out[0] = 0;
        }
        return this._createEncoderBuffer(out);
    }
    if (num < 0x80) {
        return this._createEncoderBuffer(num);
    }
    if (num < 0x100) {
        return this._createEncoderBuffer([
            0,
            num
        ]);
    }
    let size = 1;
    for(let i = num; i >= 0x100; i >>= 8){
        size++;
    }
    const out = new Array(size);
    for(let i = out.length - 1; i >= 0; i--){
        out[i] = num & 0xff;
        num >>= 8;
    }
    if (out[0] & 0x80) {
        out.unshift(0);
    }
    return this._createEncoderBuffer(Buffer.from(out));
};
DERNode.prototype._encodeBool = function encodeBool(value) {
    return this._createEncoderBuffer(value ? 0xff : 0);
};
DERNode.prototype._use = function use(entity, obj) {
    if (typeof entity === "function") {
        entity = entity(obj);
    }
    return entity._getEncoder("der").tree;
};
DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
    const state = this._baseState;
    let i;
    if (state["default"] === null) {
        return false;
    }
    const data = dataBuffer.join();
    if (state.defaultBuffer === undefined) {
        state.defaultBuffer = this._encodeValue(state["default"], reporter, parent).join();
    }
    if (data.length !== state.defaultBuffer.length) {
        return false;
    }
    for(i = 0; i < data.length; i++){
        if (data[i] !== state.defaultBuffer[i]) {
            return false;
        }
    }
    return true;
};
function encodeTag(tag, primitive, cls, reporter) {
    let res;
    if (tag === "seqof") {
        tag = "seq";
    } else if (tag === "setof") {
        tag = "set";
    }
    if (tagByName.hasOwnProperty(tag)) {
        res = tagByName[tag];
    } else if (typeof tag === "number" && (tag | 0) === tag) {
        res = tag;
    } else {
        return reporter.error("Unknown tag: " + tag);
    }
    if (res >= 0x1f) {
        return reporter.error("Multi-octet tag encoding unsupported");
    }
    if (!primitive) {
        res |= 0x20;
    }
    res |= tagClassByName[cls || "universal"] << 6;
    return res;
}
function PEMEncoder(entity) {
    DEREncoder.call(this, entity);
    this.enc = "pem";
}
PEMEncoder.prototype = Object.create(DEREncoder.prototype, {
    constructor: {
        value: PEMEncoder,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
PEMEncoder.prototype.encode = function encode(data, options) {
    const buf = DEREncoder.prototype.encode.call(this, data);
    const p = buf.toString("base64");
    const out = [
        "-----BEGIN " + options.label + "-----"
    ];
    for(let i = 0; i < p.length; i += 64){
        out.push(p.slice(i, i + 64));
    }
    out.push("-----END " + options.label + "-----");
    return out.join("\n");
};
function DERDecoder(entity) {
    this.enc = "der";
    this.name = entity.name;
    this.entity = entity;
    this.tree = new DERNode1();
    this.tree._init(entity.body);
}
DERDecoder.prototype.decode = function decode(data, options) {
    if (!DecoderBuffer.isDecoderBuffer(data)) {
        data = new DecoderBuffer(data, options);
    }
    return this.tree._decode(data, options);
};
function DERNode1(parent) {
    Node.call(this, "der", parent);
}
DERNode1.prototype = Object.create(Node.prototype, {
    constructor: {
        value: DERNode1,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
DERNode1.prototype._peekTag = function peekTag(buffer, tag, any) {
    if (buffer.isEmpty()) {
        return false;
    }
    const state = buffer.save();
    const decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
    if (buffer.isError(decodedTag)) {
        return decodedTag;
    }
    buffer.restore(state);
    return decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + "of" === tag || any;
};
DERNode1.prototype._decodeTag = function decodeTag(buffer, tag, any) {
    const decodedTag = derDecodeTag(buffer, 'Failed to decode tag of "' + tag + '"');
    if (buffer.isError(decodedTag)) {
        return decodedTag;
    }
    let len = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of "' + tag + '"');
    if (buffer.isError(len)) {
        return len;
    }
    if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + "of" !== tag) {
        return buffer.error('Failed to match tag: "' + tag + '"');
    }
    if (decodedTag.primitive || len !== null) {
        return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
    }
    const state = buffer.save();
    const res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: "' + this.tag + '"');
    if (buffer.isError(res)) {
        return res;
    }
    len = buffer.offset - state.offset;
    buffer.restore(state);
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};
DERNode1.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
    for(;;){
        const tag = derDecodeTag(buffer, fail);
        if (buffer.isError(tag)) {
            return tag;
        }
        const len = derDecodeLen(buffer, tag.primitive, fail);
        if (buffer.isError(len)) {
            return len;
        }
        let res;
        if (tag.primitive || len !== null) {
            res = buffer.skip(len);
        } else {
            res = this._skipUntilEnd(buffer, fail);
        }
        if (buffer.isError(res)) {
            return res;
        }
        if (tag.tagStr === "end") {
            break;
        }
    }
};
DERNode1.prototype._decodeList = function decodeList(buffer, _tag, decoder, options) {
    const result = [];
    while(!buffer.isEmpty()){
        const possibleEnd = this._peekTag(buffer, "end");
        if (buffer.isError(possibleEnd)) {
            return possibleEnd;
        }
        const res = decoder.decode(buffer, "der", options);
        if (buffer.isError(res) && possibleEnd) {
            break;
        }
        result.push(res);
    }
    return result;
};
DERNode1.prototype._decodeStr = function decodeStr(buffer, tag) {
    if (tag === "bitstr") {
        const unused = buffer.readUInt8();
        if (buffer.isError(unused)) {
            return unused;
        }
        return {
            unused: unused,
            data: buffer.raw()
        };
    } else if (tag === "bmpstr") {
        const raw = buffer.raw();
        if (raw.length % 2 === 1) {
            return buffer.error("Decoding of string type: bmpstr length mismatch");
        }
        let str = "";
        for(let i = 0; i < raw.length / 2; i++){
            str += String.fromCharCode(raw.readUInt16BE(i * 2));
        }
        return str;
    } else if (tag === "numstr") {
        const numstr = buffer.raw().toString("ascii");
        if (!this._isNumstr(numstr)) {
            return buffer.error("Decoding of string type: " + "numstr unsupported characters");
        }
        return numstr;
    } else if (tag === "octstr") {
        return buffer.raw();
    } else if (tag === "objDesc") {
        return buffer.raw();
    } else if (tag === "printstr") {
        const printstr = buffer.raw().toString("ascii");
        if (!this._isPrintstr(printstr)) {
            return buffer.error("Decoding of string type: " + "printstr unsupported characters");
        }
        return printstr;
    } else if (/str$/.test(tag)) {
        return buffer.raw().toString();
    } else {
        return buffer.error("Decoding of string type: " + tag + " unsupported");
    }
};
DERNode1.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
    let result;
    const identifiers = [];
    let ident = 0;
    let subident = 0;
    while(!buffer.isEmpty()){
        subident = buffer.readUInt8();
        ident <<= 7;
        ident |= subident & 0x7f;
        if ((subident & 0x80) === 0) {
            identifiers.push(ident);
            ident = 0;
        }
    }
    if (subident & 0x80) {
        identifiers.push(ident);
    }
    const first = identifiers[0] / 40 | 0;
    const second = identifiers[0] % 40;
    if (relative) {
        result = identifiers;
    } else {
        result = [
            first,
            second
        ].concat(identifiers.slice(1));
    }
    if (values) {
        let tmp = values[result.join(" ")];
        if (tmp === undefined) {
            tmp = values[result.join(".")];
        }
        if (tmp !== undefined) {
            result = tmp;
        }
    }
    return result;
};
DERNode1.prototype._decodeTime = function decodeTime(buffer, tag) {
    const str = buffer.raw().toString();
    let year;
    let mon;
    let day;
    let hour;
    let min;
    let sec;
    if (tag === "gentime") {
        year = str.slice(0, 4) | 0;
        mon = str.slice(4, 6) | 0;
        day = str.slice(6, 8) | 0;
        hour = str.slice(8, 10) | 0;
        min = str.slice(10, 12) | 0;
        sec = str.slice(12, 14) | 0;
    } else if (tag === "utctime") {
        year = str.slice(0, 2) | 0;
        mon = str.slice(2, 4) | 0;
        day = str.slice(4, 6) | 0;
        hour = str.slice(6, 8) | 0;
        min = str.slice(8, 10) | 0;
        sec = str.slice(10, 12) | 0;
        if (year < 70) {
            year = 2000 + year;
        } else {
            year = 1900 + year;
        }
    } else {
        return buffer.error("Decoding " + tag + " time is not supported yet");
    }
    return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};
DERNode1.prototype._decodeNull = function decodeNull() {
    return null;
};
DERNode1.prototype._decodeBool = function decodeBool(buffer) {
    const res = buffer.readUInt8();
    if (buffer.isError(res)) {
        return res;
    } else {
        return res !== 0;
    }
};
DERNode1.prototype._decodeInt = function decodeInt(buffer, values) {
    const raw = buffer.raw();
    let res = new BN(raw);
    if (values) {
        res = values[res.toString(10)] || res;
    }
    return res;
};
DERNode1.prototype._use = function use(entity, obj) {
    if (typeof entity === "function") {
        entity = entity(obj);
    }
    return entity._getDecoder("der").tree;
};
function derDecodeTag(buf, fail) {
    let tag1 = buf.readUInt8(fail);
    if (buf.isError(tag1)) {
        return tag1;
    }
    const cls = tagClass[tag1 >> 6];
    const primitive = (tag1 & 0x20) === 0;
    if ((tag1 & 0x1f) === 0x1f) {
        let oct = tag1;
        tag1 = 0;
        while((oct & 0x80) === 0x80){
            oct = buf.readUInt8(fail);
            if (buf.isError(oct)) {
                return oct;
            }
            tag1 <<= 7;
            tag1 |= oct & 0x7f;
        }
    } else {
        tag1 &= 0x1f;
    }
    const tagStr = tag[tag1];
    return {
        cls: cls,
        primitive: primitive,
        tag: tag1,
        tagStr: tagStr
    };
}
function derDecodeLen(buf, primitive, fail) {
    let len = buf.readUInt8(fail);
    if (buf.isError(len)) {
        return len;
    }
    if (!primitive && len === 0x80) {
        return null;
    }
    if ((len & 0x80) === 0) {
        return len;
    }
    const num = len & 0x7f;
    if (num > 4) {
        return buf.error("length octect is too long");
    }
    len = 0;
    for(let i = 0; i < num; i++){
        len <<= 8;
        const j = buf.readUInt8(fail);
        if (buf.isError(j)) {
            return j;
        }
        len |= j;
    }
    return len;
}
function PEMDecoder(entity) {
    DERDecoder.call(this, entity);
    this.enc = "pem";
}
PEMDecoder.prototype = Object.create(DERDecoder.prototype, {
    constructor: {
        value: PEMDecoder,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
PEMDecoder.prototype.decode = function decode(data, options) {
    const lines = data.toString().split(/[\r\n]+/g);
    const label = options.label.toUpperCase();
    const re = /^-----(BEGIN|END) ([^-]+)-----$/;
    let start = -1;
    let end = -1;
    for(let i = 0; i < lines.length; i++){
        const match = lines[i].match(re);
        if (match === null) {
            continue;
        }
        if (match[2] !== label) {
            continue;
        }
        if (start === -1) {
            if (match[1] !== "BEGIN") {
                break;
            }
            start = i;
        } else {
            if (match[1] !== "END") {
                break;
            }
            end = i;
            break;
        }
    }
    if (start === -1 || end === -1) {
        throw new Error("PEM section not found for: " + label);
    }
    const base64 = lines.slice(start + 1, end).join("");
    base64.replace(/[^a-z0-9+/=]+/gi, "");
    const input = Buffer.from(base64, "base64");
    return DERDecoder.prototype.decode.call(this, input, options);
};
const base = {
    DecoderBuffer,
    EncoderBuffer,
    Node,
    Reporter
};
const encoders = {
    der: DEREncoder,
    pem: PEMEncoder
};
const decoders = {
    der: DERDecoder,
    pem: PEMDecoder
};
const constants1 = {
    der: mod17
};
function define(name, body) {
    return new Entity(name, body);
}
function Entity(name, body) {
    this.name = name;
    this.body = body;
    this.decoders = {};
    this.encoders = {};
}
Entity.prototype._createNamed = function createNamed(Base) {
    const name = this.name;
    function Generated(entity) {
        this._initNamed(entity, name);
    }
    Generated.prototype = Object.create(Base.prototype, {
        constructor: {
            value: Generated,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });
    Generated.prototype._initNamed = function _initNamed(entity, name) {
        Base.call(this, entity, name);
    };
    return new Generated(this);
};
Entity.prototype._getDecoder = function _getDecoder(enc) {
    enc = enc || "der";
    if (!this.decoders.hasOwnProperty(enc)) {
        this.decoders[enc] = this._createNamed(decoders[enc]);
    }
    return this.decoders[enc];
};
Entity.prototype.decode = function decode(data, enc, options) {
    return this._getDecoder(enc).decode(data, options);
};
Entity.prototype._getEncoder = function _getEncoder(enc) {
    enc = enc || "der";
    if (!this.encoders.hasOwnProperty(enc)) {
        this.encoders[enc] = this._createNamed(encoders[enc]);
    }
    return this.encoders[enc];
};
Entity.prototype.encode = function encode(data, enc, reporter) {
    return this._getEncoder(enc).encode(data, reporter);
};
const __default5 = {
    base,
    bignum: BN,
    constants: constants1,
    decoders,
    define,
    encoders
};
const Time = define("Time", function() {
    this.choice({
        utcTime: this.utctime(),
        generalTime: this.gentime()
    });
});
const AttributeTypeValue = define("AttributeTypeValue", function() {
    this.seq().obj(this.key("type").objid(), this.key("value").any());
});
const AlgorithmIdentifier = define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
});
const SubjectPublicKeyInfo = define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier), this.key("subjectPublicKey").bitstr());
});
const RelativeDistinguishedName = define("RelativeDistinguishedName", function() {
    this.setof(AttributeTypeValue);
});
const RDNSequence = define("RDNSequence", function() {
    this.seqof(RelativeDistinguishedName);
});
const Name = define("Name", function() {
    this.choice({
        rdnSequence: this.use(RDNSequence)
    });
});
const Validity = define("Validity", function() {
    this.seq().obj(this.key("notBefore").use(Time), this.key("notAfter").use(Time));
});
const Extension = define("Extension", function() {
    this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
});
const TBSCertificate = define("TBSCertificate", function() {
    this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(AlgorithmIdentifier), this.key("issuer").use(Name), this.key("validity").use(Validity), this.key("subject").use(Name), this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(Extension).optional());
});
const X509Certificate = define("X509Certificate", function() {
    this.seq().obj(this.key("tbsCertificate").use(TBSCertificate), this.key("signatureAlgorithm").use(AlgorithmIdentifier), this.key("signatureValue").bitstr());
});
const RSAPrivateKey = __default5.define("RSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
});
const RSAPublicKey = __default5.define("RSAPublicKey", function() {
    this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
});
const PublicKey = __default5.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(AlgorithmIdentifier1), this.key("subjectPublicKey").bitstr());
});
const AlgorithmIdentifier1 = __default5.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
});
const PrivateKey = __default5.define("PrivateKeyInfo", function() {
    this.seq().obj(this.key("version").int(), this.key("algorithm").use(AlgorithmIdentifier1), this.key("subjectPrivateKey").octstr());
});
const EncryptedPrivateKey = __default5.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
});
const DSAPrivateKey = __default5.define("DSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
});
const DSAparam = __default5.define("DSAparam", function() {
    this.int();
});
const ECPrivateKey = __default5.define("ECPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(ECParameters), this.key("publicKey").optional().explicit(1).bitstr());
});
const ECParameters = __default5.define("ECParameters", function() {
    this.choice({
        namedCurve: this.objid()
    });
});
const signature = __default5.define("signature", function() {
    this.seq().obj(this.key("r").int(), this.key("s").int());
});
const findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
const startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
const fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
function __default6(okey, password) {
    const key = okey.toString();
    const match = key.match(findProc);
    let decrypted;
    if (!match) {
        const match2 = key.match(fullRegex);
        decrypted = Buffer.from(match2[2].replace(/[\r\n]/g, ""), "base64");
    } else {
        const suite = "aes" + match[1];
        const iv = Buffer.from(match[2], "hex");
        const cipherText = Buffer.from(match[3].replace(/[\r\n]/g, ""), "base64");
        const cipherKey = EVP_BytesToKey(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
        const out = [];
        const cipher = createDecipheriv(suite, cipherKey, iv);
        out.push(cipher.update(cipherText));
        out.push(cipher.final());
        decrypted = Buffer.concat(out);
    }
    const tag = key.match(startRegex)[1];
    return {
        tag: tag,
        data: decrypted
    };
}
const aesid = {
    "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
    "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
    "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
    "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
    "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
    "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
    "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
    "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
    "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
    "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
    "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
    "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
function parseKeys(buffer) {
    let password;
    if (typeof buffer === "object" && !Buffer.isBuffer(buffer)) {
        password = buffer.passphrase;
        buffer = buffer.key;
    }
    if (typeof buffer === "string") {
        buffer = Buffer.from(buffer);
    }
    const stripped = __default6(buffer, password);
    const type = stripped.tag;
    let data = stripped.data;
    let subtype, ndata;
    switch(type){
        case "CERTIFICATE":
            ndata = X509Certificate.decode(data, "der").tbsCertificate.subjectPublicKeyInfo;
        case "PUBLIC KEY":
            if (!ndata) {
                ndata = PublicKey.decode(data, "der");
            }
            subtype = ndata.algorithm.algorithm.join(".");
            switch(subtype){
                case "1.2.840.113549.1.1.1":
                    return RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");
                case "1.2.840.10045.2.1":
                    ndata.subjectPrivateKey = ndata.subjectPublicKey;
                    return {
                        type: "ec",
                        data: ndata
                    };
                case "1.2.840.10040.4.1":
                    ndata.algorithm.params.pub_key = DSAparam.decode(ndata.subjectPublicKey.data, "der");
                    return {
                        type: "dsa",
                        data: ndata.algorithm.params
                    };
                default:
                    throw new Error("unknown key id " + subtype);
            }
        case "ENCRYPTED PRIVATE KEY":
            data = EncryptedPrivateKey.decode(data, "der");
            data = decrypt2(data, password);
        case "PRIVATE KEY":
            ndata = PrivateKey.decode(data, "der");
            subtype = ndata.algorithm.algorithm.join(".");
            switch(subtype){
                case "1.2.840.113549.1.1.1":
                    return RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");
                case "1.2.840.10045.2.1":
                    return {
                        curve: ndata.algorithm.curve,
                        privateKey: ECPrivateKey.decode(ndata.subjectPrivateKey, "der").privateKey
                    };
                case "1.2.840.10040.4.1":
                    ndata.algorithm.params.priv_key = DSAparam.decode(ndata.subjectPrivateKey, "der");
                    return {
                        type: "dsa",
                        params: ndata.algorithm.params
                    };
                default:
                    throw new Error("unknown key id " + subtype);
            }
        case "RSA PUBLIC KEY":
            return RSAPublicKey.decode(data, "der");
        case "RSA PRIVATE KEY":
            return RSAPrivateKey.decode(data, "der");
        case "DSA PRIVATE KEY":
            return {
                type: "dsa",
                params: DSAPrivateKey.decode(data, "der")
            };
        case "EC PRIVATE KEY":
            data = ECPrivateKey.decode(data, "der");
            return {
                curve: data.parameters.value,
                privateKey: data.privateKey
            };
        default:
            throw new Error("unknown key type " + type);
    }
}
parseKeys.signature = signature;
function decrypt2(data, password) {
    const salt = data.algorithm.decrypt.kde.kdeparams.salt;
    const iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
    const algo = aesid[data.algorithm.decrypt.cipher.algo.join(".")];
    const iv = data.algorithm.decrypt.cipher.iv;
    const cipherText = data.subjectPrivateKey;
    const keylen = parseInt(algo.split("-")[1], 10) / 8;
    const key = pbkdf2Sync(password, salt, iters, keylen, "sha1");
    const cipher = createDecipheriv(algo, key, iv);
    const out = [];
    out.push(cipher.update(cipherText));
    out.push(cipher.final());
    return Buffer.concat(out);
}
const MAX_BYTES = 65536;
function randomBytes1(size, cb) {
    if (size > 4294967295) {
        throw new RangeError("requested too many random bytes");
    }
    const bytes = Buffer.allocUnsafe(size);
    if (size > 0) {
        if (size > 65536) {
            for(let generated = 0; generated < size; generated += MAX_BYTES){
                globalThis.crypto.getRandomValues(bytes.slice(generated, generated + 65536));
            }
        } else {
            globalThis.crypto.getRandomValues(bytes);
        }
    }
    if (typeof cb === "function") {
        return nextTick1(function() {
            cb(null, bytes);
        });
    }
    return bytes;
}
function __default7(seed, len) {
    let t = Buffer.alloc(0);
    let i = 0;
    let c;
    while(t.length < len){
        c = i2ops(i++);
        t = Buffer.concat([
            t,
            createHash("sha1").update(seed).update(c).digest()
        ]);
    }
    return t.slice(0, len);
}
function i2ops(c) {
    const out = Buffer.allocUnsafe(4);
    out.writeUInt32BE(c, 0);
    return out;
}
function xor1(a, b) {
    const len = a.length;
    let i = -1;
    while(++i < len){
        a[i] ^= b[i];
    }
    return a;
}
function withPublic(paddedMsg, key) {
    return Buffer.from(paddedMsg.toRed(BN.mont(key.modulus)).redPow(new BN(key.publicExponent)).fromRed().toArray());
}
function blind(priv) {
    const r = getr(priv);
    const blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();
    return {
        blinder: blinder,
        unblinder: r.invm(priv.modulus)
    };
}
function getr(priv) {
    const len = priv.modulus.byteLength();
    let r;
    do {
        r = new BN(randomBytes1(len));
    }while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2))
    return r;
}
function crt(msg, priv) {
    const blinds = blind(priv);
    const len = priv.modulus.byteLength();
    const blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus);
    const c1 = blinded.toRed(BN.mont(priv.prime1));
    const c2 = blinded.toRed(BN.mont(priv.prime2));
    const qinv = priv.coefficient;
    const p = priv.prime1;
    const q = priv.prime2;
    const m1 = c1.redPow(priv.exponent1).fromRed();
    const m2 = c2.redPow(priv.exponent2).fromRed();
    const h = m1.isub(m2).imul(qinv).umod(p).imul(q);
    return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer, "be", len);
}
crt.getr = getr;
function publicEncrypt(publicKey, msg, reverse) {
    let padding;
    if (publicKey.padding) {
        padding = publicKey.padding;
    } else if (reverse) {
        padding = 1;
    } else {
        padding = 4;
    }
    const key = parseKeys(publicKey);
    let paddedMsg;
    if (padding === 4) {
        paddedMsg = oaep(key, msg);
    } else if (padding === 1) {
        paddedMsg = pkcs1(key, msg, reverse);
    } else if (padding === 3) {
        paddedMsg = new BN(msg);
        if (paddedMsg.cmp(key.modulus) >= 0) {
            throw new Error("data too long for modulus");
        }
    } else {
        throw new Error("unknown padding");
    }
    if (reverse) {
        return crt(paddedMsg, key);
    } else {
        return withPublic(paddedMsg, key);
    }
}
function oaep(key, msg) {
    const k = key.modulus.byteLength();
    const mLen = msg.length;
    const iHash = createHash("sha1").update(Buffer.alloc(0)).digest();
    const hLen = iHash.length;
    const hLen2 = 2 * hLen;
    if (mLen > k - hLen2 - 2) {
        throw new Error("message too long");
    }
    const ps = Buffer.alloc(k - mLen - hLen2 - 2);
    const dblen = k - hLen - 1;
    const seed = randomBytes1(hLen);
    const maskedDb = xor1(Buffer.concat([
        iHash,
        ps,
        Buffer.alloc(1, 1),
        msg
    ], dblen), __default7(seed, dblen));
    const maskedSeed = xor1(seed, __default7(maskedDb, hLen));
    return new BN(Buffer.concat([
        Buffer.alloc(1),
        maskedSeed,
        maskedDb
    ], k));
}
function pkcs1(key, msg, reverse) {
    const mLen = msg.length;
    const k = key.modulus.byteLength();
    if (mLen > k - 11) {
        throw new Error("message too long");
    }
    let ps;
    if (reverse) {
        ps = Buffer.alloc(k - mLen - 3, 0xff);
    } else {
        ps = nonZero(k - mLen - 3);
    }
    return new BN(Buffer.concat([
        Buffer.from([
            0,
            reverse ? 1 : 2
        ]),
        ps,
        Buffer.alloc(1),
        msg
    ], k));
}
function nonZero(len) {
    const out = Buffer.allocUnsafe(len);
    let i = 0;
    let cache = randomBytes1(len * 2);
    let cur = 0;
    let num;
    while(i < len){
        if (cur === cache.length) {
            cache = randomBytes1(len * 2);
            cur = 0;
        }
        num = cache[cur++];
        if (num) {
            out[i++] = num;
        }
    }
    return out;
}
function privateDecrypt(privateKey, enc, reverse) {
    let padding;
    if (privateKey.padding) {
        padding = privateKey.padding;
    } else if (reverse) {
        padding = 1;
    } else {
        padding = 4;
    }
    const key = parseKeys(privateKey);
    const k = key.modulus.byteLength();
    if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
        throw new Error("decryption error");
    }
    let msg;
    if (reverse) {
        msg = withPublic(new BN(enc), key);
    } else {
        msg = crt(enc, key);
    }
    const zBuffer = Buffer.alloc(k - msg.length);
    msg = Buffer.concat([
        zBuffer,
        msg
    ], k);
    if (padding === 4) {
        return oaep1(key, msg);
    } else if (padding === 1) {
        return pkcs11(key, msg, reverse);
    } else if (padding === 3) {
        return msg;
    } else {
        throw new Error("unknown padding");
    }
}
function oaep1(key, msg) {
    const k = key.modulus.byteLength();
    const iHash = createHash("sha1").update(Buffer.alloc(0)).digest();
    const hLen = iHash.length;
    if (msg[0] !== 0) {
        throw new Error("decryption error");
    }
    const maskedSeed = msg.slice(1, hLen + 1);
    const maskedDb = msg.slice(hLen + 1);
    const seed = xor1(maskedSeed, __default7(maskedDb, hLen));
    const db = xor1(maskedDb, __default7(seed, k - hLen - 1));
    if (compare(iHash, db.slice(0, hLen))) {
        throw new Error("decryption error");
    }
    let i = hLen;
    while(db[i] === 0){
        i++;
    }
    if (db[i++] !== 1) {
        throw new Error("decryption error");
    }
    return db.slice(i);
}
function pkcs11(_key, msg, reverse) {
    const p1 = msg.slice(0, 2);
    let i = 2;
    let status = 0;
    while(msg[i++] !== 0){
        if (i >= msg.length) {
            status++;
            break;
        }
    }
    const ps = msg.slice(2, i - 1);
    if (p1.toString("hex") !== "0002" && !reverse || p1.toString("hex") !== "0001" && reverse) {
        status++;
    }
    if (ps.length < 8) {
        status++;
    }
    if (status) {
        throw new Error("decryption error");
    }
    return msg.slice(i);
}
function compare(a, b) {
    a = Buffer.from(a);
    b = Buffer.from(b);
    let dif = 0;
    let len = a.length;
    if (a.length !== b.length) {
        dif++;
        len = Math.min(a.length, b.length);
    }
    let i = -1;
    while(++i < len){
        dif += a[i] ^ b[i];
    }
    return dif;
}
function privateEncrypt(key, buf) {
    return publicEncrypt(key, buf, true);
}
function publicDecrypt(key, buf) {
    return privateDecrypt(key, buf, true);
}
class Cipheriv extends Iu {
    constructor(_cipher, _key, _iv, _options){
        super();
        notImplemented("crypto.Cipheriv");
    }
    final(_outputEncoding) {
        notImplemented("crypto.Cipheriv.prototype.final");
    }
    getAuthTag() {
        notImplemented("crypto.Cipheriv.prototype.getAuthTag");
    }
    setAAD(_buffer, _options) {
        notImplemented("crypto.Cipheriv.prototype.setAAD");
    }
    setAutoPadding(_autoPadding) {
        notImplemented("crypto.Cipheriv.prototype.setAutoPadding");
    }
    update(_data, _inputEncoding, _outputEncoding) {
        notImplemented("crypto.Cipheriv.prototype.update");
    }
}
class Decipheriv extends Iu {
    constructor(_cipher, _key, _iv, _options){
        super();
        notImplemented("crypto.Decipheriv");
    }
    final(_outputEncoding) {
        notImplemented("crypto.Decipheriv.prototype.final");
    }
    setAAD(_buffer, _options) {
        notImplemented("crypto.Decipheriv.prototype.setAAD");
    }
    setAuthTag(_buffer, _encoding) {
        notImplemented("crypto.Decipheriv.prototype.setAuthTag");
    }
    setAutoPadding(_autoPadding) {
        notImplemented("crypto.Decipheriv.prototype.setAutoPadding");
    }
    update(_data, _inputEncoding, _outputEncoding) {
        notImplemented("crypto.Decipheriv.prototype.update");
    }
}
function getCipherInfo(nameOrNid, options) {
    if (typeof nameOrNid !== "string" && typeof nameOrNid !== "number") {
        throw new ERR_INVALID_ARG_TYPE("nameOrNid", [
            "string",
            "number"
        ], nameOrNid);
    }
    if (typeof nameOrNid === "number") {
        validateInt32(nameOrNid, "nameOrNid");
    }
    let keyLength, ivLength;
    if (options !== undefined) {
        validateObject(options, "options");
        ({ keyLength , ivLength  } = options);
        if (keyLength !== undefined) {
            validateInt32(keyLength, "options.keyLength");
        }
        if (ivLength !== undefined) {
            validateInt32(ivLength, "options.ivLength");
        }
    }
    notImplemented("crypto.getCipherInfo");
}
const { WritableState , fromWeb , toWeb  } = mu;
class Sign extends mu {
    constructor(algorithm, _options){
        validateString(algorithm, "algorithm");
        super();
        notImplemented("crypto.Sign");
    }
    sign(_privateKey, _outputEncoding) {
        notImplemented("crypto.Sign.prototype.sign");
    }
    update(_data, _inputEncoding) {
        notImplemented("crypto.Sign.prototype.update");
    }
}
class Verify extends mu {
    constructor(algorithm, _options){
        validateString(algorithm, "algorithm");
        super();
        notImplemented("crypto.Verify");
    }
    update(_data, _inputEncoding) {
        notImplemented("crypto.Sign.prototype.update");
    }
    verify(_object, _signature, _signatureEncoding) {
        notImplemented("crypto.Sign.prototype.sign");
    }
}
function signOneShot(_algorithm, _data, _key, _callback) {
    notImplemented("crypto.sign");
}
function verifyOneShot(_algorithm, _data, _key, _signature, _callback) {
    notImplemented("crypto.verify");
}
class X509Certificate1 {
    constructor(buffer){
        if (typeof buffer === "string") {
            buffer = Buffer.from(buffer);
        }
        if (!isArrayBufferView(buffer)) {
            throw new ERR_INVALID_ARG_TYPE("buffer", [
                "string",
                "Buffer",
                "TypedArray",
                "DataView"
            ], buffer);
        }
        notImplemented("crypto.X509Certificate");
    }
    get ca() {
        notImplemented("crypto.X509Certificate.prototype.ca");
        return false;
    }
    checkEmail(_email, _options) {
        notImplemented("crypto.X509Certificate.prototype.checkEmail");
    }
    checkHost(_name, _options) {
        notImplemented("crypto.X509Certificate.prototype.checkHost");
    }
    checkIP(_ip) {
        notImplemented("crypto.X509Certificate.prototype.checkIP");
    }
    checkIssued(_otherCert) {
        notImplemented("crypto.X509Certificate.prototype.checkIssued");
    }
    checkPrivateKey(_privateKey) {
        notImplemented("crypto.X509Certificate.prototype.checkPrivateKey");
    }
    get fingerprint() {
        notImplemented("crypto.X509Certificate.prototype.fingerprint");
        return "";
    }
    get fingerprint256() {
        notImplemented("crypto.X509Certificate.prototype.fingerprint256");
        return "";
    }
    get fingerprint512() {
        notImplemented("crypto.X509Certificate.prototype.fingerprint512");
        return "";
    }
    get infoAccess() {
        notImplemented("crypto.X509Certificate.prototype.infoAccess");
        return "";
    }
    get issuer() {
        notImplemented("crypto.X509Certificate.prototype.issuer");
        return "";
    }
    get issuerCertificate() {
        notImplemented("crypto.X509Certificate.prototype.issuerCertificate");
        return {};
    }
    get keyUsage() {
        notImplemented("crypto.X509Certificate.prototype.keyUsage");
        return [];
    }
    get publicKey() {
        notImplemented("crypto.X509Certificate.prototype.publicKey");
        return {};
    }
    get raw() {
        notImplemented("crypto.X509Certificate.prototype.raw");
        return {};
    }
    get serialNumber() {
        notImplemented("crypto.X509Certificate.prototype.serialNumber");
        return "";
    }
    get subject() {
        notImplemented("crypto.X509Certificate.prototype.subject");
        return "";
    }
    get subjectAltName() {
        notImplemented("crypto.X509Certificate.prototype.subjectAltName");
        return "";
    }
    toJSON() {
        return this.toString();
    }
    toLegacyObject() {
        notImplemented("crypto.X509Certificate.prototype.toLegacyObject");
    }
    toString() {
        notImplemented("crypto.X509Certificate.prototype.toString");
    }
    get validFrom() {
        notImplemented("crypto.X509Certificate.prototype.validFrom");
        return "";
    }
    get validTo() {
        notImplemented("crypto.X509Certificate.prototype.validTo");
        return "";
    }
    verify(_publicKey) {
        notImplemented("crypto.X509Certificate.prototype.verify");
    }
}
class Certificate {
    static Certificate = Certificate;
    static exportChallenge(_spkac, _encoding) {
        notImplemented("crypto.Certificate.exportChallenge");
    }
    static exportPublicKey(_spkac, _encoding) {
        notImplemented("crypto.Certificate.exportPublicKey");
    }
    static verifySpkac(_spkac, _encoding) {
        notImplemented("crypto.Certificate.verifySpkac");
    }
}
const webcrypto = globalThis.crypto;
const fipsForced = getOptionValue("--force-fips");
function createCipheriv(cipher, key, iv, options) {
    return new Cipheriv(cipher, key, iv, options);
}
function createDecipheriv1(algorithm, key, iv, options) {
    return new Decipheriv(algorithm, key, iv, options);
}
function createDiffieHellman(sizeOrKey, keyEncoding, generator, generatorEncoding) {
    return new DiffieHellman(sizeOrKey, keyEncoding, generator, generatorEncoding);
}
function createDiffieHellmanGroup(name) {
    return new DiffieHellmanGroup(name);
}
function createECDH(curve) {
    return new ECDH(curve);
}
function createHmac(hmac, key, options) {
    return Hmac(hmac, key, options);
}
function createSign(algorithm, options) {
    return new Sign(algorithm, options);
}
function createVerify(algorithm, options) {
    return new Verify(algorithm, options);
}
function setFipsForced(val) {
    if (val) {
        return;
    }
    throw new ERR_CRYPTO_FIPS_FORCED();
}
function getFipsForced() {
    return 1;
}
Object.defineProperty(crypto1, "defaultCipherList", {
    value: getOptionValue("--tls-cipher-list")
});
const getDiffieHellman = createDiffieHellmanGroup;
const getFips = fipsForced ? getFipsForced : getFipsCrypto;
const setFips = fipsForced ? setFipsForced : setFipsCrypto;
const __default8 = {
    Certificate,
    checkPrime,
    checkPrimeSync,
    Cipheriv,
    constants: crypto1,
    createCipheriv,
    createDecipheriv: createDecipheriv1,
    createDiffieHellman,
    createDiffieHellmanGroup,
    createECDH,
    createHash,
    createHmac,
    createPrivateKey,
    createPublicKey,
    createSecretKey,
    createSign,
    createVerify,
    Decipheriv,
    DiffieHellman,
    diffieHellman,
    DiffieHellmanGroup,
    ECDH,
    generateKey,
    generateKeyPair,
    generateKeyPairSync,
    generateKeySync,
    generatePrime,
    generatePrimeSync,
    getCipherInfo,
    getCiphers,
    getCurves,
    getDiffieHellman,
    getFips,
    getHashes,
    Hash,
    hkdf,
    hkdfSync,
    Hmac,
    KeyObject,
    pbkdf2,
    pbkdf2Sync,
    privateDecrypt,
    privateEncrypt,
    publicDecrypt,
    publicEncrypt,
    randomBytes,
    randomFill,
    randomFillSync,
    randomInt,
    randomUUID,
    scrypt,
    scryptSync,
    secureHeapUsed,
    setEngine,
    setFips,
    Sign,
    sign: signOneShot,
    timingSafeEqual: timingSafeEqual1,
    Verify,
    verify: verifyOneShot,
    webcrypto,
    X509Certificate: X509Certificate1
};
var _ = Object.create;
var y = Object.defineProperty;
var v1 = Object.getOwnPropertyDescriptor;
var E = Object.getOwnPropertyNames;
var F = Object.getPrototypeOf, R1 = Object.prototype.hasOwnProperty;
var c = ((n)=>typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(n, {
        get: (t, r)=>(typeof require < "u" ? require : t)[r]
    }) : n)(function(n) {
    if (typeof require < "u") return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + n + '" is not supported');
});
var U = (n, t)=>()=>(t || n((t = {
            exports: {}
        }).exports, t), t.exports), g1 = (n, t)=>{
    for(var r in t)y(n, r, {
        get: t[r],
        enumerable: !0
    });
}, s = (n, t, r, u)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let f of E(t))!R1.call(n, f) && f !== r && y(n, f, {
        get: ()=>t[f],
        enumerable: !(u = v1(t, f)) || u.enumerable
    });
    return n;
}, d = (n, t, r)=>(s(n, t, "default"), r && s(r, t, "default")), B = (n, t, r)=>(r = n != null ? _(F(n)) : {}, s(t || !n || !n.__esModule ? y(r, "default", {
        value: n,
        enumerable: !0
    }) : r, n));
var l = U((V, p)=>{
    "use strict";
    (function() {
        var n, t = 0, r = [], u;
        for(u = 0; u < 256; u++)r[u] = (u + 256).toString(16).substr(1);
        o.BUFFER_SIZE = 4096, o.bin = m, o.clearBuffer = function() {
            n = null, t = 0;
        }, o.test = function(e) {
            return typeof e == "string" ? /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(e) : !1;
        };
        var f;
        typeof crypto < "u" ? f = crypto : typeof document < "u" && typeof window.msCrypto < "u" && (f = window.msCrypto), typeof p < "u" && typeof c == "function" ? (f = f || __default8, p.exports = o) : typeof document < "u" && (window.uuid = o), o.randomBytes = function() {
            if (f) {
                if (f.randomBytes) return f.randomBytes;
                if (f.getRandomValues) return typeof Uint8Array.prototype.slice != "function" ? function(e) {
                    var i = new Uint8Array(e);
                    return f.getRandomValues(i), Array.from(i);
                } : function(e) {
                    var i = new Uint8Array(e);
                    return f.getRandomValues(i), i;
                };
            }
            return function(e) {
                var i, w = [];
                for(i = 0; i < e; i++)w.push(Math.floor(Math.random() * 256));
                return w;
            };
        }();
        function b(e) {
            return (!n || t + e > o.BUFFER_SIZE) && (t = 0, n = o.randomBytes(o.BUFFER_SIZE)), n.slice(t, t += e);
        }
        function m() {
            var e = b(16);
            return e[6] = e[6] & 15 | 64, e[8] = e[8] & 63 | 128, e;
        }
        function o() {
            var e = m();
            return r[e[0]] + r[e[1]] + r[e[2]] + r[e[3]] + "-" + r[e[4]] + r[e[5]] + "-" + r[e[6]] + r[e[7]] + "-" + r[e[8]] + r[e[9]] + "-" + r[e[10]] + r[e[11]] + r[e[12]] + r[e[13]] + r[e[14]] + r[e[15]];
        }
    })();
});
var a = {};
g1(a, {
    default: ()=>I
});
var h = B(l());
d(a, B(l()));
var { default: x , ...A } = h, I = x !== void 0 ? x : A;
const { F_OK , R_OK , W_OK , X_OK , S_IRUSR , S_IWUSR , S_IXUSR , S_IRGRP , S_IWGRP , S_IXGRP , S_IROTH , S_IWOTH , S_IXOTH , COPYFILE_EXCL , COPYFILE_FICLONE , COPYFILE_FICLONE_FORCE , UV_FS_COPYFILE_EXCL , UV_FS_COPYFILE_FICLONE , UV_FS_COPYFILE_FICLONE_FORCE , O_RDONLY , O_WRONLY , O_RDWR , O_NOCTTY , O_TRUNC , O_APPEND , O_DIRECTORY , O_NOFOLLOW , O_SYNC , O_DSYNC , O_SYMLINK , O_NONBLOCK , O_CREAT , O_EXCL  } = fs;
const mod18 = {
    F_OK: F_OK,
    R_OK: R_OK,
    W_OK: W_OK,
    X_OK: X_OK,
    S_IRUSR: S_IRUSR,
    S_IWUSR: S_IWUSR,
    S_IXUSR: S_IXUSR,
    S_IRGRP: S_IRGRP,
    S_IWGRP: S_IWGRP,
    S_IXGRP: S_IXGRP,
    S_IROTH: S_IROTH,
    S_IWOTH: S_IWOTH,
    S_IXOTH: S_IXOTH,
    COPYFILE_EXCL: COPYFILE_EXCL,
    COPYFILE_FICLONE: COPYFILE_FICLONE,
    COPYFILE_FICLONE_FORCE: COPYFILE_FICLONE_FORCE,
    UV_FS_COPYFILE_EXCL: UV_FS_COPYFILE_EXCL,
    UV_FS_COPYFILE_FICLONE: UV_FS_COPYFILE_FICLONE,
    UV_FS_COPYFILE_FICLONE_FORCE: UV_FS_COPYFILE_FICLONE_FORCE,
    O_RDONLY: O_RDONLY,
    O_WRONLY: O_WRONLY,
    O_RDWR: O_RDWR,
    O_NOCTTY: O_NOCTTY,
    O_TRUNC: O_TRUNC,
    O_APPEND: O_APPEND,
    O_DIRECTORY: O_DIRECTORY,
    O_NOFOLLOW: O_NOFOLLOW,
    O_SYNC: O_SYNC,
    O_DSYNC: O_DSYNC,
    O_SYMLINK: O_SYMLINK,
    O_NONBLOCK: O_NONBLOCK,
    O_CREAT: O_CREAT,
    O_EXCL: O_EXCL
};
function isFileOptions(fileOptions) {
    if (!fileOptions) return false;
    return fileOptions.encoding != undefined || fileOptions.flag != undefined || fileOptions.signal != undefined || fileOptions.mode != undefined;
}
function getEncoding(optOrCallback) {
    if (!optOrCallback || typeof optOrCallback === "function") {
        return null;
    }
    const encoding = typeof optOrCallback === "string" ? optOrCallback : optOrCallback.encoding;
    if (!encoding) return null;
    return encoding;
}
function checkEncoding(encoding) {
    if (!encoding) return null;
    encoding = encoding.toLowerCase();
    if ([
        "utf8",
        "hex",
        "base64"
    ].includes(encoding)) return encoding;
    if (encoding === "utf-8") {
        return "utf8";
    }
    if (encoding === "binary") {
        return "binary";
    }
    const notImplementedEncodings = [
        "utf16le",
        "latin1",
        "ascii",
        "ucs2"
    ];
    if (notImplementedEncodings.includes(encoding)) {
        notImplemented(`"${encoding}" encoding`);
    }
    throw new Error(`The value "${encoding}" is invalid for option "encoding"`);
}
function getOpenOptions(flag) {
    if (!flag) {
        return {
            create: true,
            append: true
        };
    }
    let openOptions = {};
    if (typeof flag === "string") {
        switch(flag){
            case "a":
                {
                    openOptions = {
                        create: true,
                        append: true
                    };
                    break;
                }
            case "ax":
            case "xa":
                {
                    openOptions = {
                        createNew: true,
                        write: true,
                        append: true
                    };
                    break;
                }
            case "a+":
                {
                    openOptions = {
                        read: true,
                        create: true,
                        append: true
                    };
                    break;
                }
            case "ax+":
            case "xa+":
                {
                    openOptions = {
                        read: true,
                        createNew: true,
                        append: true
                    };
                    break;
                }
            case "r":
                {
                    openOptions = {
                        read: true
                    };
                    break;
                }
            case "r+":
                {
                    openOptions = {
                        read: true,
                        write: true
                    };
                    break;
                }
            case "w":
                {
                    openOptions = {
                        create: true,
                        write: true,
                        truncate: true
                    };
                    break;
                }
            case "wx":
            case "xw":
                {
                    openOptions = {
                        createNew: true,
                        write: true
                    };
                    break;
                }
            case "w+":
                {
                    openOptions = {
                        create: true,
                        write: true,
                        truncate: true,
                        read: true
                    };
                    break;
                }
            case "wx+":
            case "xw+":
                {
                    openOptions = {
                        createNew: true,
                        write: true,
                        read: true
                    };
                    break;
                }
            case "as":
            case "sa":
                {
                    openOptions = {
                        create: true,
                        append: true
                    };
                    break;
                }
            case "as+":
            case "sa+":
                {
                    openOptions = {
                        create: true,
                        read: true,
                        append: true
                    };
                    break;
                }
            case "rs+":
            case "sr+":
                {
                    openOptions = {
                        create: true,
                        read: true,
                        write: true
                    };
                    break;
                }
            default:
                {
                    throw new Error(`Unrecognized file system flag: ${flag}`);
                }
        }
    } else if (typeof flag === "number") {
        if ((flag & O_APPEND) === O_APPEND) {
            openOptions.append = true;
        }
        if ((flag & O_CREAT) === O_CREAT) {
            openOptions.create = true;
            openOptions.write = true;
        }
        if ((flag & O_EXCL) === O_EXCL) {
            openOptions.createNew = true;
            openOptions.read = true;
            openOptions.write = true;
        }
        if ((flag & O_TRUNC) === O_TRUNC) {
            openOptions.truncate = true;
        }
        if ((flag & O_RDONLY) === O_RDONLY) {
            openOptions.read = true;
        }
        if ((flag & O_WRONLY) === O_WRONLY) {
            openOptions.write = true;
        }
        if ((flag & O_RDWR) === O_RDWR) {
            openOptions.read = true;
            openOptions.write = true;
        }
    }
    return openOptions;
}
function maybeCallback(cb) {
    validateFunction(cb, "cb");
    return cb;
}
function makeCallback(cb) {
    validateFunction(cb, "cb");
    return (...args)=>Reflect.apply(cb, this, args);
}
var State;
(function(State) {
    State[State["PASSTHROUGH"] = 0] = "PASSTHROUGH";
    State[State["PERCENT"] = 1] = "PERCENT";
    State[State["POSITIONAL"] = 2] = "POSITIONAL";
    State[State["PRECISION"] = 3] = "PRECISION";
    State[State["WIDTH"] = 4] = "WIDTH";
})(State || (State = {}));
var WorP;
(function(WorP) {
    WorP[WorP["WIDTH"] = 0] = "WIDTH";
    WorP[WorP["PRECISION"] = 1] = "PRECISION";
})(WorP || (WorP = {}));
class Flags {
    plus;
    dash;
    sharp;
    space;
    zero;
    lessthan;
    width = -1;
    precision = -1;
}
const min = Math.min;
const UNICODE_REPLACEMENT_CHARACTER = "\ufffd";
const FLOAT_REGEXP = /(-?)(\d)\.?(\d*)e([+-])(\d+)/;
var F1;
(function(F) {
    F[F["sign"] = 1] = "sign";
    F[F["mantissa"] = 2] = "mantissa";
    F[F["fractional"] = 3] = "fractional";
    F[F["esign"] = 4] = "esign";
    F[F["exponent"] = 5] = "exponent";
})(F1 || (F1 = {}));
class Printf {
    format;
    args;
    i;
    state = State.PASSTHROUGH;
    verb = "";
    buf = "";
    argNum = 0;
    flags = new Flags();
    haveSeen;
    tmpError;
    constructor(format, ...args){
        this.format = format;
        this.args = args;
        this.haveSeen = Array.from({
            length: args.length
        });
        this.i = 0;
    }
    doPrintf() {
        for(; this.i < this.format.length; ++this.i){
            const c = this.format[this.i];
            switch(this.state){
                case State.PASSTHROUGH:
                    if (c === "%") {
                        this.state = State.PERCENT;
                    } else {
                        this.buf += c;
                    }
                    break;
                case State.PERCENT:
                    if (c === "%") {
                        this.buf += c;
                        this.state = State.PASSTHROUGH;
                    } else {
                        this.handleFormat();
                    }
                    break;
                default:
                    throw Error("Should be unreachable, certainly a bug in the lib.");
            }
        }
        let extras = false;
        let err = "%!(EXTRA";
        for(let i = 0; i !== this.haveSeen.length; ++i){
            if (!this.haveSeen[i]) {
                extras = true;
                err += ` '${Deno.inspect(this.args[i])}'`;
            }
        }
        err += ")";
        if (extras) {
            this.buf += err;
        }
        return this.buf;
    }
    handleFormat() {
        this.flags = new Flags();
        const flags = this.flags;
        for(; this.i < this.format.length; ++this.i){
            const c = this.format[this.i];
            switch(this.state){
                case State.PERCENT:
                    switch(c){
                        case "[":
                            this.handlePositional();
                            this.state = State.POSITIONAL;
                            break;
                        case "+":
                            flags.plus = true;
                            break;
                        case "<":
                            flags.lessthan = true;
                            break;
                        case "-":
                            flags.dash = true;
                            flags.zero = false;
                            break;
                        case "#":
                            flags.sharp = true;
                            break;
                        case " ":
                            flags.space = true;
                            break;
                        case "0":
                            flags.zero = !flags.dash;
                            break;
                        default:
                            if ("1" <= c && c <= "9" || c === "." || c === "*") {
                                if (c === ".") {
                                    this.flags.precision = 0;
                                    this.state = State.PRECISION;
                                    this.i++;
                                } else {
                                    this.state = State.WIDTH;
                                }
                                this.handleWidthAndPrecision(flags);
                            } else {
                                this.handleVerb();
                                return;
                            }
                    }
                    break;
                case State.POSITIONAL:
                    if (c === "*") {
                        const worp = this.flags.precision === -1 ? WorP.WIDTH : WorP.PRECISION;
                        this.handleWidthOrPrecisionRef(worp);
                        this.state = State.PERCENT;
                        break;
                    } else {
                        this.handleVerb();
                        return;
                    }
                default:
                    throw new Error(`Should not be here ${this.state}, library bug!`);
            }
        }
    }
    handleWidthOrPrecisionRef(wOrP) {
        if (this.argNum >= this.args.length) {
            return;
        }
        const arg = this.args[this.argNum];
        this.haveSeen[this.argNum] = true;
        if (typeof arg === "number") {
            switch(wOrP){
                case WorP.WIDTH:
                    this.flags.width = arg;
                    break;
                default:
                    this.flags.precision = arg;
            }
        } else {
            const tmp = wOrP === WorP.WIDTH ? "WIDTH" : "PREC";
            this.tmpError = `%!(BAD ${tmp} '${this.args[this.argNum]}')`;
        }
        this.argNum++;
    }
    handleWidthAndPrecision(flags) {
        const fmt = this.format;
        for(; this.i !== this.format.length; ++this.i){
            const c = fmt[this.i];
            switch(this.state){
                case State.WIDTH:
                    switch(c){
                        case ".":
                            this.flags.precision = 0;
                            this.state = State.PRECISION;
                            break;
                        case "*":
                            this.handleWidthOrPrecisionRef(WorP.WIDTH);
                            break;
                        default:
                            {
                                const val = parseInt(c);
                                if (isNaN(val)) {
                                    this.i--;
                                    this.state = State.PERCENT;
                                    return;
                                }
                                flags.width = flags.width == -1 ? 0 : flags.width;
                                flags.width *= 10;
                                flags.width += val;
                            }
                    }
                    break;
                case State.PRECISION:
                    {
                        if (c === "*") {
                            this.handleWidthOrPrecisionRef(WorP.PRECISION);
                            break;
                        }
                        const val = parseInt(c);
                        if (isNaN(val)) {
                            this.i--;
                            this.state = State.PERCENT;
                            return;
                        }
                        flags.precision *= 10;
                        flags.precision += val;
                        break;
                    }
                default:
                    throw new Error("can't be here. bug.");
            }
        }
    }
    handlePositional() {
        if (this.format[this.i] !== "[") {
            throw new Error("Can't happen? Bug.");
        }
        let positional = 0;
        const format = this.format;
        this.i++;
        let err = false;
        for(; this.i !== this.format.length; ++this.i){
            if (format[this.i] === "]") {
                break;
            }
            positional *= 10;
            const val = parseInt(format[this.i]);
            if (isNaN(val)) {
                this.tmpError = "%!(BAD INDEX)";
                err = true;
            }
            positional += val;
        }
        if (positional - 1 >= this.args.length) {
            this.tmpError = "%!(BAD INDEX)";
            err = true;
        }
        this.argNum = err ? this.argNum : positional - 1;
    }
    handleLessThan() {
        const arg = this.args[this.argNum];
        if ((arg || {}).constructor.name !== "Array") {
            throw new Error(`arg ${arg} is not an array. Todo better error handling`);
        }
        let str = "[ ";
        for(let i = 0; i !== arg.length; ++i){
            if (i !== 0) str += ", ";
            str += this._handleVerb(arg[i]);
        }
        return str + " ]";
    }
    handleVerb() {
        const verb = this.format[this.i];
        this.verb = verb;
        if (this.tmpError) {
            this.buf += this.tmpError;
            this.tmpError = undefined;
            if (this.argNum < this.haveSeen.length) {
                this.haveSeen[this.argNum] = true;
            }
        } else if (this.args.length <= this.argNum) {
            this.buf += `%!(MISSING '${verb}')`;
        } else {
            const arg = this.args[this.argNum];
            this.haveSeen[this.argNum] = true;
            if (this.flags.lessthan) {
                this.buf += this.handleLessThan();
            } else {
                this.buf += this._handleVerb(arg);
            }
        }
        this.argNum++;
        this.state = State.PASSTHROUGH;
    }
    _handleVerb(arg) {
        switch(this.verb){
            case "t":
                return this.pad(arg.toString());
            case "b":
                return this.fmtNumber(arg, 2);
            case "c":
                return this.fmtNumberCodePoint(arg);
            case "d":
                return this.fmtNumber(arg, 10);
            case "o":
                return this.fmtNumber(arg, 8);
            case "x":
                return this.fmtHex(arg);
            case "X":
                return this.fmtHex(arg, true);
            case "e":
                return this.fmtFloatE(arg);
            case "E":
                return this.fmtFloatE(arg, true);
            case "f":
            case "F":
                return this.fmtFloatF(arg);
            case "g":
                return this.fmtFloatG(arg);
            case "G":
                return this.fmtFloatG(arg, true);
            case "s":
                return this.fmtString(arg);
            case "T":
                return this.fmtString(typeof arg);
            case "v":
                return this.fmtV(arg);
            case "j":
                return this.fmtJ(arg);
            case "i":
                return this.fmtI(arg, false);
            case "I":
                return this.fmtI(arg, true);
            default:
                return `%!(BAD VERB '${this.verb}')`;
        }
    }
    pad(s) {
        const padding = this.flags.zero ? "0" : " ";
        if (this.flags.dash) {
            return s.padEnd(this.flags.width, padding);
        }
        return s.padStart(this.flags.width, padding);
    }
    padNum(nStr, neg) {
        let sign;
        if (neg) {
            sign = "-";
        } else if (this.flags.plus || this.flags.space) {
            sign = this.flags.plus ? "+" : " ";
        } else {
            sign = "";
        }
        const zero = this.flags.zero;
        if (!zero) {
            nStr = sign + nStr;
        }
        const pad = zero ? "0" : " ";
        const len = zero ? this.flags.width - sign.length : this.flags.width;
        if (this.flags.dash) {
            nStr = nStr.padEnd(len, pad);
        } else {
            nStr = nStr.padStart(len, pad);
        }
        if (zero) {
            nStr = sign + nStr;
        }
        return nStr;
    }
    fmtNumber(n, radix, upcase = false) {
        let num = Math.abs(n).toString(radix);
        const prec = this.flags.precision;
        if (prec !== -1) {
            this.flags.zero = false;
            num = n === 0 && prec === 0 ? "" : num;
            while(num.length < prec){
                num = "0" + num;
            }
        }
        let prefix = "";
        if (this.flags.sharp) {
            switch(radix){
                case 2:
                    prefix += "0b";
                    break;
                case 8:
                    prefix += num.startsWith("0") ? "" : "0";
                    break;
                case 16:
                    prefix += "0x";
                    break;
                default:
                    throw new Error("cannot handle base: " + radix);
            }
        }
        num = num.length === 0 ? num : prefix + num;
        if (upcase) {
            num = num.toUpperCase();
        }
        return this.padNum(num, n < 0);
    }
    fmtNumberCodePoint(n) {
        let s = "";
        try {
            s = String.fromCodePoint(n);
        } catch  {
            s = UNICODE_REPLACEMENT_CHARACTER;
        }
        return this.pad(s);
    }
    fmtFloatSpecial(n) {
        if (isNaN(n)) {
            this.flags.zero = false;
            return this.padNum("NaN", false);
        }
        if (n === Number.POSITIVE_INFINITY) {
            this.flags.zero = false;
            this.flags.plus = true;
            return this.padNum("Inf", false);
        }
        if (n === Number.NEGATIVE_INFINITY) {
            this.flags.zero = false;
            return this.padNum("Inf", true);
        }
        return "";
    }
    roundFractionToPrecision(fractional, precision) {
        let round = false;
        if (fractional.length > precision) {
            fractional = "1" + fractional;
            let tmp = parseInt(fractional.slice(0, precision + 2)) / 10;
            tmp = Math.round(tmp);
            fractional = Math.floor(tmp).toString();
            round = fractional[0] === "2";
            fractional = fractional.slice(1);
        } else {
            while(fractional.length < precision){
                fractional += "0";
            }
        }
        return [
            fractional,
            round
        ];
    }
    fmtFloatE(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        const m = n.toExponential().match(FLOAT_REGEXP);
        if (!m) {
            throw Error("can't happen, bug");
        }
        let fractional = m[F1.fractional];
        const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
        let rounding = false;
        [fractional, rounding] = this.roundFractionToPrecision(fractional, precision);
        let e = m[F1.exponent];
        let esign = m[F1.esign];
        let mantissa = parseInt(m[F1.mantissa]);
        if (rounding) {
            mantissa += 1;
            if (10 <= mantissa) {
                mantissa = 1;
                const r = parseInt(esign + e) + 1;
                e = r.toString();
                esign = r < 0 ? "-" : "+";
            }
        }
        e = e.length == 1 ? "0" + e : e;
        const val = `${mantissa}.${fractional}${upcase ? "E" : "e"}${esign}${e}`;
        return this.padNum(val, n < 0);
    }
    fmtFloatF(n) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        function expandNumber(n) {
            if (Number.isSafeInteger(n)) {
                return n.toString() + ".";
            }
            const t = n.toExponential().split("e");
            let m = t[0].replace(".", "");
            const e = parseInt(t[1]);
            if (e < 0) {
                let nStr = "0.";
                for(let i = 0; i !== Math.abs(e) - 1; ++i){
                    nStr += "0";
                }
                return nStr += m;
            } else {
                const splIdx = e + 1;
                while(m.length < splIdx){
                    m += "0";
                }
                return m.slice(0, splIdx) + "." + m.slice(splIdx);
            }
        }
        const val = expandNumber(Math.abs(n));
        const arr = val.split(".");
        let dig = arr[0];
        let fractional = arr[1];
        const precision = this.flags.precision !== -1 ? this.flags.precision : 6;
        let round = false;
        [fractional, round] = this.roundFractionToPrecision(fractional, precision);
        if (round) {
            dig = (parseInt(dig) + 1).toString();
        }
        return this.padNum(`${dig}.${fractional}`, n < 0);
    }
    fmtFloatG(n, upcase = false) {
        const special = this.fmtFloatSpecial(n);
        if (special !== "") {
            return special;
        }
        let P = this.flags.precision !== -1 ? this.flags.precision : 6;
        P = P === 0 ? 1 : P;
        const m = n.toExponential().match(FLOAT_REGEXP);
        if (!m) {
            throw Error("can't happen");
        }
        const X = parseInt(m[F1.exponent]) * (m[F1.esign] === "-" ? -1 : 1);
        let nStr = "";
        if (P > X && X >= -4) {
            this.flags.precision = P - (X + 1);
            nStr = this.fmtFloatF(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*$/, "");
            }
        } else {
            this.flags.precision = P - 1;
            nStr = this.fmtFloatE(n);
            if (!this.flags.sharp) {
                nStr = nStr.replace(/\.?0*e/, upcase ? "E" : "e");
            }
        }
        return nStr;
    }
    fmtString(s) {
        if (this.flags.precision !== -1) {
            s = s.slice(0, this.flags.precision);
        }
        return this.pad(s);
    }
    fmtHex(val, upper = false) {
        switch(typeof val){
            case "number":
                return this.fmtNumber(val, 16, upper);
            case "string":
                {
                    const sharp = this.flags.sharp && val.length !== 0;
                    let hex = sharp ? "0x" : "";
                    const prec = this.flags.precision;
                    const end = prec !== -1 ? min(prec, val.length) : val.length;
                    for(let i = 0; i !== end; ++i){
                        if (i !== 0 && this.flags.space) {
                            hex += sharp ? " 0x" : " ";
                        }
                        const c = (val.charCodeAt(i) & 0xff).toString(16);
                        hex += c.length === 1 ? `0${c}` : c;
                    }
                    if (upper) {
                        hex = hex.toUpperCase();
                    }
                    return this.pad(hex);
                }
            default:
                throw new Error("currently only number and string are implemented for hex");
        }
    }
    fmtV(val) {
        if (this.flags.sharp) {
            const options = this.flags.precision !== -1 ? {
                depth: this.flags.precision
            } : {};
            return this.pad(Deno.inspect(val, options));
        } else {
            const p = this.flags.precision;
            return p === -1 ? val.toString() : val.toString().slice(0, p);
        }
    }
    fmtJ(val) {
        return JSON.stringify(val);
    }
    fmtI(val, compact) {
        return Deno.inspect(val, {
            colors: true,
            compact,
            depth: Infinity,
            iterableLimit: Infinity
        });
    }
}
let debugImpls;
function initializeDebugEnv(debugEnv) {
    debugImpls = Object.create(null);
    if (debugEnv) {
        debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replaceAll("*", ".*").replaceAll(",", "$|^");
        const debugEnvRegex = new RegExp(`^${debugEnv}$`, "i");
        (str)=>debugEnvRegex.exec(str) !== null;
    } else {
        ()=>false;
    }
}
let debugEnv;
try {
    debugEnv = Deno.env.get("NODE_DEBUG") ?? "";
} catch (error) {
    if (error instanceof Deno.errors.PermissionDenied) {
        debugEnv = "";
    } else {
        throw error;
    }
}
initializeDebugEnv(debugEnv);
({
    ...mod3
});
var valueType;
(function(valueType) {
    valueType[valueType["noIterator"] = 0] = "noIterator";
    valueType[valueType["isArray"] = 1] = "isArray";
    valueType[valueType["isSet"] = 2] = "isSet";
    valueType[valueType["isMap"] = 3] = "isMap";
})(valueType || (valueType = {}));
const CHAR_FORWARD_SLASH1 = 47;
function assertPath1(path) {
    if (typeof path !== "string") {
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
    }
}
function isPosixPathSeparator1(code) {
    return code === 47;
}
function isPathSeparator1(code) {
    return isPosixPathSeparator1(code) || code === 92;
}
function isWindowsDeviceRoot1(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString1(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i = 0, len = path.length; i <= len; ++i){
        if (i < len) code = path.charCodeAt(i);
        else if (isPathSeparator(code)) break;
        else code = CHAR_FORWARD_SLASH1;
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format1(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (base === sep) return dir;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
const WHITESPACE_ENCODINGS1 = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace1(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS1[c] ?? c;
    });
}
function lastPathSegment1(path, isSep, start = 0) {
    let matchedNonSeparator = false;
    let end = path.length;
    for(let i = path.length - 1; i >= start; --i){
        if (isSep(path.charCodeAt(i))) {
            if (matchedNonSeparator) {
                start = i + 1;
                break;
            }
        } else if (!matchedNonSeparator) {
            matchedNonSeparator = true;
            end = i + 1;
        }
    }
    return path.slice(start, end);
}
function stripTrailingSeparators1(segment, isSep) {
    if (segment.length <= 1) {
        return segment;
    }
    let end = segment.length;
    for(let i = segment.length - 1; i > 0; i--){
        if (isSep(segment.charCodeAt(i))) {
            end = i;
        } else {
            break;
        }
    }
    return segment.slice(0, end);
}
function stripSuffix1(name, suffix) {
    if (suffix.length >= name.length) {
        return name;
    }
    const lenDiff = name.length - suffix.length;
    for(let i = suffix.length - 1; i >= 0; --i){
        if (name.charCodeAt(lenDiff + i) !== suffix.charCodeAt(i)) {
            return name;
        }
    }
    return name.slice(0, -suffix.length);
}
const sep2 = "\\";
const delimiter3 = ";";
function resolve3(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1; i--){
        let path;
        const { Deno: Deno1  } = globalThis;
        if (i >= 0) {
            path = pathSegments[i];
        } else if (!resolvedDevice) {
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno1.cwd();
        } else {
            if (typeof Deno1?.env?.get !== "function" || typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath1(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator1(code)) {
                isAbsolute = true;
                if (isPathSeparator1(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator1(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot1(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator1(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator1(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString1(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator1);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize4(path) {
    assertPath1(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            isAbsolute = true;
            if (isPathSeparator1(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator1(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString1(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator1);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator1(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute3(path) {
    assertPath1(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator1(code)) {
        return true;
    } else if (isWindowsDeviceRoot1(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator1(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join5(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i = 0; i < pathsCount; ++i){
        const path = paths[i];
        assertPath1(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert1(firstPart != null);
    if (isPathSeparator1(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator1(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator1(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator1(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize4(joined);
}
function relative3(from, to) {
    assertPath1(from);
    assertPath1(to);
    if (from === to) return "";
    const fromOrig = resolve3(from);
    const toOrig = resolve3(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 92) {
                    return toOrig.slice(toStart + i + 1);
                } else if (i === 2) {
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 92) {
                    lastCommonSep = i;
                } else if (i === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i;
    }
    if (i !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath3(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve3(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot1(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function dirname3(path) {
    assertPath1(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator1(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator1(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        return path;
    }
    for(let i = len - 1; i >= offset; --i){
        if (isPathSeparator1(path.charCodeAt(i))) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return stripTrailingSeparators1(path.slice(0, end), isPosixPathSeparator1);
}
function basename3(path, suffix = "") {
    assertPath1(path);
    if (path.length === 0) return path;
    if (typeof suffix !== "string") {
        throw new TypeError(`Suffix must be a string. Received ${JSON.stringify(suffix)}`);
    }
    let start = 0;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot1(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    const lastSegment = lastPathSegment1(path, isPathSeparator1, start);
    const strippedSegment = stripTrailingSeparators1(lastSegment, isPathSeparator1);
    return suffix ? stripSuffix1(strippedSegment, suffix) : strippedSegment;
}
function extname3(path) {
    assertPath1(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot1(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i = path.length - 1; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPathSeparator1(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format3(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format1("\\", pathObject);
}
function parse4(path) {
    assertPath1(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator1(code)) {
            rootEnd = 1;
            if (isPathSeparator1(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator1(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator1(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator1(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot1(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator1(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            ret.base = "\\";
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator1(code)) {
        ret.root = ret.dir = path;
        ret.base = "\\";
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= rootEnd; --i){
        code = path.charCodeAt(i);
        if (isPathSeparator1(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    ret.base = ret.base || "\\";
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl3(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
function toFileUrl3(path) {
    if (!isAbsolute3(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace1(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const mod19 = {
    sep: sep2,
    delimiter: delimiter3,
    resolve: resolve3,
    normalize: normalize4,
    isAbsolute: isAbsolute3,
    join: join5,
    relative: relative3,
    toNamespacedPath: toNamespacedPath3,
    dirname: dirname3,
    basename: basename3,
    extname: extname3,
    format: format3,
    parse: parse4,
    fromFileUrl: fromFileUrl3,
    toFileUrl: toFileUrl3
};
const sep3 = "/";
const delimiter4 = ":";
function resolve4(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) path = pathSegments[i];
        else {
            const { Deno: Deno1  } = globalThis;
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
        }
        assertPath1(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = isPosixPathSeparator1(path.charCodeAt(0));
    }
    resolvedPath = normalizeString1(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator1);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize5(path) {
    assertPath1(path);
    if (path.length === 0) return ".";
    const isAbsolute = isPosixPathSeparator1(path.charCodeAt(0));
    const trailingSeparator = isPosixPathSeparator1(path.charCodeAt(path.length - 1));
    path = normalizeString1(path, !isAbsolute, "/", isPosixPathSeparator1);
    if (path.length === 0 && !isAbsolute) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute) return `/${path}`;
    return path;
}
function isAbsolute4(path) {
    assertPath1(path);
    return path.length > 0 && isPosixPathSeparator1(path.charCodeAt(0));
}
function join6(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        assertPath1(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return normalize5(joined);
}
function relative4(from, to) {
    assertPath1(from);
    assertPath1(to);
    if (from === to) return "";
    from = resolve4(from);
    to = resolve4(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (!isPosixPathSeparator1(from.charCodeAt(fromStart))) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (!isPosixPathSeparator1(to.charCodeAt(toStart))) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (isPosixPathSeparator1(to.charCodeAt(toStart + i))) {
                    return to.slice(toStart + i + 1);
                } else if (i === 0) {
                    return to.slice(toStart + i);
                }
            } else if (fromLen > length) {
                if (isPosixPathSeparator1(from.charCodeAt(fromStart + i))) {
                    lastCommonSep = i;
                } else if (i === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (isPosixPathSeparator1(fromCode)) lastCommonSep = i;
    }
    let out = "";
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || isPosixPathSeparator1(from.charCodeAt(i))) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (isPosixPathSeparator1(to.charCodeAt(toStart))) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath4(path) {
    return path;
}
function dirname4(path) {
    if (path.length === 0) return ".";
    let end = -1;
    let matchedNonSeparator = false;
    for(let i = path.length - 1; i >= 1; --i){
        if (isPosixPathSeparator1(path.charCodeAt(i))) {
            if (matchedNonSeparator) {
                end = i;
                break;
            }
        } else {
            matchedNonSeparator = true;
        }
    }
    if (end === -1) {
        return isPosixPathSeparator1(path.charCodeAt(0)) ? "/" : ".";
    }
    return stripTrailingSeparators1(path.slice(0, end), isPosixPathSeparator1);
}
function basename4(path, suffix = "") {
    assertPath1(path);
    if (path.length === 0) return path;
    if (typeof suffix !== "string") {
        throw new TypeError(`Suffix must be a string. Received ${JSON.stringify(suffix)}`);
    }
    const lastSegment = lastPathSegment1(path, isPosixPathSeparator1);
    const strippedSegment = stripTrailingSeparators1(lastSegment, isPosixPathSeparator1);
    return suffix ? stripSuffix1(strippedSegment, suffix) : strippedSegment;
}
function extname4(path) {
    assertPath1(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i = path.length - 1; i >= 0; --i){
        const code = path.charCodeAt(i);
        if (isPosixPathSeparator1(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format4(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof pathObject}`);
    }
    return _format1("/", pathObject);
}
function parse5(path) {
    assertPath1(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute = isPosixPathSeparator1(path.charCodeAt(0));
    let start;
    if (isAbsolute) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPosixPathSeparator1(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
        ret.base = ret.base || "/";
    } else {
        if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) {
        ret.dir = stripTrailingSeparators1(path.slice(0, startPart - 1), isPosixPathSeparator1);
    } else if (isAbsolute) ret.dir = "/";
    return ret;
}
function fromFileUrl4(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl4(path) {
    if (!isAbsolute4(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace1(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const mod20 = {
    sep: sep3,
    delimiter: delimiter4,
    resolve: resolve4,
    normalize: normalize5,
    isAbsolute: isAbsolute4,
    join: join6,
    relative: relative4,
    toNamespacedPath: toNamespacedPath4,
    dirname: dirname4,
    basename: basename4,
    extname: extname4,
    format: format4,
    parse: parse5,
    fromFileUrl: fromFileUrl4,
    toFileUrl: toFileUrl4
};
const path2 = isWindows1 ? mod19 : mod20;
const { join: join7 , normalize: normalize6  } = path2;
const path3 = isWindows1 ? mod19 : mod20;
const { basename: basename5 , delimiter: delimiter5 , dirname: dirname5 , extname: extname5 , format: format5 , fromFileUrl: fromFileUrl5 , isAbsolute: isAbsolute5 , join: join8 , normalize: normalize7 , parse: parse6 , relative: relative5 , resolve: resolve5 , sep: sep4 , toFileUrl: toFileUrl5 , toNamespacedPath: toNamespacedPath5  } = path3;
"use strict";
const kEscape = "\x1b";
Symbol("kSubstringSearch");
function CSI(strings, ...args) {
    let ret = `${kEscape}[`;
    for(let n = 0; n < strings.length; n++){
        ret += strings[n];
        if (n < args.length) {
            ret += args[n];
        }
    }
    return ret;
}
CSI.kEscape = kEscape;
CSI.kClearToLineBeginning = CSI`1K`;
CSI.kClearToLineEnd = CSI`0K`;
CSI.kClearLine = CSI`2K`;
CSI.kClearScreenDown = CSI`0J`;
"use strict";
const { kClearLine , kClearScreenDown , kClearToLineBeginning , kClearToLineEnd  } = CSI;
function cursorTo(stream, x, y, callback) {
    if (callback !== undefined) {
        validateFunction(callback, "callback");
    }
    if (typeof y === "function") {
        callback = y;
        y = undefined;
    }
    if (Number.isNaN(x)) throw new ERR_INVALID_ARG_VALUE("x", x);
    if (Number.isNaN(y)) throw new ERR_INVALID_ARG_VALUE("y", y);
    if (stream == null || typeof x !== "number" && typeof y !== "number") {
        if (typeof callback === "function") process.nextTick(callback, null);
        return true;
    }
    if (typeof x !== "number") throw new ERR_INVALID_CURSOR_POS();
    const data = typeof y !== "number" ? CSI`${x + 1}G` : CSI`${y + 1};${x + 1}H`;
    return stream.write(data, callback);
}
function moveCursor(stream, dx, dy, callback) {
    if (callback !== undefined) {
        validateFunction(callback, "callback");
    }
    if (stream == null || !(dx || dy)) {
        if (typeof callback === "function") process.nextTick(callback, null);
        return true;
    }
    let data = "";
    if (dx < 0) {
        data += CSI`${-dx}D`;
    } else if (dx > 0) {
        data += CSI`${dx}C`;
    }
    if (dy < 0) {
        data += CSI`${-dy}A`;
    } else if (dy > 0) {
        data += CSI`${dy}B`;
    }
    return stream.write(data, callback);
}
function clearLine(stream, dir, callback) {
    if (callback !== undefined) {
        validateFunction(callback, "callback");
    }
    if (stream === null || stream === undefined) {
        if (typeof callback === "function") process.nextTick(callback, null);
        return true;
    }
    const type = dir < 0 ? kClearToLineBeginning : dir > 0 ? kClearToLineEnd : kClearLine;
    return stream.write(type, callback);
}
function clearScreenDown(stream, callback) {
    if (callback !== undefined) {
        validateFunction(callback, "callback");
    }
    if (stream === null || stream === undefined) {
        if (typeof callback === "function") process.nextTick(callback, null);
        return true;
    }
    return stream.write(kClearScreenDown, callback);
}
function createWritableStdioStream(writer, name) {
    const stream = new mu({
        write (buf, enc, cb) {
            if (!writer) {
                this.destroy(new Error(`Deno.${name} is not available in this environment`));
                return;
            }
            writer.writeSync(buf instanceof Uint8Array ? buf : Buffer.from(buf, enc));
            cb();
        },
        destroy (err, cb) {
            cb(err);
            this._undestroy();
            if (!this._writableState.emitClose) {
                nextTick(()=>this.emit("close"));
            }
        }
    });
    stream.fd = writer?.rid ?? -1;
    stream.destroySoon = stream.destroy;
    stream._isStdio = true;
    stream.once("close", ()=>writer?.close());
    Object.defineProperties(stream, {
        columns: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.().columns : undefined
        },
        rows: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid) ? Deno.consoleSize?.().rows : undefined
        },
        isTTY: {
            enumerable: true,
            configurable: true,
            get: ()=>Deno.isatty?.(writer?.rid)
        },
        getWindowSize: {
            enumerable: true,
            configurable: true,
            value: ()=>Deno.isatty?.(writer?.rid) ? Object.values(Deno.consoleSize?.()) : undefined
        }
    });
    if (Deno.isatty?.(writer?.rid)) {
        stream.cursorTo = function(x, y, callback) {
            return cursorTo(this, x, y, callback);
        };
        stream.moveCursor = function(dx, dy, callback) {
            return moveCursor(this, dx, dy, callback);
        };
        stream.clearLine = function(dir, callback) {
            return clearLine(this, dir, callback);
        };
        stream.clearScreenDown = function(callback) {
            return clearScreenDown(this, callback);
        };
    }
    return stream;
}
const stderr = stdio.stderr = createWritableStdioStream(Deno.stderr, "stderr");
const stdout = stdio.stdout = createWritableStdioStream(Deno.stdout, "stdout");
function _guessStdinType(fd) {
    if (typeof fd !== "number" || fd < 0) return "UNKNOWN";
    if (Deno.isatty?.(fd)) return "TTY";
    try {
        const fileInfo = Deno.fstatSync?.(fd);
        if (Deno.build.os !== "windows") {
            switch(fileInfo.mode & fs.S_IFMT){
                case fs.S_IFREG:
                case fs.S_IFCHR:
                    return "FILE";
                case fs.S_IFIFO:
                    return "PIPE";
                case fs.S_IFSOCK:
                    return "TCP";
                default:
                    return "UNKNOWN";
            }
        }
        if (fileInfo.isFile) {
            if (fileInfo.birthtime.valueOf() === 11644473600000) return "PIPE";
            return "FILE";
        }
    } catch (e) {
        if (Deno.build.os === "windows" && e.code === "EISDIR") return "FILE";
    }
    return "UNKNOWN";
}
const _read = function(size) {
    const p = Buffer.alloc(size || 16 * 1024);
    Deno.stdin?.read(p).then((length)=>{
        this.push(length === null ? null : p.slice(0, length));
    }, (error)=>{
        this.destroy(error);
    });
};
const stdin = stdio.stdin = (()=>{
    const fd = Deno.stdin?.rid;
    let _stdin;
    const stdinType = _guessStdinType(fd);
    switch(stdinType){
        case "FILE":
            {
                _stdin = new Au({
                    highWaterMark: 64 * 1024,
                    autoDestroy: false,
                    read: _read
                });
                break;
            }
        case "TTY":
        case "PIPE":
        case "TCP":
            {
                _stdin = new Tu({
                    readable: stdinType === "TTY" ? undefined : true,
                    writable: stdinType === "TTY" ? undefined : false,
                    readableHighWaterMark: stdinType === "TTY" ? 0 : undefined,
                    allowHalfOpen: false,
                    emitClose: false,
                    autoDestroy: true,
                    decodeStrings: false,
                    read: _read
                });
                if (stdinType !== "TTY") {
                    _stdin._writableState.ended = true;
                }
                break;
            }
        default:
            {
                _stdin = new Au({
                    read () {}
                });
                _stdin.push(null);
            }
    }
    return _stdin;
})();
stdin.on("close", ()=>Deno.stdin?.close());
stdin.fd = Deno.stdin?.rid ?? -1;
Object.defineProperty(stdin, "isTTY", {
    enumerable: true,
    configurable: true,
    get () {
        return Deno.isatty?.(Deno.stdin.rid);
    }
});
stdin._isRawMode = false;
stdin.setRawMode = (enable)=>{
    Deno.stdin?.setRaw?.(enable);
    stdin._isRawMode = enable;
    return stdin;
};
Object.defineProperty(stdin, "isRaw", {
    enumerable: true,
    configurable: true,
    get () {
        return stdin._isRawMode;
    }
});
function registerDestroyHook(_target, _asyncId, _prop) {}
var constants2;
(function(constants) {
    constants[constants["kInit"] = 0] = "kInit";
    constants[constants["kBefore"] = 1] = "kBefore";
    constants[constants["kAfter"] = 2] = "kAfter";
    constants[constants["kDestroy"] = 3] = "kDestroy";
    constants[constants["kPromiseResolve"] = 4] = "kPromiseResolve";
    constants[constants["kTotals"] = 5] = "kTotals";
    constants[constants["kCheck"] = 6] = "kCheck";
    constants[constants["kExecutionAsyncId"] = 7] = "kExecutionAsyncId";
    constants[constants["kTriggerAsyncId"] = 8] = "kTriggerAsyncId";
    constants[constants["kAsyncIdCounter"] = 9] = "kAsyncIdCounter";
    constants[constants["kDefaultTriggerAsyncId"] = 10] = "kDefaultTriggerAsyncId";
    constants[constants["kUsesExecutionAsyncResource"] = 11] = "kUsesExecutionAsyncResource";
    constants[constants["kStackLength"] = 12] = "kStackLength";
})(constants2 || (constants2 = {}));
const asyncHookFields = new Uint32Array(Object.keys(constants2).length);
function newAsyncId() {
    return ++asyncIdFields[constants2.kAsyncIdCounter];
}
var UidFields;
(function(UidFields) {
    UidFields[UidFields["kExecutionAsyncId"] = 0] = "kExecutionAsyncId";
    UidFields[UidFields["kTriggerAsyncId"] = 1] = "kTriggerAsyncId";
    UidFields[UidFields["kAsyncIdCounter"] = 2] = "kAsyncIdCounter";
    UidFields[UidFields["kDefaultTriggerAsyncId"] = 3] = "kDefaultTriggerAsyncId";
    UidFields[UidFields["kUidFieldsCount"] = 4] = "kUidFieldsCount";
})(UidFields || (UidFields = {}));
const asyncIdFields = new Float64Array(Object.keys(UidFields).length);
asyncIdFields[UidFields.kAsyncIdCounter] = 1;
asyncIdFields[UidFields.kDefaultTriggerAsyncId] = -1;
var providerType;
(function(providerType) {
    providerType[providerType["NONE"] = 0] = "NONE";
    providerType[providerType["DIRHANDLE"] = 1] = "DIRHANDLE";
    providerType[providerType["DNSCHANNEL"] = 2] = "DNSCHANNEL";
    providerType[providerType["ELDHISTOGRAM"] = 3] = "ELDHISTOGRAM";
    providerType[providerType["FILEHANDLE"] = 4] = "FILEHANDLE";
    providerType[providerType["FILEHANDLECLOSEREQ"] = 5] = "FILEHANDLECLOSEREQ";
    providerType[providerType["FIXEDSIZEBLOBCOPY"] = 6] = "FIXEDSIZEBLOBCOPY";
    providerType[providerType["FSEVENTWRAP"] = 7] = "FSEVENTWRAP";
    providerType[providerType["FSREQCALLBACK"] = 8] = "FSREQCALLBACK";
    providerType[providerType["FSREQPROMISE"] = 9] = "FSREQPROMISE";
    providerType[providerType["GETADDRINFOREQWRAP"] = 10] = "GETADDRINFOREQWRAP";
    providerType[providerType["GETNAMEINFOREQWRAP"] = 11] = "GETNAMEINFOREQWRAP";
    providerType[providerType["HEAPSNAPSHOT"] = 12] = "HEAPSNAPSHOT";
    providerType[providerType["HTTP2SESSION"] = 13] = "HTTP2SESSION";
    providerType[providerType["HTTP2STREAM"] = 14] = "HTTP2STREAM";
    providerType[providerType["HTTP2PING"] = 15] = "HTTP2PING";
    providerType[providerType["HTTP2SETTINGS"] = 16] = "HTTP2SETTINGS";
    providerType[providerType["HTTPINCOMINGMESSAGE"] = 17] = "HTTPINCOMINGMESSAGE";
    providerType[providerType["HTTPCLIENTREQUEST"] = 18] = "HTTPCLIENTREQUEST";
    providerType[providerType["JSSTREAM"] = 19] = "JSSTREAM";
    providerType[providerType["JSUDPWRAP"] = 20] = "JSUDPWRAP";
    providerType[providerType["MESSAGEPORT"] = 21] = "MESSAGEPORT";
    providerType[providerType["PIPECONNECTWRAP"] = 22] = "PIPECONNECTWRAP";
    providerType[providerType["PIPESERVERWRAP"] = 23] = "PIPESERVERWRAP";
    providerType[providerType["PIPEWRAP"] = 24] = "PIPEWRAP";
    providerType[providerType["PROCESSWRAP"] = 25] = "PROCESSWRAP";
    providerType[providerType["PROMISE"] = 26] = "PROMISE";
    providerType[providerType["QUERYWRAP"] = 27] = "QUERYWRAP";
    providerType[providerType["SHUTDOWNWRAP"] = 28] = "SHUTDOWNWRAP";
    providerType[providerType["SIGNALWRAP"] = 29] = "SIGNALWRAP";
    providerType[providerType["STATWATCHER"] = 30] = "STATWATCHER";
    providerType[providerType["STREAMPIPE"] = 31] = "STREAMPIPE";
    providerType[providerType["TCPCONNECTWRAP"] = 32] = "TCPCONNECTWRAP";
    providerType[providerType["TCPSERVERWRAP"] = 33] = "TCPSERVERWRAP";
    providerType[providerType["TCPWRAP"] = 34] = "TCPWRAP";
    providerType[providerType["TTYWRAP"] = 35] = "TTYWRAP";
    providerType[providerType["UDPSENDWRAP"] = 36] = "UDPSENDWRAP";
    providerType[providerType["UDPWRAP"] = 37] = "UDPWRAP";
    providerType[providerType["SIGINTWATCHDOG"] = 38] = "SIGINTWATCHDOG";
    providerType[providerType["WORKER"] = 39] = "WORKER";
    providerType[providerType["WORKERHEAPSNAPSHOT"] = 40] = "WORKERHEAPSNAPSHOT";
    providerType[providerType["WRITEWRAP"] = 41] = "WRITEWRAP";
    providerType[providerType["ZLIB"] = 42] = "ZLIB";
})(providerType || (providerType = {}));
const kInvalidAsyncId = -1;
class AsyncWrap {
    provider = providerType.NONE;
    asyncId = kInvalidAsyncId;
    constructor(provider){
        this.provider = provider;
        this.getAsyncId();
    }
    getAsyncId() {
        this.asyncId = this.asyncId === kInvalidAsyncId ? newAsyncId() : this.asyncId;
        return this.asyncId;
    }
    getProviderType() {
        return this.provider;
    }
}
const mod21 = {
    async_hook_fields: asyncHookFields,
    asyncIdFields: asyncIdFields,
    registerDestroyHook: registerDestroyHook,
    constants: constants2,
    newAsyncId: newAsyncId,
    UidFields: UidFields,
    providerType: providerType,
    AsyncWrap: AsyncWrap
};
const mod22 = {};
const v4Seg = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
const v4Str = `(${v4Seg}[.]){3}${v4Seg}`;
const IPv4Reg = new RegExp(`^${v4Str}$`);
const v6Seg = "(?:[0-9a-fA-F]{1,4})";
const IPv6Reg = new RegExp("^(" + `(?:${v6Seg}:){7}(?:${v6Seg}|:)|` + `(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|` + `(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|` + `(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|` + `(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|` + `(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|` + `(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|` + `(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:))` + ")(%[0-9a-zA-Z-.:]{1,})?$");
function isIPv4(ip) {
    return RegExp.prototype.test.call(IPv4Reg, ip);
}
function isIPv6(ip) {
    return RegExp.prototype.test.call(IPv6Reg, ip);
}
function isIP(ip) {
    if (isIPv4(ip)) {
        return 4;
    }
    if (isIPv6(ip)) {
        return 6;
    }
    return 0;
}
Symbol("normalizedArgs");
function ares_strerror(code) {
    const errorText = [
        "Successful completion",
        "DNS server returned answer with no data",
        "DNS server claims query was misformatted",
        "DNS server returned general failure",
        "Domain name not found",
        "DNS server does not implement requested operation",
        "DNS server refused query",
        "Misformatted DNS query",
        "Misformatted domain name",
        "Unsupported address family",
        "Misformatted DNS reply",
        "Could not contact DNS servers",
        "Timeout while contacting DNS servers",
        "End of file",
        "Error reading file",
        "Out of memory",
        "Channel is being destroyed",
        "Misformatted string",
        "Illegal flags specified",
        "Given hostname is not numeric",
        "Illegal hints flags specified",
        "c-ares library initialization not yet performed",
        "Error loading iphlpapi.dll",
        "Could not find GetNetworkParams function",
        "DNS query cancelled"
    ];
    if (code >= 0 && code < errorText.length) {
        return errorText[code];
    } else {
        return "unknown";
    }
}
class GetAddrInfoReqWrap extends AsyncWrap {
    family;
    hostname;
    callback;
    resolve;
    reject;
    oncomplete;
    constructor(){
        super(providerType.GETADDRINFOREQWRAP);
    }
}
function getaddrinfo(req, hostname, family, _hints, verbatim) {
    let addresses = [];
    const recordTypes = [];
    if (family === 0 || family === 4) {
        recordTypes.push("A");
    }
    if (family === 0 || family === 6) {
        recordTypes.push("AAAA");
    }
    (async ()=>{
        await Promise.allSettled(recordTypes.map((recordType)=>Deno.resolveDns(hostname, recordType).then((records)=>{
                records.forEach((record)=>addresses.push(record));
            })));
        const error = addresses.length ? 0 : codeMap.get("EAI_NODATA");
        if (!verbatim) {
            addresses.sort((a, b)=>{
                if (isIPv4(a)) {
                    return -1;
                } else if (isIPv4(b)) {
                    return 1;
                }
                return 0;
            });
        }
        if (isWindows1 && hostname === "localhost") {
            addresses = addresses.filter((address)=>isIPv4(address));
        }
        req.oncomplete(error, addresses);
    })();
    return 0;
}
class QueryReqWrap extends AsyncWrap {
    bindingName;
    hostname;
    ttl;
    callback;
    resolve;
    reject;
    oncomplete;
    constructor(){
        super(providerType.QUERYWRAP);
    }
}
function fqdnToHostname(fqdn) {
    return fqdn.replace(/\.$/, "");
}
function compressIPv6(address) {
    const formatted = address.replace(/\b(?:0+:){2,}/, ":");
    const finalAddress = formatted.split(":").map((octet)=>{
        if (octet.match(/^\d+\.\d+\.\d+\.\d+$/)) {
            return Number(octet.replaceAll(".", "")).toString(16);
        }
        return octet.replace(/\b0+/g, "");
    }).join(":");
    return finalAddress;
}
class ChannelWrap extends AsyncWrap {
    #servers = [];
    #timeout;
    #tries;
    constructor(timeout, tries){
        super(providerType.DNSCHANNEL);
        this.#timeout = timeout;
        this.#tries = tries;
    }
    async #query(query, recordType) {
        let code;
        let ret;
        if (this.#servers.length) {
            for (const [ipAddr, port] of this.#servers){
                const resolveOptions = {
                    nameServer: {
                        ipAddr,
                        port
                    }
                };
                ({ code , ret  } = await this.#resolve(query, recordType, resolveOptions));
                if (code === 0 || code === codeMap.get("EAI_NODATA")) {
                    break;
                }
            }
        } else {
            ({ code , ret  } = await this.#resolve(query, recordType));
        }
        return {
            code: code,
            ret: ret
        };
    }
    async #resolve(query, recordType, resolveOptions) {
        let ret = [];
        let code = 0;
        try {
            ret = await Deno.resolveDns(query, recordType, resolveOptions);
        } catch (e) {
            if (e instanceof Deno.errors.NotFound) {
                code = codeMap.get("EAI_NODATA");
            } else {
                code = codeMap.get("UNKNOWN");
            }
        }
        return {
            code,
            ret
        };
    }
    queryAny(req, name) {
        (async ()=>{
            const records = [];
            await Promise.allSettled([
                this.#query(name, "A").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "A",
                            address: record
                        }));
                }),
                this.#query(name, "AAAA").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "AAAA",
                            address: compressIPv6(record)
                        }));
                }),
                this.#query(name, "CAA").then(({ ret  })=>{
                    ret.forEach(({ critical , tag , value  })=>records.push({
                            type: "CAA",
                            [tag]: value,
                            critical: +critical && 128
                        }));
                }),
                this.#query(name, "CNAME").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "CNAME",
                            value: record
                        }));
                }),
                this.#query(name, "MX").then(({ ret  })=>{
                    ret.forEach(({ preference , exchange  })=>records.push({
                            type: "MX",
                            priority: preference,
                            exchange: fqdnToHostname(exchange)
                        }));
                }),
                this.#query(name, "NAPTR").then(({ ret  })=>{
                    ret.forEach(({ order , preference , flags , services , regexp , replacement  })=>records.push({
                            type: "NAPTR",
                            order,
                            preference,
                            flags,
                            service: services,
                            regexp,
                            replacement
                        }));
                }),
                this.#query(name, "NS").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "NS",
                            value: fqdnToHostname(record)
                        }));
                }),
                this.#query(name, "PTR").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "PTR",
                            value: fqdnToHostname(record)
                        }));
                }),
                this.#query(name, "SOA").then(({ ret  })=>{
                    ret.forEach(({ mname , rname , serial , refresh , retry , expire , minimum  })=>records.push({
                            type: "SOA",
                            nsname: fqdnToHostname(mname),
                            hostmaster: fqdnToHostname(rname),
                            serial,
                            refresh,
                            retry,
                            expire,
                            minttl: minimum
                        }));
                }),
                this.#query(name, "SRV").then(({ ret  })=>{
                    ret.forEach(({ priority , weight , port , target  })=>records.push({
                            type: "SRV",
                            priority,
                            weight,
                            port,
                            name: target
                        }));
                }),
                this.#query(name, "TXT").then(({ ret  })=>{
                    ret.forEach((record)=>records.push({
                            type: "TXT",
                            entries: record
                        }));
                })
            ]);
            const err = records.length ? 0 : codeMap.get("EAI_NODATA");
            req.oncomplete(err, records);
        })();
        return 0;
    }
    queryA(req, name) {
        this.#query(name, "A").then(({ code , ret  })=>{
            req.oncomplete(code, ret);
        });
        return 0;
    }
    queryAaaa(req, name) {
        this.#query(name, "AAAA").then(({ code , ret  })=>{
            const records = ret.map((record)=>compressIPv6(record));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryCaa(req, name) {
        this.#query(name, "CAA").then(({ code , ret  })=>{
            const records = ret.map(({ critical , tag , value  })=>({
                    [tag]: value,
                    critical: +critical && 128
                }));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryCname(req, name) {
        this.#query(name, "CNAME").then(({ code , ret  })=>{
            req.oncomplete(code, ret);
        });
        return 0;
    }
    queryMx(req, name) {
        this.#query(name, "MX").then(({ code , ret  })=>{
            const records = ret.map(({ preference , exchange  })=>({
                    priority: preference,
                    exchange: fqdnToHostname(exchange)
                }));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryNaptr(req, name) {
        this.#query(name, "NAPTR").then(({ code , ret  })=>{
            const records = ret.map(({ order , preference , flags , services , regexp , replacement  })=>({
                    flags,
                    service: services,
                    regexp,
                    replacement,
                    order,
                    preference
                }));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryNs(req, name) {
        this.#query(name, "NS").then(({ code , ret  })=>{
            const records = ret.map((record)=>fqdnToHostname(record));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryPtr(req, name) {
        this.#query(name, "PTR").then(({ code , ret  })=>{
            const records = ret.map((record)=>fqdnToHostname(record));
            req.oncomplete(code, records);
        });
        return 0;
    }
    querySoa(req, name) {
        this.#query(name, "SOA").then(({ code , ret  })=>{
            let record = {};
            if (ret.length) {
                const { mname , rname , serial , refresh , retry , expire , minimum  } = ret[0];
                record = {
                    nsname: fqdnToHostname(mname),
                    hostmaster: fqdnToHostname(rname),
                    serial,
                    refresh,
                    retry,
                    expire,
                    minttl: minimum
                };
            }
            req.oncomplete(code, record);
        });
        return 0;
    }
    querySrv(req, name) {
        this.#query(name, "SRV").then(({ code , ret  })=>{
            const records = ret.map(({ priority , weight , port , target  })=>({
                    priority,
                    weight,
                    port,
                    name: target
                }));
            req.oncomplete(code, records);
        });
        return 0;
    }
    queryTxt(req, name) {
        this.#query(name, "TXT").then(({ code , ret  })=>{
            req.oncomplete(code, ret);
        });
        return 0;
    }
    getHostByAddr(_req, _name) {
        notImplemented("cares.ChannelWrap.prototype.getHostByAddr");
    }
    getServers() {
        return this.#servers;
    }
    setServers(servers) {
        if (typeof servers === "string") {
            const tuples = [];
            for(let i = 0; i < servers.length; i += 2){
                tuples.push([
                    servers[i],
                    parseInt(servers[i + 1])
                ]);
            }
            this.#servers = tuples;
        } else {
            this.#servers = servers.map(([_ipVersion, ip, port])=>[
                    ip,
                    port
                ]);
        }
        return 0;
    }
    setLocalAddress(_addr0, _addr1) {
        notImplemented("cares.ChannelWrap.prototype.setLocalAddress");
    }
    cancel() {
        notImplemented("cares.ChannelWrap.prototype.cancel");
    }
}
const DNS_ESETSRVPENDING = -1000;
const EMSG_ESETSRVPENDING = "There are pending queries.";
function strerror(code) {
    return code === DNS_ESETSRVPENDING ? EMSG_ESETSRVPENDING : ares_strerror(code);
}
const mod23 = {
    GetAddrInfoReqWrap: GetAddrInfoReqWrap,
    getaddrinfo: getaddrinfo,
    QueryReqWrap: QueryReqWrap,
    ChannelWrap: ChannelWrap,
    strerror: strerror
};
const mod24 = {};
const mod25 = {};
const mod26 = {};
const mod27 = {};
const mod28 = {};
const mod29 = {};
const mod30 = {};
const mod31 = {};
const mod32 = {};
const mod33 = {};
const mod34 = {};
const mod35 = {};
const mod36 = {};
const mod37 = {};
const mod38 = {};
const mod39 = {};
const mod40 = {};
class HandleWrap extends AsyncWrap {
    constructor(provider){
        super(provider);
    }
    close(cb = ()=>{}) {
        this._onClose();
        queueMicrotask(cb);
    }
    ref() {
        unreachable();
    }
    unref() {
        unreachable();
    }
    _onClose() {}
}
async function writeAll(w, arr) {
    let nwritten = 0;
    while(nwritten < arr.length){
        nwritten += await w.write(arr.subarray(nwritten));
    }
}
function writeAllSync(w, arr) {
    let nwritten = 0;
    while(nwritten < arr.length){
        nwritten += w.writeSync(arr.subarray(nwritten));
    }
}
var StreamBaseStateFields;
(function(StreamBaseStateFields) {
    StreamBaseStateFields[StreamBaseStateFields["kReadBytesOrError"] = 0] = "kReadBytesOrError";
    StreamBaseStateFields[StreamBaseStateFields["kArrayBufferOffset"] = 1] = "kArrayBufferOffset";
    StreamBaseStateFields[StreamBaseStateFields["kBytesWritten"] = 2] = "kBytesWritten";
    StreamBaseStateFields[StreamBaseStateFields["kLastWriteWasAsync"] = 3] = "kLastWriteWasAsync";
    StreamBaseStateFields[StreamBaseStateFields["kNumStreamBaseStateFields"] = 4] = "kNumStreamBaseStateFields";
})(StreamBaseStateFields || (StreamBaseStateFields = {}));
const kReadBytesOrError = StreamBaseStateFields.kReadBytesOrError;
const kArrayBufferOffset = StreamBaseStateFields.kArrayBufferOffset;
const kBytesWritten = StreamBaseStateFields.kBytesWritten;
const kLastWriteWasAsync = StreamBaseStateFields.kLastWriteWasAsync;
const kNumStreamBaseStateFields = StreamBaseStateFields.kNumStreamBaseStateFields;
const streamBaseState = new Uint8Array(5);
streamBaseState[kLastWriteWasAsync] = 1;
class WriteWrap extends AsyncWrap {
    handle;
    oncomplete;
    async;
    bytes;
    buffer;
    callback;
    _chunks;
    constructor(){
        super(providerType.WRITEWRAP);
    }
}
class ShutdownWrap extends AsyncWrap {
    handle;
    oncomplete;
    callback;
    constructor(){
        super(providerType.SHUTDOWNWRAP);
    }
}
const kStreamBaseField = Symbol("kStreamBaseField");
const SUGGESTED_SIZE = 64 * 1024;
class LibuvStreamWrap extends HandleWrap {
    [kStreamBaseField];
    reading;
    #reading = false;
    destroyed = false;
    writeQueueSize = 0;
    bytesRead = 0;
    bytesWritten = 0;
    onread;
    constructor(provider, stream){
        super(provider);
        this.#attachToObject(stream);
    }
    readStart() {
        if (!this.#reading) {
            this.#reading = true;
            this.#read();
        }
        return 0;
    }
    readStop() {
        this.#reading = false;
        return 0;
    }
    shutdown(req) {
        const status = this._onClose();
        try {
            req.oncomplete(status);
        } catch  {}
        return 0;
    }
    useUserBuffer(_userBuf) {
        notImplemented("LibuvStreamWrap.prototype.useUserBuffer");
    }
    writeBuffer(req, data) {
        this.#write(req, data);
        return 0;
    }
    writev(req, chunks, allBuffers) {
        const count = allBuffers ? chunks.length : chunks.length >> 1;
        const buffers = new Array(count);
        if (!allBuffers) {
            for(let i = 0; i < count; i++){
                const chunk = chunks[i * 2];
                if (Buffer.isBuffer(chunk)) {
                    buffers[i] = chunk;
                }
                const encoding = chunks[i * 2 + 1];
                buffers[i] = Buffer.from(chunk, encoding);
            }
        } else {
            for(let i = 0; i < count; i++){
                buffers[i] = chunks[i];
            }
        }
        return this.writeBuffer(req, Buffer.concat(buffers));
    }
    writeAsciiString(req, data) {
        const buffer = new TextEncoder().encode(data);
        return this.writeBuffer(req, buffer);
    }
    writeUtf8String(req, data) {
        const buffer = new TextEncoder().encode(data);
        return this.writeBuffer(req, buffer);
    }
    writeUcs2String(_req, _data) {
        notImplemented("LibuvStreamWrap.prototype.writeUcs2String");
    }
    writeLatin1String(req, data) {
        const buffer = Buffer.from(data, "latin1");
        return this.writeBuffer(req, buffer);
    }
    _onClose() {
        let status = 0;
        this.#reading = false;
        try {
            this[kStreamBaseField]?.close();
        } catch  {
            status = codeMap.get("ENOTCONN");
        }
        return status;
    }
    #attachToObject(stream) {
        this[kStreamBaseField] = stream;
    }
    async #read() {
        let buf = new Uint8Array(SUGGESTED_SIZE);
        let nread;
        try {
            nread = await this[kStreamBaseField].read(buf);
        } catch (e) {
            if (e instanceof Deno.errors.Interrupted || e instanceof Deno.errors.BadResource) {
                nread = codeMap.get("EOF");
            } else if (e instanceof Deno.errors.ConnectionReset || e instanceof Deno.errors.ConnectionAborted) {
                nread = codeMap.get("ECONNRESET");
            } else {
                nread = codeMap.get("UNKNOWN");
            }
            buf = new Uint8Array(0);
        }
        nread ??= codeMap.get("EOF");
        streamBaseState[kReadBytesOrError] = nread;
        if (nread > 0) {
            this.bytesRead += nread;
        }
        buf = buf.slice(0, nread);
        streamBaseState[kArrayBufferOffset] = 0;
        try {
            this.onread(buf, nread);
        } catch  {}
        if (nread >= 0 && this.#reading) {
            this.#read();
        }
    }
    async #write(req, data) {
        const { byteLength  } = data;
        try {
            await writeAll(this[kStreamBaseField], data);
        } catch (e) {
            let status;
            if (e instanceof Deno.errors.BadResource || e instanceof Deno.errors.BrokenPipe) {
                status = codeMap.get("EBADF");
            } else {
                status = codeMap.get("UNKNOWN");
            }
            try {
                req.oncomplete(status);
            } catch  {}
            return;
        }
        streamBaseState[kBytesWritten] = byteLength;
        this.bytesWritten += byteLength;
        try {
            req.oncomplete(0);
        } catch  {}
        return;
    }
}
const mod41 = {
    kReadBytesOrError: kReadBytesOrError,
    kArrayBufferOffset: kArrayBufferOffset,
    kBytesWritten: kBytesWritten,
    kLastWriteWasAsync: kLastWriteWasAsync,
    kNumStreamBaseStateFields: kNumStreamBaseStateFields,
    streamBaseState: streamBaseState,
    WriteWrap: WriteWrap,
    ShutdownWrap: ShutdownWrap,
    kStreamBaseField: kStreamBaseField,
    LibuvStreamWrap: LibuvStreamWrap
};
class ConnectionWrap extends LibuvStreamWrap {
    onconnection = null;
    constructor(provider, object){
        super(provider, object);
    }
    afterConnect(req, status) {
        const isSuccessStatus = !status;
        const readable = isSuccessStatus;
        const writable = isSuccessStatus;
        try {
            req.oncomplete(status, this, req, readable, writable);
        } catch  {}
        return;
    }
}
function deferred() {
    let methods;
    let state = "pending";
    const promise = new Promise((resolve, reject)=>{
        methods = {
            async resolve (value) {
                await value;
                state = "fulfilled";
                resolve(value);
            },
            reject (reason) {
                state = "rejected";
                reject(reason);
            }
        };
    });
    Object.defineProperty(promise, "state", {
        get: ()=>state
    });
    return Object.assign(promise, methods);
}
function delay(ms, options = {}) {
    const { signal , persistent  } = options;
    if (signal?.aborted) {
        return Promise.reject(new DOMException("Delay was aborted.", "AbortError"));
    }
    return new Promise((resolve, reject)=>{
        const abort = ()=>{
            clearTimeout(i);
            reject(new DOMException("Delay was aborted.", "AbortError"));
        };
        const done = ()=>{
            signal?.removeEventListener("abort", abort);
            resolve();
        };
        const i = setTimeout(done, ms);
        signal?.addEventListener("abort", abort, {
            once: true
        });
        if (persistent === false) {
            try {
                Deno.unrefTimer(i);
            } catch (error) {
                if (!(error instanceof ReferenceError)) {
                    throw error;
                }
                console.error("`persistent` option is only available in Deno");
            }
        }
    });
}
class MuxAsyncIterator {
    #iteratorCount = 0;
    #yields = [];
    #throws = [];
    #signal = deferred();
    add(iterable) {
        ++this.#iteratorCount;
        this.#callIteratorNext(iterable[Symbol.asyncIterator]());
    }
    async #callIteratorNext(iterator) {
        try {
            const { value , done  } = await iterator.next();
            if (done) {
                --this.#iteratorCount;
            } else {
                this.#yields.push({
                    iterator,
                    value
                });
            }
        } catch (e) {
            this.#throws.push(e);
        }
        this.#signal.resolve();
    }
    async *iterate() {
        while(this.#iteratorCount > 0){
            await this.#signal;
            for(let i = 0; i < this.#yields.length; i++){
                const { iterator , value  } = this.#yields[i];
                yield value;
                this.#callIteratorNext(iterator);
            }
            if (this.#throws.length) {
                for (const e of this.#throws){
                    throw e;
                }
                this.#throws.length = 0;
            }
            this.#yields.length = 0;
            this.#signal = deferred();
        }
    }
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
}
function ceilPowOf2(n) {
    const roundPowOf2 = 1 << 31 - Math.clz32(n);
    return roundPowOf2 < n ? roundPowOf2 * 2 : roundPowOf2;
}
const INITIAL_ACCEPT_BACKOFF_DELAY = 5;
const MAX_ACCEPT_BACKOFF_DELAY = 1000;
var socketType;
(function(socketType) {
    socketType[socketType["SOCKET"] = 0] = "SOCKET";
    socketType[socketType["SERVER"] = 1] = "SERVER";
    socketType[socketType["IPC"] = 2] = "IPC";
})(socketType || (socketType = {}));
class Pipe extends ConnectionWrap {
    reading = false;
    ipc;
    #pendingInstances = 4;
    #address;
    #backlog;
    #listener;
    #connections = 0;
    #closed = false;
    #acceptBackoffDelay;
    constructor(type, conn){
        let provider;
        let ipc;
        switch(type){
            case socketType.SOCKET:
                {
                    provider = providerType.PIPEWRAP;
                    ipc = false;
                    break;
                }
            case socketType.SERVER:
                {
                    provider = providerType.PIPESERVERWRAP;
                    ipc = false;
                    break;
                }
            case socketType.IPC:
                {
                    provider = providerType.PIPEWRAP;
                    ipc = true;
                    break;
                }
            default:
                {
                    unreachable();
                }
        }
        super(provider, conn);
        this.ipc = ipc;
        if (conn && provider === providerType.PIPEWRAP) {
            const localAddr = conn.localAddr;
            this.#address = localAddr.path;
        }
    }
    open(_fd) {
        notImplemented("Pipe.prototype.open");
    }
    bind(name) {
        this.#address = name;
        return 0;
    }
    connect(req, address) {
        if (isWindows1) {
            notImplemented("Pipe.prototype.connect - Windows");
        }
        const connectOptions = {
            path: address,
            transport: "unix"
        };
        Deno.connect(connectOptions).then((conn)=>{
            const localAddr = conn.localAddr;
            this.#address = req.address = localAddr.path;
            this[kStreamBaseField] = conn;
            try {
                this.afterConnect(req, 0);
            } catch  {}
        }, (e)=>{
            let code;
            if (e instanceof Deno.errors.NotFound) {
                code = codeMap.get("ENOENT");
            } else if (e instanceof Deno.errors.PermissionDenied) {
                code = codeMap.get("EACCES");
            } else {
                code = codeMap.get("ECONNREFUSED");
            }
            try {
                this.afterConnect(req, code);
            } catch  {}
        });
        return 0;
    }
    listen(backlog) {
        if (isWindows1) {
            notImplemented("Pipe.prototype.listen - Windows");
        }
        this.#backlog = isWindows1 ? this.#pendingInstances : ceilPowOf2(backlog + 1);
        const listenOptions = {
            path: this.#address,
            transport: "unix"
        };
        let listener;
        try {
            listener = Deno.listen(listenOptions);
        } catch (e) {
            if (e instanceof Deno.errors.AddrInUse) {
                return codeMap.get("EADDRINUSE");
            } else if (e instanceof Deno.errors.AddrNotAvailable) {
                return codeMap.get("EADDRNOTAVAIL");
            } else if (e instanceof Deno.errors.PermissionDenied) {
                throw e;
            }
            return codeMap.get("UNKNOWN");
        }
        const address = listener.addr;
        this.#address = address.path;
        this.#listener = listener;
        this.#accept();
        return 0;
    }
    ref() {
        if (this.#listener) {
            this.#listener.ref();
        }
    }
    unref() {
        if (this.#listener) {
            this.#listener.unref();
        }
    }
    setPendingInstances(instances) {
        this.#pendingInstances = instances;
    }
    fchmod(mode) {
        if (mode != constants3.UV_READABLE && mode != constants3.UV_WRITABLE && mode != (constants3.UV_WRITABLE | constants3.UV_READABLE)) {
            return codeMap.get("EINVAL");
        }
        let desired_mode = 0;
        if (mode & constants3.UV_READABLE) {
            desired_mode |= fs.S_IRUSR | fs.S_IRGRP | fs.S_IROTH;
        }
        if (mode & constants3.UV_WRITABLE) {
            desired_mode |= fs.S_IWUSR | fs.S_IWGRP | fs.S_IWOTH;
        }
        try {
            Deno.chmodSync(this.#address, desired_mode);
        } catch  {
            return codeMap.get("UNKNOWN");
        }
        return 0;
    }
    async #acceptBackoff() {
        if (!this.#acceptBackoffDelay) {
            this.#acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY;
        } else {
            this.#acceptBackoffDelay *= 2;
        }
        if (this.#acceptBackoffDelay >= 1000) {
            this.#acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY;
        }
        await delay(this.#acceptBackoffDelay);
        this.#accept();
    }
    async #accept() {
        if (this.#closed) {
            return;
        }
        if (this.#connections > this.#backlog) {
            this.#acceptBackoff();
            return;
        }
        let connection;
        try {
            connection = await this.#listener.accept();
        } catch (e) {
            if (e instanceof Deno.errors.BadResource && this.#closed) {
                return;
            }
            try {
                this.onconnection(codeMap.get("UNKNOWN"), undefined);
            } catch  {}
            this.#acceptBackoff();
            return;
        }
        this.#acceptBackoffDelay = undefined;
        const connectionHandle = new Pipe(socketType.SOCKET, connection);
        this.#connections++;
        try {
            this.onconnection(0, connectionHandle);
        } catch  {}
        return this.#accept();
    }
    _onClose() {
        this.#closed = true;
        this.reading = false;
        this.#address = undefined;
        this.#backlog = undefined;
        this.#connections = 0;
        this.#acceptBackoffDelay = undefined;
        if (this.provider === providerType.PIPESERVERWRAP) {
            try {
                this.#listener.close();
            } catch  {}
        }
        return LibuvStreamWrap.prototype._onClose.call(this);
    }
}
class PipeConnectWrap extends AsyncWrap {
    oncomplete;
    address;
    constructor(){
        super(providerType.PIPECONNECTWRAP);
    }
}
var constants3;
(function(constants) {
    constants[constants["SOCKET"] = socketType.SOCKET] = "SOCKET";
    constants[constants["SERVER"] = socketType.SERVER] = "SERVER";
    constants[constants["IPC"] = socketType.IPC] = "IPC";
    constants[constants["UV_READABLE"] = 1] = "UV_READABLE";
    constants[constants["UV_WRITABLE"] = 2] = "UV_WRITABLE";
})(constants3 || (constants3 = {}));
const mod42 = {
    socketType: socketType,
    Pipe: Pipe,
    PipeConnectWrap: PipeConnectWrap,
    constants: constants3
};
const mod43 = {};
const mod44 = {};
const mod45 = {};
const mod46 = {};
const mod47 = {};
const mod48 = {};
const asyncIdSymbol = Symbol("asyncIdSymbol");
const ownerSymbol = Symbol("ownerSymbol");
const mod49 = {
    asyncIdSymbol: asyncIdSymbol,
    ownerSymbol: ownerSymbol
};
const mod50 = {};
var socketType1;
(function(socketType) {
    socketType[socketType["SOCKET"] = 0] = "SOCKET";
    socketType[socketType["SERVER"] = 1] = "SERVER";
})(socketType1 || (socketType1 = {}));
class TCPConnectWrap extends AsyncWrap {
    oncomplete;
    address;
    port;
    localAddress;
    localPort;
    constructor(){
        super(providerType.TCPCONNECTWRAP);
    }
}
var constants4;
(function(constants) {
    constants[constants["SOCKET"] = socketType1.SOCKET] = "SOCKET";
    constants[constants["SERVER"] = socketType1.SERVER] = "SERVER";
    constants[constants["UV_TCP_IPV6ONLY"] = 0] = "UV_TCP_IPV6ONLY";
})(constants4 || (constants4 = {}));
class TCP extends ConnectionWrap {
    [ownerSymbol] = null;
    reading = false;
    #address;
    #port;
    #remoteAddress;
    #remoteFamily;
    #remotePort;
    #backlog;
    #listener;
    #connections = 0;
    #closed = false;
    #acceptBackoffDelay;
    constructor(type, conn){
        let provider;
        switch(type){
            case socketType1.SOCKET:
                {
                    provider = providerType.TCPWRAP;
                    break;
                }
            case socketType1.SERVER:
                {
                    provider = providerType.TCPSERVERWRAP;
                    break;
                }
            default:
                {
                    unreachable();
                }
        }
        super(provider, conn);
        if (conn && provider === providerType.TCPWRAP) {
            const localAddr = conn.localAddr;
            this.#address = localAddr.hostname;
            this.#port = localAddr.port;
            const remoteAddr = conn.remoteAddr;
            this.#remoteAddress = remoteAddr.hostname;
            this.#remotePort = remoteAddr.port;
            this.#remoteFamily = isIP(remoteAddr.hostname);
        }
    }
    open(_fd) {
        notImplemented("TCP.prototype.open");
    }
    bind(address, port) {
        return this.#bind(address, port, 0);
    }
    bind6(address, port, flags) {
        return this.#bind(address, port, flags);
    }
    connect(req, address, port) {
        return this.#connect(req, address, port);
    }
    connect6(req, address, port) {
        return this.#connect(req, address, port);
    }
    listen(backlog) {
        this.#backlog = ceilPowOf2(backlog + 1);
        const listenOptions = {
            hostname: this.#address,
            port: this.#port,
            transport: "tcp"
        };
        let listener;
        try {
            listener = Deno.listen(listenOptions);
        } catch (e) {
            if (e instanceof Deno.errors.AddrInUse) {
                return codeMap.get("EADDRINUSE");
            } else if (e instanceof Deno.errors.AddrNotAvailable) {
                return codeMap.get("EADDRNOTAVAIL");
            } else if (e instanceof Deno.errors.PermissionDenied) {
                throw e;
            }
            return codeMap.get("UNKNOWN");
        }
        const address = listener.addr;
        this.#address = address.hostname;
        this.#port = address.port;
        this.#listener = listener;
        this.#accept();
        return 0;
    }
    ref() {
        if (this.#listener) {
            this.#listener.ref();
        }
        if (this[kStreamBaseField]) {
            this[kStreamBaseField].ref();
        }
    }
    unref() {
        if (this.#listener) {
            this.#listener.unref();
        }
        if (this[kStreamBaseField]) {
            this[kStreamBaseField].unref();
        }
    }
    getsockname(sockname) {
        if (typeof this.#address === "undefined" || typeof this.#port === "undefined") {
            return codeMap.get("EADDRNOTAVAIL");
        }
        sockname.address = this.#address;
        sockname.port = this.#port;
        sockname.family = isIP(this.#address);
        return 0;
    }
    getpeername(peername) {
        if (typeof this.#remoteAddress === "undefined" || typeof this.#remotePort === "undefined") {
            return codeMap.get("EADDRNOTAVAIL");
        }
        peername.address = this.#remoteAddress;
        peername.port = this.#remotePort;
        peername.family = this.#remoteFamily;
        return 0;
    }
    setNoDelay(_noDelay) {
        return 0;
    }
    setKeepAlive(_enable, _initialDelay) {
        return 0;
    }
    setSimultaneousAccepts(_enable) {
        notImplemented("TCP.prototype.setSimultaneousAccepts");
    }
    #bind(address, port, _flags) {
        this.#address = address;
        this.#port = port;
        return 0;
    }
    #connect(req, address, port) {
        this.#remoteAddress = address;
        this.#remotePort = port;
        this.#remoteFamily = isIP(address);
        const connectOptions = {
            hostname: address,
            port,
            transport: "tcp"
        };
        Deno.connect(connectOptions).then((conn)=>{
            const localAddr = conn.localAddr;
            this.#address = req.localAddress = localAddr.hostname;
            this.#port = req.localPort = localAddr.port;
            this[kStreamBaseField] = conn;
            try {
                this.afterConnect(req, 0);
            } catch  {}
        }, ()=>{
            try {
                this.afterConnect(req, codeMap.get("ECONNREFUSED"));
            } catch  {}
        });
        return 0;
    }
    async #acceptBackoff() {
        if (!this.#acceptBackoffDelay) {
            this.#acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY;
        } else {
            this.#acceptBackoffDelay *= 2;
        }
        if (this.#acceptBackoffDelay >= 1000) {
            this.#acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY;
        }
        await delay(this.#acceptBackoffDelay);
        this.#accept();
    }
    async #accept() {
        if (this.#closed) {
            return;
        }
        if (this.#connections > this.#backlog) {
            this.#acceptBackoff();
            return;
        }
        let connection;
        try {
            connection = await this.#listener.accept();
        } catch (e) {
            if (e instanceof Deno.errors.BadResource && this.#closed) {
                return;
            }
            try {
                this.onconnection(codeMap.get("UNKNOWN"), undefined);
            } catch  {}
            this.#acceptBackoff();
            return;
        }
        this.#acceptBackoffDelay = undefined;
        const connectionHandle = new TCP(socketType1.SOCKET, connection);
        this.#connections++;
        try {
            this.onconnection(0, connectionHandle);
        } catch  {}
        return this.#accept();
    }
    _onClose() {
        this.#closed = true;
        this.reading = false;
        this.#address = undefined;
        this.#port = undefined;
        this.#remoteAddress = undefined;
        this.#remoteFamily = undefined;
        this.#remotePort = undefined;
        this.#backlog = undefined;
        this.#connections = 0;
        this.#acceptBackoffDelay = undefined;
        if (this.provider === providerType.TCPSERVERWRAP) {
            try {
                this.#listener.close();
            } catch  {}
        }
        return LibuvStreamWrap.prototype._onClose.call(this);
    }
}
const mod51 = {
    TCPConnectWrap: TCPConnectWrap,
    constants: constants4,
    TCP: TCP
};
const mod52 = {};
const mod53 = {};
const mod54 = {};
const mod55 = {};
const DenoListenDatagram = Deno[Deno.internal]?.nodeUnstable?.listenDatagram || Deno.listenDatagram;
const AF_INET6 = 10;
const UDP_DGRAM_MAXSIZE = 64 * 1024;
class SendWrap extends AsyncWrap {
    list;
    address;
    port;
    callback;
    oncomplete;
    constructor(){
        super(providerType.UDPSENDWRAP);
    }
}
class UDP extends HandleWrap {
    [ownerSymbol] = null;
    #address;
    #family;
    #port;
    #remoteAddress;
    #remoteFamily;
    #remotePort;
    #listener;
    #receiving = false;
    #recvBufferSize = UDP_DGRAM_MAXSIZE;
    #sendBufferSize = UDP_DGRAM_MAXSIZE;
    onmessage;
    lookup;
    constructor(){
        super(providerType.UDPWRAP);
    }
    addMembership(_multicastAddress, _interfaceAddress) {
        notImplemented("udp.UDP.prototype.addMembership");
    }
    addSourceSpecificMembership(_sourceAddress, _groupAddress, _interfaceAddress) {
        notImplemented("udp.UDP.prototype.addSourceSpecificMembership");
    }
    bind(ip, port, flags) {
        return this.#doBind(ip, port, flags, 2);
    }
    bind6(ip, port, flags) {
        return this.#doBind(ip, port, flags, 10);
    }
    bufferSize(size, buffer, ctx) {
        let err;
        if (size > UDP_DGRAM_MAXSIZE) {
            err = "EINVAL";
        } else if (!this.#address) {
            err = isWindows1 ? "ENOTSOCK" : "EBADF";
        }
        if (err) {
            ctx.errno = codeMap.get(err);
            ctx.code = err;
            ctx.message = errorMap.get(ctx.errno)[1];
            ctx.syscall = buffer ? "uv_recv_buffer_size" : "uv_send_buffer_size";
            return;
        }
        if (size !== 0) {
            size = isLinux ? size * 2 : size;
            if (buffer) {
                return this.#recvBufferSize = size;
            }
            return this.#sendBufferSize = size;
        }
        return buffer ? this.#recvBufferSize : this.#sendBufferSize;
    }
    connect(ip, port) {
        return this.#doConnect(ip, port, 2);
    }
    connect6(ip, port) {
        return this.#doConnect(ip, port, 10);
    }
    disconnect() {
        this.#remoteAddress = undefined;
        this.#remotePort = undefined;
        this.#remoteFamily = undefined;
        return 0;
    }
    dropMembership(_multicastAddress, _interfaceAddress) {
        notImplemented("udp.UDP.prototype.dropMembership");
    }
    dropSourceSpecificMembership(_sourceAddress, _groupAddress, _interfaceAddress) {
        notImplemented("udp.UDP.prototype.dropSourceSpecificMembership");
    }
    getpeername(peername) {
        if (this.#remoteAddress === undefined) {
            return codeMap.get("EBADF");
        }
        peername.address = this.#remoteAddress;
        peername.port = this.#remotePort;
        peername.family = this.#remoteFamily;
        return 0;
    }
    getsockname(sockname) {
        if (this.#address === undefined) {
            return codeMap.get("EBADF");
        }
        sockname.address = this.#address;
        sockname.port = this.#port;
        sockname.family = this.#family;
        return 0;
    }
    open(_fd) {
        notImplemented("udp.UDP.prototype.open");
    }
    recvStart() {
        if (!this.#receiving) {
            this.#receiving = true;
            this.#receive();
        }
        return 0;
    }
    recvStop() {
        this.#receiving = false;
        return 0;
    }
    ref() {
        notImplemented("udp.UDP.prototype.ref");
    }
    send(req, bufs, count, ...args) {
        return this.#doSend(req, bufs, count, args, 2);
    }
    send6(req, bufs, count, ...args) {
        return this.#doSend(req, bufs, count, args, 10);
    }
    setBroadcast(_bool) {
        notImplemented("udp.UDP.prototype.setBroadcast");
    }
    setMulticastInterface(_interfaceAddress) {
        notImplemented("udp.UDP.prototype.setMulticastInterface");
    }
    setMulticastLoopback(_bool) {
        notImplemented("udp.UDP.prototype.setMulticastLoopback");
    }
    setMulticastTTL(_ttl) {
        notImplemented("udp.UDP.prototype.setMulticastTTL");
    }
    setTTL(_ttl) {
        notImplemented("udp.UDP.prototype.setTTL");
    }
    unref() {
        notImplemented("udp.UDP.prototype.unref");
    }
    #doBind(ip, port, _flags, family) {
        const listenOptions = {
            port,
            hostname: ip,
            transport: "udp"
        };
        let listener;
        try {
            listener = DenoListenDatagram(listenOptions);
        } catch (e) {
            if (e instanceof Deno.errors.AddrInUse) {
                return codeMap.get("EADDRINUSE");
            } else if (e instanceof Deno.errors.AddrNotAvailable) {
                return codeMap.get("EADDRNOTAVAIL");
            } else if (e instanceof Deno.errors.PermissionDenied) {
                throw e;
            }
            return codeMap.get("UNKNOWN");
        }
        const address = listener.addr;
        this.#address = address.hostname;
        this.#port = address.port;
        this.#family = family === AF_INET6 ? "IPv6" : "IPv4";
        this.#listener = listener;
        return 0;
    }
    #doConnect(ip, port, family) {
        this.#remoteAddress = ip;
        this.#remotePort = port;
        this.#remoteFamily = family === AF_INET6 ? "IPv6" : "IPv4";
        return 0;
    }
    #doSend(req, bufs, _count, args, _family) {
        let hasCallback;
        if (args.length === 3) {
            this.#remotePort = args[0];
            this.#remoteAddress = args[1];
            hasCallback = args[2];
        } else {
            hasCallback = args[0];
        }
        const addr = {
            hostname: this.#remoteAddress,
            port: this.#remotePort,
            transport: "udp"
        };
        const payload = new Uint8Array(Buffer.concat(bufs.map((buf)=>{
            if (typeof buf === "string") {
                return Buffer.from(buf);
            }
            return Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
        })));
        (async ()=>{
            let sent;
            let err = null;
            try {
                sent = await this.#listener.send(payload, addr);
            } catch (e) {
                if (e instanceof Deno.errors.BadResource) {
                    err = codeMap.get("EBADF");
                } else if (e instanceof Error && e.message.match(/os error (40|90|10040)/)) {
                    err = codeMap.get("EMSGSIZE");
                } else {
                    err = codeMap.get("UNKNOWN");
                }
                sent = 0;
            }
            if (hasCallback) {
                try {
                    req.oncomplete(err, sent);
                } catch  {}
            }
        })();
        return 0;
    }
    async #receive() {
        if (!this.#receiving) {
            return;
        }
        const p = new Uint8Array(this.#recvBufferSize);
        let buf;
        let remoteAddr;
        let nread;
        try {
            [buf, remoteAddr] = await this.#listener.receive(p);
            nread = buf.length;
        } catch (e) {
            if (e instanceof Deno.errors.Interrupted || e instanceof Deno.errors.BadResource) {
                nread = 0;
            } else {
                nread = codeMap.get("UNKNOWN");
            }
            buf = new Uint8Array(0);
            remoteAddr = null;
        }
        nread ??= 0;
        const rinfo = remoteAddr ? {
            address: remoteAddr.hostname,
            port: remoteAddr.port,
            family: isIP(remoteAddr.hostname) === 6 ? "IPv6" : "IPv4"
        } : undefined;
        try {
            this.onmessage(nread, this, Buffer.from(buf), rinfo);
        } catch  {}
        this.#receive();
    }
    _onClose() {
        this.#receiving = false;
        this.#address = undefined;
        this.#port = undefined;
        this.#family = undefined;
        try {
            this.#listener.close();
        } catch  {}
        this.#listener = undefined;
        return 0;
    }
}
const mod56 = {
    SendWrap: SendWrap,
    UDP: UDP
};
const mod57 = {};
const mod58 = {};
const mod59 = {};
const mod60 = {};
const modules = {
    "async_wrap": mod21,
    buffer: mod8,
    "cares_wrap": mod23,
    config: mod22,
    constants: mod6,
    contextify: mod24,
    credentials: mod25,
    crypto: mod9,
    errors: mod26,
    fs: mod27,
    "fs_dir": mod28,
    "fs_event_wrap": mod29,
    "heap_utils": mod30,
    "http_parser": mod31,
    icu: mod32,
    inspector: mod33,
    "js_stream": mod34,
    messaging: mod35,
    "module_wrap": mod36,
    "native_module": mod37,
    natives: mod38,
    options: mod39,
    os: mod40,
    performance: mod43,
    "pipe_wrap": mod42,
    "process_methods": mod44,
    report: mod45,
    serdes: mod46,
    "signal_wrap": mod47,
    "spawn_sync": mod48,
    "stream_wrap": mod41,
    "string_decoder": mod7,
    symbols: mod49,
    "task_queue": mod50,
    "tcp_wrap": mod51,
    timers: mod52,
    "tls_wrap": mod53,
    "trace_events": mod54,
    "tty_wrap": mod55,
    types: mod2,
    "udp_wrap": mod56,
    url: mod57,
    util: mod5,
    uv: mod4,
    v8: mod58,
    worker: mod59,
    zlib: mod60
};
function getBinding(name) {
    const mod = modules[name];
    if (!mod) {
        throw new Error(`No such module: ${name}`);
    }
    return mod;
}
const kInternal = Symbol("internal properties");
const replaceUnderscoresRegex = /_/g;
const leadingDashesRegex = /^--?/;
const trailingValuesRegex = /=.*$/;
function buildAllowedFlags() {
    const allowedNodeEnvironmentFlags = [
        "--track-heap-objects",
        "--no-track-heap-objects",
        "--node-snapshot",
        "--no-node-snapshot",
        "--require",
        "--max-old-space-size",
        "--trace-exit",
        "--no-trace-exit",
        "--disallow-code-generation-from-strings",
        "--experimental-json-modules",
        "--no-experimental-json-modules",
        "--interpreted-frames-native-stack",
        "--inspect-brk",
        "--no-inspect-brk",
        "--trace-tls",
        "--no-trace-tls",
        "--stack-trace-limit",
        "--experimental-repl-await",
        "--no-experimental-repl-await",
        "--preserve-symlinks",
        "--no-preserve-symlinks",
        "--report-uncaught-exception",
        "--no-report-uncaught-exception",
        "--experimental-modules",
        "--no-experimental-modules",
        "--report-signal",
        "--jitless",
        "--inspect-port",
        "--heapsnapshot-near-heap-limit",
        "--tls-keylog",
        "--force-context-aware",
        "--no-force-context-aware",
        "--napi-modules",
        "--abort-on-uncaught-exception",
        "--diagnostic-dir",
        "--verify-base-objects",
        "--no-verify-base-objects",
        "--unhandled-rejections",
        "--perf-basic-prof",
        "--trace-atomics-wait",
        "--no-trace-atomics-wait",
        "--deprecation",
        "--no-deprecation",
        "--perf-basic-prof-only-functions",
        "--perf-prof",
        "--max-http-header-size",
        "--report-on-signal",
        "--no-report-on-signal",
        "--throw-deprecation",
        "--no-throw-deprecation",
        "--warnings",
        "--no-warnings",
        "--force-fips",
        "--no-force-fips",
        "--pending-deprecation",
        "--no-pending-deprecation",
        "--input-type",
        "--tls-max-v1.3",
        "--no-tls-max-v1.3",
        "--tls-min-v1.2",
        "--no-tls-min-v1.2",
        "--inspect",
        "--no-inspect",
        "--heapsnapshot-signal",
        "--trace-warnings",
        "--no-trace-warnings",
        "--trace-event-categories",
        "--experimental-worker",
        "--tls-max-v1.2",
        "--no-tls-max-v1.2",
        "--perf-prof-unwinding-info",
        "--preserve-symlinks-main",
        "--no-preserve-symlinks-main",
        "--policy-integrity",
        "--experimental-wasm-modules",
        "--no-experimental-wasm-modules",
        "--node-memory-debug",
        "--inspect-publish-uid",
        "--tls-min-v1.3",
        "--no-tls-min-v1.3",
        "--experimental-specifier-resolution",
        "--secure-heap",
        "--tls-min-v1.0",
        "--no-tls-min-v1.0",
        "--redirect-warnings",
        "--experimental-report",
        "--trace-event-file-pattern",
        "--trace-uncaught",
        "--no-trace-uncaught",
        "--experimental-loader",
        "--http-parser",
        "--dns-result-order",
        "--trace-sigint",
        "--no-trace-sigint",
        "--secure-heap-min",
        "--enable-fips",
        "--no-enable-fips",
        "--enable-source-maps",
        "--no-enable-source-maps",
        "--insecure-http-parser",
        "--no-insecure-http-parser",
        "--use-openssl-ca",
        "--no-use-openssl-ca",
        "--tls-cipher-list",
        "--experimental-top-level-await",
        "--no-experimental-top-level-await",
        "--openssl-config",
        "--icu-data-dir",
        "--v8-pool-size",
        "--report-on-fatalerror",
        "--no-report-on-fatalerror",
        "--title",
        "--tls-min-v1.1",
        "--no-tls-min-v1.1",
        "--report-filename",
        "--trace-deprecation",
        "--no-trace-deprecation",
        "--report-compact",
        "--no-report-compact",
        "--experimental-policy",
        "--experimental-import-meta-resolve",
        "--no-experimental-import-meta-resolve",
        "--zero-fill-buffers",
        "--no-zero-fill-buffers",
        "--report-dir",
        "--use-bundled-ca",
        "--no-use-bundled-ca",
        "--experimental-vm-modules",
        "--no-experimental-vm-modules",
        "--force-async-hooks-checks",
        "--no-force-async-hooks-checks",
        "--frozen-intrinsics",
        "--no-frozen-intrinsics",
        "--huge-max-old-generation-size",
        "--disable-proto",
        "--debug-arraybuffer-allocations",
        "--no-debug-arraybuffer-allocations",
        "--conditions",
        "--experimental-wasi-unstable-preview1",
        "--no-experimental-wasi-unstable-preview1",
        "--trace-sync-io",
        "--no-trace-sync-io",
        "--use-largepages",
        "--experimental-abortcontroller",
        "--debug-port",
        "--es-module-specifier-resolution",
        "--prof-process",
        "-C",
        "--loader",
        "--report-directory",
        "-r",
        "--trace-events-enabled"
    ];
    const trimLeadingDashes = (flag)=>flag.replace(leadingDashesRegex, "");
    const nodeFlags = allowedNodeEnvironmentFlags.map(trimLeadingDashes);
    class NodeEnvironmentFlagsSet extends Set {
        constructor(array){
            super();
            this[kInternal] = {
                array
            };
        }
        add() {
            return this;
        }
        delete() {
            return false;
        }
        clear() {}
        has(key) {
            if (typeof key === "string") {
                key = key.replace(replaceUnderscoresRegex, "-");
                if (leadingDashesRegex.test(key)) {
                    key = key.replace(trailingValuesRegex, "");
                    return this[kInternal].array.includes(key);
                }
                return nodeFlags.includes(key);
            }
            return false;
        }
        entries() {
            this[kInternal].set ??= new Set(this[kInternal].array);
            return this[kInternal].set.entries();
        }
        forEach(callback, thisArg = undefined) {
            this[kInternal].array.forEach((v)=>Reflect.apply(callback, thisArg, [
                    v,
                    v,
                    this
                ]));
        }
        get size() {
            return this[kInternal].array.length;
        }
        values() {
            this[kInternal].set ??= new Set(this[kInternal].array);
            return this[kInternal].set.values();
        }
    }
    NodeEnvironmentFlagsSet.prototype.keys = NodeEnvironmentFlagsSet.prototype[Symbol.iterator] = NodeEnvironmentFlagsSet.prototype.values;
    Object.freeze(NodeEnvironmentFlagsSet.prototype.constructor);
    Object.freeze(NodeEnvironmentFlagsSet.prototype);
    return Object.freeze(new NodeEnvironmentFlagsSet(allowedNodeEnvironmentFlags));
}
const DenoCommand = Deno[Deno.internal]?.nodeUnstable?.Command || Deno.Command;
const notImplementedEvents = [
    "disconnect",
    "message",
    "multipleResolves",
    "rejectionHandled",
    "worker"
];
const argv = [
    "",
    "",
    ...Deno.args
];
Object.defineProperty(argv, "0", {
    get: Deno.execPath
});
Object.defineProperty(argv, "1", {
    get: ()=>{
        if (Deno.mainModule.startsWith("file:")) {
            return fromFileUrl5(Deno.mainModule);
        } else {
            return join8(Deno.cwd(), "$deno$node.js");
        }
    }
});
const exit = (code)=>{
    if (code || code === 0) {
        if (typeof code === "string") {
            const parsedCode = parseInt(code);
            process2.exitCode = isNaN(parsedCode) ? undefined : parsedCode;
        } else {
            process2.exitCode = code;
        }
    }
    if (!process2._exiting) {
        process2._exiting = true;
        process2.emit("exit", process2.exitCode || 0);
    }
    Deno.exit(process2.exitCode || 0);
};
function addReadOnlyProcessAlias(name, option, enumerable = true) {
    const value = getOptionValue(option);
    if (value) {
        Object.defineProperty(process2, name, {
            writable: false,
            configurable: true,
            enumerable,
            value
        });
    }
}
function createWarningObject(warning, type, code, ctor, detail) {
    assert1(typeof warning === "string");
    const warningErr = new Error(warning);
    warningErr.name = String(type || "Warning");
    if (code !== undefined) {
        warningErr.code = code;
    }
    if (detail !== undefined) {
        warningErr.detail = detail;
    }
    Error.captureStackTrace(warningErr, ctor || process2.emitWarning);
    return warningErr;
}
function doEmitWarning(warning) {
    process2.emit("warning", warning);
}
function emitWarning(warning, type, code, ctor) {
    let detail;
    if (type !== null && typeof type === "object" && !Array.isArray(type)) {
        ctor = type.ctor;
        code = type.code;
        if (typeof type.detail === "string") {
            detail = type.detail;
        }
        type = type.type || "Warning";
    } else if (typeof type === "function") {
        ctor = type;
        code = undefined;
        type = "Warning";
    }
    if (type !== undefined) {
        validateString(type, "type");
    }
    if (typeof code === "function") {
        ctor = code;
        code = undefined;
    } else if (code !== undefined) {
        validateString(code, "code");
    }
    if (typeof warning === "string") {
        warning = createWarningObject(warning, type, code, ctor, detail);
    } else if (!(warning instanceof Error)) {
        throw new ERR_INVALID_ARG_TYPE("warning", [
            "Error",
            "string"
        ], warning);
    }
    if (warning.name === "DeprecationWarning") {
        if (process2.noDeprecation) {
            return;
        }
        if (process2.throwDeprecation) {
            return process2.nextTick(()=>{
                throw warning;
            });
        }
    }
    process2.nextTick(doEmitWarning, warning);
}
function hrtime(time) {
    const milli = performance.now();
    const sec = Math.floor(milli / 1000);
    const nano = Math.floor(milli * 1_000_000 - sec * 1_000_000_000);
    if (!time) {
        return [
            sec,
            nano
        ];
    }
    const [prevSec, prevNano] = time;
    return [
        sec - prevSec,
        nano - prevNano
    ];
}
hrtime.bigint = function() {
    const [sec, nano] = hrtime();
    return BigInt(sec) * 1_000_000_000n + BigInt(nano);
};
function memoryUsage() {
    return {
        ...Deno.memoryUsage(),
        arrayBuffers: 0
    };
}
memoryUsage.rss = function() {
    return memoryUsage().rss;
};
function _kill(pid, sig) {
    let errCode;
    if (sig === 0) {
        let status;
        if (Deno.build.os === "windows") {
            status = new DenoCommand("powershell.exe", {
                args: [
                    "Get-Process",
                    "-pid",
                    pid
                ]
            }).outputSync();
        } else {
            status = new DenoCommand("kill", {
                args: [
                    "-0",
                    pid
                ]
            }).outputSync();
        }
        if (!status.success) {
            errCode = codeMap.get("ESRCH");
        }
    } else {
        const maybeSignal = Object.entries(os.signals).find(([_, numericCode])=>numericCode === sig);
        if (!maybeSignal) {
            errCode = codeMap.get("EINVAL");
        } else {
            try {
                Deno.kill(pid, maybeSignal[0]);
            } catch (e) {
                if (e instanceof TypeError) {
                    throw notImplemented(maybeSignal[0]);
                }
                throw e;
            }
        }
    }
    if (!errCode) {
        return 0;
    } else {
        return errCode;
    }
}
function kill(pid, sig = "SIGTERM") {
    if (pid != (pid | 0)) {
        throw new ERR_INVALID_ARG_TYPE("pid", "number", pid);
    }
    let err;
    if (typeof sig === "number") {
        err = process2._kill(pid, sig);
    } else {
        if (sig in os.signals) {
            err = process2._kill(pid, os.signals[sig]);
        } else {
            throw new ERR_UNKNOWN_SIGNAL(sig);
        }
    }
    if (err) {
        throw errnoException(err, "kill");
    }
    return true;
}
function uncaughtExceptionHandler(err, origin) {
    process2.emit("uncaughtExceptionMonitor", err, origin);
    process2.emit("uncaughtException", err, origin);
}
let execPath = null;
class Process extends EventEmitter {
    constructor(){
        super();
        globalThis.addEventListener("unhandledrejection", (event)=>{
            if (process2.listenerCount("unhandledRejection") === 0) {
                if (process2.listenerCount("uncaughtException") === 0) {
                    throw event.reason;
                }
                event.preventDefault();
                uncaughtExceptionHandler(event.reason, "unhandledRejection");
                return;
            }
            event.preventDefault();
            process2.emit("unhandledRejection", event.reason, event.promise);
        });
        globalThis.addEventListener("error", (event)=>{
            if (process2.listenerCount("uncaughtException") > 0) {
                event.preventDefault();
            }
            uncaughtExceptionHandler(event.error, "uncaughtException");
        });
        globalThis.addEventListener("beforeunload", (e)=>{
            super.emit("beforeExit", process2.exitCode || 0);
            processTicksAndRejections();
            if (core.eventLoopHasMoreWork()) {
                e.preventDefault();
            }
        });
        globalThis.addEventListener("unload", ()=>{
            if (!process2._exiting) {
                process2._exiting = true;
                super.emit("exit", process2.exitCode || 0);
            }
        });
    }
    arch = arch;
    argv = argv;
    chdir = chdir;
    config = {
        target_defaults: {},
        variables: {}
    };
    cwd = cwd;
    env = env;
    execArgv = [];
    exit = exit;
    _exiting = _exiting;
    exitCode = undefined;
    mainModule = undefined;
    nextTick = nextTick1;
    on(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.on("${event}")`);
            super.on(event, listener);
        } else if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else if (event === "SIGTERM" && Deno.build.os === "windows") {} else {
                Deno.addSignalListener(event, listener);
            }
        } else {
            super.on(event, listener);
        }
        return this;
    }
    off(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.off("${event}")`);
            super.off(event, listener);
        } else if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else if (event === "SIGTERM" && Deno.build.os === "windows") {} else {
                Deno.removeSignalListener(event, listener);
            }
        } else {
            super.off(event, listener);
        }
        return this;
    }
    emit(event, ...args) {
        if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else {
                Deno.kill(Deno.pid, event);
            }
        } else {
            return super.emit(event, ...args);
        }
        return true;
    }
    prependListener(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.prependListener("${event}")`);
            super.prependListener(event, listener);
        } else if (event.startsWith("SIG")) {
            if (event === "SIGBREAK" && Deno.build.os !== "windows") {} else {
                Deno.addSignalListener(event, listener);
            }
        } else {
            super.prependListener(event, listener);
        }
        return this;
    }
    pid = pid;
    platform = platform;
    addListener(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.addListener("${event}")`);
        }
        return this.on(event, listener);
    }
    removeListener(event, listener) {
        if (notImplementedEvents.includes(event)) {
            warnNotImplemented(`process.removeListener("${event}")`);
        }
        return this.off(event, listener);
    }
    hrtime = hrtime;
    _kill = _kill;
    kill = kill;
    memoryUsage = memoryUsage;
    stderr = stderr;
    stdin = stdin;
    stdout = stdout;
    version = version;
    versions = versions;
    emitWarning = emitWarning;
    binding(name) {
        return getBinding(name);
    }
    umask() {
        return 0o22;
    }
    getgid() {
        return Deno.gid();
    }
    getuid() {
        return Deno.uid();
    }
    _eval = undefined;
    get execPath() {
        if (execPath) {
            return execPath;
        }
        execPath = Deno.execPath();
        return execPath;
    }
    set execPath(path) {
        execPath = path;
    }
    #startTime = Date.now();
    uptime() {
        return (Date.now() - this.#startTime) / 1000;
    }
    #allowedFlags = buildAllowedFlags();
    get allowedNodeEnvironmentFlags() {
        return this.#allowedFlags;
    }
    features = {
        inspector: false
    };
    noDeprecation = false;
}
if (Deno.build.os === "windows") {
    delete Process.prototype.getgid;
    delete Process.prototype.getuid;
}
const process2 = new Process();
Object.defineProperty(process2, Symbol.toStringTag, {
    enumerable: false,
    writable: true,
    configurable: false,
    value: "process"
});
addReadOnlyProcessAlias("noDeprecation", "--no-deprecation");
addReadOnlyProcessAlias("throwDeprecation", "--throw-deprecation");
process2.removeListener;
process2.removeAllListeners;
const codesWarned = new Set();
function deprecate(fn, msg, code) {
    if (process2.noDeprecation === true) {
        return fn;
    }
    if (code !== undefined) {
        validateString(code, "code");
    }
    let warned = false;
    function deprecated(...args) {
        if (!warned) {
            warned = true;
            if (code !== undefined) {
                if (!codesWarned.has(code)) {
                    process2.emitWarning(msg, "DeprecationWarning", code, deprecated);
                    codesWarned.add(code);
                }
            } else {
                process2.emitWarning(msg, "DeprecationWarning", deprecated);
            }
        }
        if (new.target) {
            return Reflect.construct(fn, args, new.target);
        }
        return Reflect.apply(fn, this, args);
    }
    Object.setPrototypeOf(deprecated, fn);
    if (fn.prototype) {
        deprecated.prototype = fn.prototype;
    }
    return deprecated;
}
const CHAR_FORWARD_SLASH2 = 47;
function assertPath2(path) {
    if (typeof path !== "string") {
        throw new ERR_INVALID_ARG_TYPE("path", [
            "string"
        ], path);
    }
}
function isPosixPathSeparator2(code) {
    return code === 47;
}
function isPathSeparator2(code) {
    return isPosixPathSeparator2(code) || code === 92;
}
function isWindowsDeviceRoot2(code) {
    return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function normalizeString2(path, allowAboveRoot, separator, isPathSeparator) {
    let res = "";
    let lastSegmentLength = 0;
    let lastSlash = -1;
    let dots = 0;
    let code;
    for(let i = 0, len = path.length; i <= len; ++i){
        if (i < len) code = path.charCodeAt(i);
        else if (isPathSeparator(code)) break;
        else code = CHAR_FORWARD_SLASH2;
        if (isPathSeparator(code)) {
            if (lastSlash === i - 1 || dots === 1) {} else if (lastSlash !== i - 1 && dots === 2) {
                if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
                    if (res.length > 2) {
                        const lastSlashIndex = res.lastIndexOf(separator);
                        if (lastSlashIndex === -1) {
                            res = "";
                            lastSegmentLength = 0;
                        } else {
                            res = res.slice(0, lastSlashIndex);
                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);
                        }
                        lastSlash = i;
                        dots = 0;
                        continue;
                    } else if (res.length === 2 || res.length === 1) {
                        res = "";
                        lastSegmentLength = 0;
                        lastSlash = i;
                        dots = 0;
                        continue;
                    }
                }
                if (allowAboveRoot) {
                    if (res.length > 0) res += `${separator}..`;
                    else res = "..";
                    lastSegmentLength = 2;
                }
            } else {
                if (res.length > 0) res += separator + path.slice(lastSlash + 1, i);
                else res = path.slice(lastSlash + 1, i);
                lastSegmentLength = i - lastSlash - 1;
            }
            lastSlash = i;
            dots = 0;
        } else if (code === 46 && dots !== -1) {
            ++dots;
        } else {
            dots = -1;
        }
    }
    return res;
}
function _format2(sep, pathObject) {
    const dir = pathObject.dir || pathObject.root;
    const base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) return base;
    if (dir === pathObject.root) return dir + base;
    return dir + sep + base;
}
const WHITESPACE_ENCODINGS2 = {
    "\u0009": "%09",
    "\u000A": "%0A",
    "\u000B": "%0B",
    "\u000C": "%0C",
    "\u000D": "%0D",
    "\u0020": "%20"
};
function encodeWhitespace2(string) {
    return string.replaceAll(/[\s]/g, (c)=>{
        return WHITESPACE_ENCODINGS2[c] ?? c;
    });
}
const sep5 = "\\";
const delimiter6 = ";";
function resolve6(...pathSegments) {
    let resolvedDevice = "";
    let resolvedTail = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1; i--){
        let path;
        const { Deno: Deno1  } = globalThis;
        if (i >= 0) {
            path = pathSegments[i];
        } else if (!resolvedDevice) {
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a drive-letter-less path without a CWD.");
            }
            path = Deno1.cwd();
        } else {
            if (typeof Deno1?.env?.get !== "function" || typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
            if (path === undefined || path.slice(0, 3).toLowerCase() !== `${resolvedDevice.toLowerCase()}\\`) {
                path = `${resolvedDevice}\\`;
            }
        }
        assertPath2(path);
        const len = path.length;
        if (len === 0) continue;
        let rootEnd = 0;
        let device = "";
        let isAbsolute = false;
        const code = path.charCodeAt(0);
        if (len > 1) {
            if (isPathSeparator2(code)) {
                isAbsolute = true;
                if (isPathSeparator2(path.charCodeAt(1))) {
                    let j = 2;
                    let last = j;
                    for(; j < len; ++j){
                        if (isPathSeparator2(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        const firstPart = path.slice(last, j);
                        last = j;
                        for(; j < len; ++j){
                            if (!isPathSeparator2(path.charCodeAt(j))) break;
                        }
                        if (j < len && j !== last) {
                            last = j;
                            for(; j < len; ++j){
                                if (isPathSeparator2(path.charCodeAt(j))) break;
                            }
                            if (j === len) {
                                device = `\\\\${firstPart}\\${path.slice(last)}`;
                                rootEnd = j;
                            } else if (j !== last) {
                                device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                                rootEnd = j;
                            }
                        }
                    }
                } else {
                    rootEnd = 1;
                }
            } else if (isWindowsDeviceRoot2(code)) {
                if (path.charCodeAt(1) === 58) {
                    device = path.slice(0, 2);
                    rootEnd = 2;
                    if (len > 2) {
                        if (isPathSeparator2(path.charCodeAt(2))) {
                            isAbsolute = true;
                            rootEnd = 3;
                        }
                    }
                }
            }
        } else if (isPathSeparator2(code)) {
            rootEnd = 1;
            isAbsolute = true;
        }
        if (device.length > 0 && resolvedDevice.length > 0 && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
        }
        if (resolvedDevice.length === 0 && device.length > 0) {
            resolvedDevice = device;
        }
        if (!resolvedAbsolute) {
            resolvedTail = `${path.slice(rootEnd)}\\${resolvedTail}`;
            resolvedAbsolute = isAbsolute;
        }
        if (resolvedAbsolute && resolvedDevice.length > 0) break;
    }
    resolvedTail = normalizeString2(resolvedTail, !resolvedAbsolute, "\\", isPathSeparator2);
    return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
}
function normalize8(path) {
    assertPath2(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = 0;
    let device;
    let isAbsolute = false;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator2(code)) {
            isAbsolute = true;
            if (isPathSeparator2(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator2(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    const firstPart = path.slice(last, j);
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator2(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator2(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return `\\\\${firstPart}\\${path.slice(last)}\\`;
                        } else if (j !== last) {
                            device = `\\\\${firstPart}\\${path.slice(last, j)}`;
                            rootEnd = j;
                        }
                    }
                }
            } else {
                rootEnd = 1;
            }
        } else if (isWindowsDeviceRoot2(code)) {
            if (path.charCodeAt(1) === 58) {
                device = path.slice(0, 2);
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator2(path.charCodeAt(2))) {
                        isAbsolute = true;
                        rootEnd = 3;
                    }
                }
            }
        }
    } else if (isPathSeparator2(code)) {
        return "\\";
    }
    let tail;
    if (rootEnd < len) {
        tail = normalizeString2(path.slice(rootEnd), !isAbsolute, "\\", isPathSeparator2);
    } else {
        tail = "";
    }
    if (tail.length === 0 && !isAbsolute) tail = ".";
    if (tail.length > 0 && isPathSeparator2(path.charCodeAt(len - 1))) {
        tail += "\\";
    }
    if (device === undefined) {
        if (isAbsolute) {
            if (tail.length > 0) return `\\${tail}`;
            else return "\\";
        } else if (tail.length > 0) {
            return tail;
        } else {
            return "";
        }
    } else if (isAbsolute) {
        if (tail.length > 0) return `${device}\\${tail}`;
        else return `${device}\\`;
    } else if (tail.length > 0) {
        return device + tail;
    } else {
        return device;
    }
}
function isAbsolute6(path) {
    assertPath2(path);
    const len = path.length;
    if (len === 0) return false;
    const code = path.charCodeAt(0);
    if (isPathSeparator2(code)) {
        return true;
    } else if (isWindowsDeviceRoot2(code)) {
        if (len > 2 && path.charCodeAt(1) === 58) {
            if (isPathSeparator2(path.charCodeAt(2))) return true;
        }
    }
    return false;
}
function join9(...paths) {
    const pathsCount = paths.length;
    if (pathsCount === 0) return ".";
    let joined;
    let firstPart = null;
    for(let i = 0; i < pathsCount; ++i){
        const path = paths[i];
        assertPath2(path);
        if (path.length > 0) {
            if (joined === undefined) joined = firstPart = path;
            else joined += `\\${path}`;
        }
    }
    if (joined === undefined) return ".";
    let needsReplace = true;
    let slashCount = 0;
    assert1(firstPart != null);
    if (isPathSeparator2(firstPart.charCodeAt(0))) {
        ++slashCount;
        const firstLen = firstPart.length;
        if (firstLen > 1) {
            if (isPathSeparator2(firstPart.charCodeAt(1))) {
                ++slashCount;
                if (firstLen > 2) {
                    if (isPathSeparator2(firstPart.charCodeAt(2))) ++slashCount;
                    else {
                        needsReplace = false;
                    }
                }
            }
        }
    }
    if (needsReplace) {
        for(; slashCount < joined.length; ++slashCount){
            if (!isPathSeparator2(joined.charCodeAt(slashCount))) break;
        }
        if (slashCount >= 2) joined = `\\${joined.slice(slashCount)}`;
    }
    return normalize8(joined);
}
function relative6(from, to) {
    assertPath2(from);
    assertPath2(to);
    if (from === to) return "";
    const fromOrig = resolve6(from);
    const toOrig = resolve6(to);
    if (fromOrig === toOrig) return "";
    from = fromOrig.toLowerCase();
    to = toOrig.toLowerCase();
    if (from === to) return "";
    let fromStart = 0;
    let fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 92) break;
    }
    for(; fromEnd - 1 > fromStart; --fromEnd){
        if (from.charCodeAt(fromEnd - 1) !== 92) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 0;
    let toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 92) break;
    }
    for(; toEnd - 1 > toStart; --toEnd){
        if (to.charCodeAt(toEnd - 1) !== 92) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 92) {
                    return toOrig.slice(toStart + i + 1);
                } else if (i === 2) {
                    return toOrig.slice(toStart + i);
                }
            }
            if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 92) {
                    lastCommonSep = i;
                } else if (i === 2) {
                    lastCommonSep = 3;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 92) lastCommonSep = i;
    }
    if (i !== length && lastCommonSep === -1) {
        return toOrig;
    }
    let out = "";
    if (lastCommonSep === -1) lastCommonSep = 0;
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 92) {
            if (out.length === 0) out += "..";
            else out += "\\..";
        }
    }
    if (out.length > 0) {
        return out + toOrig.slice(toStart + lastCommonSep, toEnd);
    } else {
        toStart += lastCommonSep;
        if (toOrig.charCodeAt(toStart) === 92) ++toStart;
        return toOrig.slice(toStart, toEnd);
    }
}
function toNamespacedPath6(path) {
    if (typeof path !== "string") return path;
    if (path.length === 0) return "";
    const resolvedPath = resolve6(path);
    if (resolvedPath.length >= 3) {
        if (resolvedPath.charCodeAt(0) === 92) {
            if (resolvedPath.charCodeAt(1) === 92) {
                const code = resolvedPath.charCodeAt(2);
                if (code !== 63 && code !== 46) {
                    return `\\\\?\\UNC\\${resolvedPath.slice(2)}`;
                }
            }
        } else if (isWindowsDeviceRoot2(resolvedPath.charCodeAt(0))) {
            if (resolvedPath.charCodeAt(1) === 58 && resolvedPath.charCodeAt(2) === 92) {
                return `\\\\?\\${resolvedPath}`;
            }
        }
    }
    return path;
}
function dirname6(path) {
    assertPath2(path);
    const len = path.length;
    if (len === 0) return ".";
    let rootEnd = -1;
    let end = -1;
    let matchedSlash = true;
    let offset = 0;
    const code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator2(code)) {
            rootEnd = offset = 1;
            if (isPathSeparator2(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator2(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator2(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator2(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            return path;
                        }
                        if (j !== last) {
                            rootEnd = offset = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot2(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = offset = 2;
                if (len > 2) {
                    if (isPathSeparator2(path.charCodeAt(2))) rootEnd = offset = 3;
                }
            }
        }
    } else if (isPathSeparator2(code)) {
        return path;
    }
    for(let i = len - 1; i >= offset; --i){
        if (isPathSeparator2(path.charCodeAt(i))) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) {
        if (rootEnd === -1) return ".";
        else end = rootEnd;
    }
    return path.slice(0, end);
}
function basename6(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new ERR_INVALID_ARG_TYPE("ext", [
            "string"
        ], ext);
    }
    assertPath2(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (path.length >= 2) {
        const drive = path.charCodeAt(0);
        if (isWindowsDeviceRoot2(drive)) {
            if (path.charCodeAt(1) === 58) start = 2;
        }
    }
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= start; --i){
            const code = path.charCodeAt(i);
            if (isPathSeparator2(code)) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= start; --i){
            if (isPathSeparator2(path.charCodeAt(i))) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname6(path) {
    assertPath2(path);
    let start = 0;
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    if (path.length >= 2 && path.charCodeAt(1) === 58 && isWindowsDeviceRoot2(path.charCodeAt(0))) {
        start = startPart = 2;
    }
    for(let i = path.length - 1; i >= start; --i){
        const code = path.charCodeAt(i);
        if (isPathSeparator2(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format6(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new ERR_INVALID_ARG_TYPE("pathObject", [
            "Object"
        ], pathObject);
    }
    return _format2("\\", pathObject);
}
function parse7(path) {
    assertPath2(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    const len = path.length;
    if (len === 0) return ret;
    let rootEnd = 0;
    let code = path.charCodeAt(0);
    if (len > 1) {
        if (isPathSeparator2(code)) {
            rootEnd = 1;
            if (isPathSeparator2(path.charCodeAt(1))) {
                let j = 2;
                let last = j;
                for(; j < len; ++j){
                    if (isPathSeparator2(path.charCodeAt(j))) break;
                }
                if (j < len && j !== last) {
                    last = j;
                    for(; j < len; ++j){
                        if (!isPathSeparator2(path.charCodeAt(j))) break;
                    }
                    if (j < len && j !== last) {
                        last = j;
                        for(; j < len; ++j){
                            if (isPathSeparator2(path.charCodeAt(j))) break;
                        }
                        if (j === len) {
                            rootEnd = j;
                        } else if (j !== last) {
                            rootEnd = j + 1;
                        }
                    }
                }
            }
        } else if (isWindowsDeviceRoot2(code)) {
            if (path.charCodeAt(1) === 58) {
                rootEnd = 2;
                if (len > 2) {
                    if (isPathSeparator2(path.charCodeAt(2))) {
                        if (len === 3) {
                            ret.root = ret.dir = path;
                            return ret;
                        }
                        rootEnd = 3;
                    }
                } else {
                    ret.root = ret.dir = path;
                    return ret;
                }
            }
        }
    } else if (isPathSeparator2(code)) {
        ret.root = ret.dir = path;
        return ret;
    }
    if (rootEnd > 0) ret.root = path.slice(0, rootEnd);
    let startDot = -1;
    let startPart = rootEnd;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= rootEnd; --i){
        code = path.charCodeAt(i);
        if (isPathSeparator2(code)) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            ret.base = ret.name = path.slice(startPart, end);
        }
    } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0 && startPart !== rootEnd) {
        ret.dir = path.slice(0, startPart - 1);
    } else ret.dir = ret.root;
    return ret;
}
function fromFileUrl6(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    let path = decodeURIComponent(url.pathname.replace(/\//g, "\\").replace(/%(?![0-9A-Fa-f]{2})/g, "%25")).replace(/^\\*([A-Za-z]:)(\\|$)/, "$1\\");
    if (url.hostname != "") {
        path = `\\\\${url.hostname}${path}`;
    }
    return path;
}
function toFileUrl6(path) {
    if (!isAbsolute6(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const [, hostname, pathname] = path.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/);
    const url = new URL("file:///");
    url.pathname = encodeWhitespace2(pathname.replace(/%/g, "%25"));
    if (hostname != null && hostname != "localhost") {
        url.hostname = hostname;
        if (!url.hostname) {
            throw new TypeError("Invalid hostname.");
        }
    }
    return url;
}
const __default9 = {
    basename: basename6,
    delimiter: delimiter6,
    dirname: dirname6,
    extname: extname6,
    format: format6,
    fromFileUrl: fromFileUrl6,
    isAbsolute: isAbsolute6,
    join: join9,
    normalize: normalize8,
    parse: parse7,
    relative: relative6,
    resolve: resolve6,
    sep: sep5,
    toFileUrl: toFileUrl6,
    toNamespacedPath: toNamespacedPath6
};
const mod61 = {
    sep: sep5,
    delimiter: delimiter6,
    resolve: resolve6,
    normalize: normalize8,
    isAbsolute: isAbsolute6,
    join: join9,
    relative: relative6,
    toNamespacedPath: toNamespacedPath6,
    dirname: dirname6,
    basename: basename6,
    extname: extname6,
    format: format6,
    parse: parse7,
    fromFileUrl: fromFileUrl6,
    toFileUrl: toFileUrl6,
    default: __default9
};
const sep6 = "/";
const delimiter7 = ":";
function resolve7(...pathSegments) {
    let resolvedPath = "";
    let resolvedAbsolute = false;
    for(let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--){
        let path;
        if (i >= 0) path = pathSegments[i];
        else {
            const { Deno: Deno1  } = globalThis;
            if (typeof Deno1?.cwd !== "function") {
                throw new TypeError("Resolved a relative path without a CWD.");
            }
            path = Deno1.cwd();
        }
        assertPath2(path);
        if (path.length === 0) {
            continue;
        }
        resolvedPath = `${path}/${resolvedPath}`;
        resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH2;
    }
    resolvedPath = normalizeString2(resolvedPath, !resolvedAbsolute, "/", isPosixPathSeparator2);
    if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return `/${resolvedPath}`;
        else return "/";
    } else if (resolvedPath.length > 0) return resolvedPath;
    else return ".";
}
function normalize9(path) {
    assertPath2(path);
    if (path.length === 0) return ".";
    const isAbsolute = path.charCodeAt(0) === 47;
    const trailingSeparator = path.charCodeAt(path.length - 1) === 47;
    path = normalizeString2(path, !isAbsolute, "/", isPosixPathSeparator2);
    if (path.length === 0 && !isAbsolute) path = ".";
    if (path.length > 0 && trailingSeparator) path += "/";
    if (isAbsolute) return `/${path}`;
    return path;
}
function isAbsolute7(path) {
    assertPath2(path);
    return path.length > 0 && path.charCodeAt(0) === 47;
}
function join10(...paths) {
    if (paths.length === 0) return ".";
    let joined;
    for(let i = 0, len = paths.length; i < len; ++i){
        const path = paths[i];
        assertPath2(path);
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `/${path}`;
        }
    }
    if (!joined) return ".";
    return normalize9(joined);
}
function relative7(from, to) {
    assertPath2(from);
    assertPath2(to);
    if (from === to) return "";
    from = resolve7(from);
    to = resolve7(to);
    if (from === to) return "";
    let fromStart = 1;
    const fromEnd = from.length;
    for(; fromStart < fromEnd; ++fromStart){
        if (from.charCodeAt(fromStart) !== 47) break;
    }
    const fromLen = fromEnd - fromStart;
    let toStart = 1;
    const toEnd = to.length;
    for(; toStart < toEnd; ++toStart){
        if (to.charCodeAt(toStart) !== 47) break;
    }
    const toLen = toEnd - toStart;
    const length = fromLen < toLen ? fromLen : toLen;
    let lastCommonSep = -1;
    let i = 0;
    for(; i <= length; ++i){
        if (i === length) {
            if (toLen > length) {
                if (to.charCodeAt(toStart + i) === 47) {
                    return to.slice(toStart + i + 1);
                } else if (i === 0) {
                    return to.slice(toStart + i);
                }
            } else if (fromLen > length) {
                if (from.charCodeAt(fromStart + i) === 47) {
                    lastCommonSep = i;
                } else if (i === 0) {
                    lastCommonSep = 0;
                }
            }
            break;
        }
        const fromCode = from.charCodeAt(fromStart + i);
        const toCode = to.charCodeAt(toStart + i);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i;
    }
    let out = "";
    for(i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i){
        if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0) out += "..";
            else out += "/..";
        }
    }
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
    else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
    }
}
function toNamespacedPath7(path) {
    return path;
}
function dirname7(path) {
    assertPath2(path);
    if (path.length === 0) return ".";
    const hasRoot = path.charCodeAt(0) === 47;
    let end = -1;
    let matchedSlash = true;
    for(let i = path.length - 1; i >= 1; --i){
        if (path.charCodeAt(i) === 47) {
            if (!matchedSlash) {
                end = i;
                break;
            }
        } else {
            matchedSlash = false;
        }
    }
    if (end === -1) return hasRoot ? "/" : ".";
    if (hasRoot && end === 1) return "//";
    return path.slice(0, end);
}
function basename7(path, ext = "") {
    if (ext !== undefined && typeof ext !== "string") {
        throw new ERR_INVALID_ARG_TYPE("ext", [
            "string"
        ], ext);
    }
    assertPath2(path);
    let start = 0;
    let end = -1;
    let matchedSlash = true;
    let i;
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path) return "";
        let extIdx = ext.length - 1;
        let firstNonSlashEnd = -1;
        for(i = path.length - 1; i >= 0; --i){
            const code = path.charCodeAt(i);
            if (code === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else {
                if (firstNonSlashEnd === -1) {
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            end = i;
                        }
                    } else {
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path.length;
        return path.slice(start, end);
    } else {
        for(i = path.length - 1; i >= 0; --i){
            if (path.charCodeAt(i) === 47) {
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            } else if (end === -1) {
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1) return "";
        return path.slice(start, end);
    }
}
function extname7(path) {
    assertPath2(path);
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let preDotState = 0;
    for(let i = path.length - 1; i >= 0; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
    }
    return path.slice(startDot, end);
}
function format7(pathObject) {
    if (pathObject === null || typeof pathObject !== "object") {
        throw new ERR_INVALID_ARG_TYPE("pathObject", [
            "Object"
        ], pathObject);
    }
    return _format2("/", pathObject);
}
function parse8(path) {
    assertPath2(path);
    const ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
    };
    if (path.length === 0) return ret;
    const isAbsolute = path.charCodeAt(0) === 47;
    let start;
    if (isAbsolute) {
        ret.root = "/";
        start = 1;
    } else {
        start = 0;
    }
    let startDot = -1;
    let startPart = 0;
    let end = -1;
    let matchedSlash = true;
    let i = path.length - 1;
    let preDotState = 0;
    for(; i >= start; --i){
        const code = path.charCodeAt(i);
        if (code === 47) {
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46) {
            if (startDot === -1) startDot = i;
            else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
            if (startPart === 0 && isAbsolute) {
                ret.base = ret.name = path.slice(1, end);
            } else {
                ret.base = ret.name = path.slice(startPart, end);
            }
        }
    } else {
        if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
        } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
        }
        ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);
    else if (isAbsolute) ret.dir = "/";
    return ret;
}
function fromFileUrl7(url) {
    url = url instanceof URL ? url : new URL(url);
    if (url.protocol != "file:") {
        throw new TypeError("Must be a file URL.");
    }
    return decodeURIComponent(url.pathname.replace(/%(?![0-9A-Fa-f]{2})/g, "%25"));
}
function toFileUrl7(path) {
    if (!isAbsolute7(path)) {
        throw new TypeError("Must be an absolute path.");
    }
    const url = new URL("file:///");
    url.pathname = encodeWhitespace2(path.replace(/%/g, "%25").replace(/\\/g, "%5C"));
    return url;
}
const __default10 = {
    basename: basename7,
    delimiter: delimiter7,
    dirname: dirname7,
    extname: extname7,
    format: format7,
    fromFileUrl: fromFileUrl7,
    isAbsolute: isAbsolute7,
    join: join10,
    normalize: normalize9,
    parse: parse8,
    relative: relative7,
    resolve: resolve7,
    sep: sep6,
    toFileUrl: toFileUrl7,
    toNamespacedPath: toNamespacedPath7
};
const mod62 = {
    sep: sep6,
    delimiter: delimiter7,
    resolve: resolve7,
    normalize: normalize9,
    isAbsolute: isAbsolute7,
    join: join10,
    relative: relative7,
    toNamespacedPath: toNamespacedPath7,
    dirname: dirname7,
    basename: basename7,
    extname: extname7,
    format: format7,
    parse: parse8,
    fromFileUrl: fromFileUrl7,
    toFileUrl: toFileUrl7,
    default: __default10
};
const SEP = isWindows1 ? "\\" : "/";
const SEP_PATTERN = isWindows1 ? /[\\/]+/ : /\/+/;
function common(paths, sep = SEP) {
    const [first = "", ...remaining] = paths;
    if (first === "" || remaining.length === 0) {
        return first.substring(0, first.lastIndexOf(sep) + 1);
    }
    const parts = first.split(sep);
    let endOfPrefix = parts.length;
    for (const path of remaining){
        const compare = path.split(sep);
        for(let i = 0; i < endOfPrefix; i++){
            if (compare[i] !== parts[i]) {
                endOfPrefix = i;
            }
        }
        if (endOfPrefix === 0) {
            return "";
        }
    }
    const prefix = parts.slice(0, endOfPrefix).join(sep);
    return prefix.endsWith(sep) ? prefix : `${prefix}${sep}`;
}
const path4 = isWindows1 ? mod61 : mod62;
const { join: join11 , normalize: normalize10  } = path4;
const regExpEscapeChars = [
    "!",
    "$",
    "(",
    ")",
    "*",
    "+",
    ".",
    "=",
    "?",
    "[",
    "\\",
    "^",
    "{",
    "|"
];
const rangeEscapeChars = [
    "-",
    "\\",
    "]"
];
function globToRegExp(glob, { extended =true , globstar: globstarOption = true , os =osType1 , caseInsensitive =false  } = {}) {
    if (glob == "") {
        return /(?!)/;
    }
    const sep = os == "windows" ? "(?:\\\\|/)+" : "/+";
    const sepMaybe = os == "windows" ? "(?:\\\\|/)*" : "/*";
    const seps = os == "windows" ? [
        "\\",
        "/"
    ] : [
        "/"
    ];
    const globstar = os == "windows" ? "(?:[^\\\\/]*(?:\\\\|/|$)+)*" : "(?:[^/]*(?:/|$)+)*";
    const wildcard = os == "windows" ? "[^\\\\/]*" : "[^/]*";
    const escapePrefix = os == "windows" ? "`" : "\\";
    let newLength = glob.length;
    for(; newLength > 1 && seps.includes(glob[newLength - 1]); newLength--);
    glob = glob.slice(0, newLength);
    let regExpString = "";
    for(let j = 0; j < glob.length;){
        let segment = "";
        const groupStack = [];
        let inRange = false;
        let inEscape = false;
        let endsWithSep = false;
        let i = j;
        for(; i < glob.length && !seps.includes(glob[i]); i++){
            if (inEscape) {
                inEscape = false;
                const escapeChars = inRange ? rangeEscapeChars : regExpEscapeChars;
                segment += escapeChars.includes(glob[i]) ? `\\${glob[i]}` : glob[i];
                continue;
            }
            if (glob[i] == escapePrefix) {
                inEscape = true;
                continue;
            }
            if (glob[i] == "[") {
                if (!inRange) {
                    inRange = true;
                    segment += "[";
                    if (glob[i + 1] == "!") {
                        i++;
                        segment += "^";
                    } else if (glob[i + 1] == "^") {
                        i++;
                        segment += "\\^";
                    }
                    continue;
                } else if (glob[i + 1] == ":") {
                    let k = i + 1;
                    let value = "";
                    while(glob[k + 1] != null && glob[k + 1] != ":"){
                        value += glob[k + 1];
                        k++;
                    }
                    if (glob[k + 1] == ":" && glob[k + 2] == "]") {
                        i = k + 2;
                        if (value == "alnum") segment += "\\dA-Za-z";
                        else if (value == "alpha") segment += "A-Za-z";
                        else if (value == "ascii") segment += "\x00-\x7F";
                        else if (value == "blank") segment += "\t ";
                        else if (value == "cntrl") segment += "\x00-\x1F\x7F";
                        else if (value == "digit") segment += "\\d";
                        else if (value == "graph") segment += "\x21-\x7E";
                        else if (value == "lower") segment += "a-z";
                        else if (value == "print") segment += "\x20-\x7E";
                        else if (value == "punct") {
                            segment += "!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_‘{|}~";
                        } else if (value == "space") segment += "\\s\v";
                        else if (value == "upper") segment += "A-Z";
                        else if (value == "word") segment += "\\w";
                        else if (value == "xdigit") segment += "\\dA-Fa-f";
                        continue;
                    }
                }
            }
            if (glob[i] == "]" && inRange) {
                inRange = false;
                segment += "]";
                continue;
            }
            if (inRange) {
                if (glob[i] == "\\") {
                    segment += `\\\\`;
                } else {
                    segment += glob[i];
                }
                continue;
            }
            if (glob[i] == ")" && groupStack.length > 0 && groupStack[groupStack.length - 1] != "BRACE") {
                segment += ")";
                const type = groupStack.pop();
                if (type == "!") {
                    segment += wildcard;
                } else if (type != "@") {
                    segment += type;
                }
                continue;
            }
            if (glob[i] == "|" && groupStack.length > 0 && groupStack[groupStack.length - 1] != "BRACE") {
                segment += "|";
                continue;
            }
            if (glob[i] == "+" && extended && glob[i + 1] == "(") {
                i++;
                groupStack.push("+");
                segment += "(?:";
                continue;
            }
            if (glob[i] == "@" && extended && glob[i + 1] == "(") {
                i++;
                groupStack.push("@");
                segment += "(?:";
                continue;
            }
            if (glob[i] == "?") {
                if (extended && glob[i + 1] == "(") {
                    i++;
                    groupStack.push("?");
                    segment += "(?:";
                } else {
                    segment += ".";
                }
                continue;
            }
            if (glob[i] == "!" && extended && glob[i + 1] == "(") {
                i++;
                groupStack.push("!");
                segment += "(?!";
                continue;
            }
            if (glob[i] == "{") {
                groupStack.push("BRACE");
                segment += "(?:";
                continue;
            }
            if (glob[i] == "}" && groupStack[groupStack.length - 1] == "BRACE") {
                groupStack.pop();
                segment += ")";
                continue;
            }
            if (glob[i] == "," && groupStack[groupStack.length - 1] == "BRACE") {
                segment += "|";
                continue;
            }
            if (glob[i] == "*") {
                if (extended && glob[i + 1] == "(") {
                    i++;
                    groupStack.push("*");
                    segment += "(?:";
                } else {
                    const prevChar = glob[i - 1];
                    let numStars = 1;
                    while(glob[i + 1] == "*"){
                        i++;
                        numStars++;
                    }
                    const nextChar = glob[i + 1];
                    if (globstarOption && numStars == 2 && [
                        ...seps,
                        undefined
                    ].includes(prevChar) && [
                        ...seps,
                        undefined
                    ].includes(nextChar)) {
                        segment += globstar;
                        endsWithSep = true;
                    } else {
                        segment += wildcard;
                    }
                }
                continue;
            }
            segment += regExpEscapeChars.includes(glob[i]) ? `\\${glob[i]}` : glob[i];
        }
        if (groupStack.length > 0 || inRange || inEscape) {
            segment = "";
            for (const c of glob.slice(j, i)){
                segment += regExpEscapeChars.includes(c) ? `\\${c}` : c;
                endsWithSep = false;
            }
        }
        regExpString += segment;
        if (!endsWithSep) {
            regExpString += i < glob.length ? sep : sepMaybe;
            endsWithSep = true;
        }
        while(seps.includes(glob[i]))i++;
        if (!(i > j)) {
            throw new Error("Assertion failure: i > j (potential infinite loop)");
        }
        j = i;
    }
    regExpString = `^${regExpString}$`;
    return new RegExp(regExpString, caseInsensitive ? "i" : "");
}
function isGlob(str) {
    const chars = {
        "{": "}",
        "(": ")",
        "[": "]"
    };
    const regex = /\\(.)|(^!|\*|\?|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
    if (str === "") {
        return false;
    }
    let match;
    while(match = regex.exec(str)){
        if (match[2]) return true;
        let idx = match.index + match[0].length;
        const open = match[1];
        const close = open ? chars[open] : null;
        if (open && close) {
            const n = str.indexOf(close, idx);
            if (n !== -1) {
                idx = n + 1;
            }
        }
        str = str.slice(idx);
    }
    return false;
}
function normalizeGlob(glob, { globstar =false  } = {}) {
    if (glob.match(/\0/g)) {
        throw new Error(`Glob contains invalid characters: "${glob}"`);
    }
    if (!globstar) {
        return normalize10(glob);
    }
    const s = SEP_PATTERN.source;
    const badParentPattern = new RegExp(`(?<=(${s}|^)\\*\\*${s})\\.\\.(?=${s}|$)`, "g");
    return normalize10(glob.replace(badParentPattern, "\0")).replace(/\0/g, "..");
}
function joinGlobs(globs, { extended =true , globstar =false  } = {}) {
    if (!globstar || globs.length == 0) {
        return join11(...globs);
    }
    if (globs.length === 0) return ".";
    let joined;
    for (const glob of globs){
        const path = glob;
        if (path.length > 0) {
            if (!joined) joined = path;
            else joined += `${SEP}${path}`;
        }
    }
    if (!joined) return ".";
    return normalizeGlob(joined, {
        extended,
        globstar
    });
}
const path5 = isWindows1 ? __default9 : __default10;
const { basename: basename8 , delimiter: delimiter8 , dirname: dirname8 , extname: extname8 , format: format8 , fromFileUrl: fromFileUrl8 , isAbsolute: isAbsolute8 , join: join12 , normalize: normalize11 , parse: parse9 , relative: relative8 , resolve: resolve8 , sep: sep7 , toFileUrl: toFileUrl8 , toNamespacedPath: toNamespacedPath8  } = path5;
const mod63 = {
    SEP: SEP,
    SEP_PATTERN: SEP_PATTERN,
    win32: __default9,
    posix: __default10,
    basename: basename8,
    delimiter: delimiter8,
    dirname: dirname8,
    extname: extname8,
    format: format8,
    fromFileUrl: fromFileUrl8,
    isAbsolute: isAbsolute8,
    join: join12,
    normalize: normalize11,
    parse: parse9,
    relative: relative8,
    resolve: resolve8,
    sep: sep7,
    toFileUrl: toFileUrl8,
    toNamespacedPath: toNamespacedPath8,
    common,
    globToRegExp,
    isGlob,
    normalizeGlob,
    joinGlobs
};
const __default11 = {
    ...mod63
};
"use strict";
const hexTable1 = new Array(256);
for(let i = 0; i < 256; ++i){
    hexTable1[i] = "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase();
}
new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
]);
new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
]);
new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
]);
new Int8Array([
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    +0,
    +1,
    +2,
    +3,
    +4,
    +5,
    +6,
    +7,
    +8,
    +9,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    10,
    11,
    12,
    13,
    14,
    15,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1
]);
const forwardSlashRegEx = /\//g;
new Set([
    "javascript",
    "javascript:"
]);
new Set([
    "javascript",
    "javascript:"
]);
new Set([
    "http",
    "http:",
    "https",
    "https:",
    "ftp",
    "ftp:",
    "gopher",
    "gopher:",
    "file",
    "file:",
    "ws",
    "ws:",
    "wss",
    "wss:"
]);
new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
]);
URL;
function fileURLToPath(path) {
    if (typeof path === "string") path = new URL(path);
    else if (!(path instanceof URL)) {
        throw new ERR_INVALID_ARG_TYPE("path", [
            "string",
            "URL"
        ], path);
    }
    if (path.protocol !== "file:") {
        throw new ERR_INVALID_URL_SCHEME("file");
    }
    return isWindows1 ? getPathFromURLWin(path) : getPathFromURLPosix(path);
}
function getPathFromURLWin(url) {
    const hostname = url.hostname;
    let pathname = url.pathname;
    for(let n = 0; n < pathname.length; n++){
        if (pathname[n] === "%") {
            const third = pathname.codePointAt(n + 2) | 0x20;
            if (pathname[n + 1] === "2" && third === 102 || pathname[n + 1] === "5" && third === 99) {
                throw new ERR_INVALID_FILE_URL_PATH("must not include encoded \\ or / characters");
            }
        }
    }
    pathname = pathname.replace(forwardSlashRegEx, "\\");
    pathname = decodeURIComponent(pathname);
    if (hostname !== "") {
        return `\\\\${hostname}${pathname}`;
    } else {
        const letter = pathname.codePointAt(1) | 0x20;
        const sep = pathname[2];
        if (letter < 97 || letter > 122 || sep !== ":") {
            throw new ERR_INVALID_FILE_URL_PATH("must be absolute");
        }
        return pathname.slice(1);
    }
}
function getPathFromURLPosix(url) {
    if (url.hostname !== "") {
        throw new ERR_INVALID_FILE_URL_HOST(osType1);
    }
    const pathname = url.pathname;
    for(let n = 0; n < pathname.length; n++){
        if (pathname[n] === "%") {
            const third = pathname.codePointAt(n + 2) | 0x20;
            if (pathname[n + 1] === "2" && third === 102) {
                throw new ERR_INVALID_FILE_URL_PATH("must not include encoded / characters");
            }
        }
    }
    return decodeURIComponent(pathname);
}
URLSearchParams;
Symbol("query");
function toPathIfFileURL(fileURLOrPath) {
    if (!(fileURLOrPath instanceof URL)) {
        return fileURLOrPath;
    }
    return fileURLToPath(fileURLOrPath);
}
function assert3(value, message) {
    if (!value) {
        throw new ERR_INTERNAL_ASSERTION(message);
    }
}
function fail(message) {
    throw new ERR_INTERNAL_ASSERTION(message);
}
assert3.fail = fail;
function convertFileInfoToStats(origin) {
    return {
        dev: origin.dev,
        ino: origin.ino,
        mode: origin.mode,
        nlink: origin.nlink,
        uid: origin.uid,
        gid: origin.gid,
        rdev: origin.rdev,
        size: origin.size,
        blksize: origin.blksize,
        blocks: origin.blocks,
        mtime: origin.mtime,
        atime: origin.atime,
        birthtime: origin.birthtime,
        mtimeMs: origin.mtime?.getTime() || null,
        atimeMs: origin.atime?.getTime() || null,
        birthtimeMs: origin.birthtime?.getTime() || null,
        isFile: ()=>origin.isFile,
        isDirectory: ()=>origin.isDirectory,
        isSymbolicLink: ()=>origin.isSymlink,
        isBlockDevice: ()=>false,
        isFIFO: ()=>false,
        isCharacterDevice: ()=>false,
        isSocket: ()=>false,
        ctime: origin.mtime,
        ctimeMs: origin.mtime?.getTime() || null
    };
}
function toBigInt(number) {
    if (number === null || number === undefined) return null;
    return BigInt(number);
}
function convertFileInfoToBigIntStats(origin) {
    return {
        dev: toBigInt(origin.dev),
        ino: toBigInt(origin.ino),
        mode: toBigInt(origin.mode),
        nlink: toBigInt(origin.nlink),
        uid: toBigInt(origin.uid),
        gid: toBigInt(origin.gid),
        rdev: toBigInt(origin.rdev),
        size: toBigInt(origin.size) || 0n,
        blksize: toBigInt(origin.blksize),
        blocks: toBigInt(origin.blocks),
        mtime: origin.mtime,
        atime: origin.atime,
        birthtime: origin.birthtime,
        mtimeMs: origin.mtime ? BigInt(origin.mtime.getTime()) : null,
        atimeMs: origin.atime ? BigInt(origin.atime.getTime()) : null,
        birthtimeMs: origin.birthtime ? BigInt(origin.birthtime.getTime()) : null,
        mtimeNs: origin.mtime ? BigInt(origin.mtime.getTime()) * 1000000n : null,
        atimeNs: origin.atime ? BigInt(origin.atime.getTime()) * 1000000n : null,
        birthtimeNs: origin.birthtime ? BigInt(origin.birthtime.getTime()) * 1000000n : null,
        isFile: ()=>origin.isFile,
        isDirectory: ()=>origin.isDirectory,
        isSymbolicLink: ()=>origin.isSymlink,
        isBlockDevice: ()=>false,
        isFIFO: ()=>false,
        isCharacterDevice: ()=>false,
        isSocket: ()=>false,
        ctime: origin.mtime,
        ctimeMs: origin.mtime ? BigInt(origin.mtime.getTime()) : null,
        ctimeNs: origin.mtime ? BigInt(origin.mtime.getTime()) * 1000000n : null
    };
}
function CFISBIS(fileInfo, bigInt) {
    if (bigInt) return convertFileInfoToBigIntStats(fileInfo);
    return convertFileInfoToStats(fileInfo);
}
function stat(path, optionsOrCallback, maybeCallback) {
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback;
    const options = typeof optionsOrCallback === "object" ? optionsOrCallback : {
        bigint: false
    };
    if (!callback) throw new Error("No callback function supplied");
    Deno.stat(path).then((stat)=>callback(null, CFISBIS(stat, options.bigint)), (err)=>callback(denoErrorToNodeError(err, {
            syscall: "stat"
        })));
}
const statPromise = promisify(stat);
function statSync(path, options = {
    bigint: false,
    throwIfNoEntry: true
}) {
    try {
        const origin = Deno.statSync(path);
        return CFISBIS(origin, options.bigint);
    } catch (err) {
        if (options?.throwIfNoEntry === false && err instanceof Deno.errors.NotFound) {
            return;
        }
        if (err instanceof Error) {
            throw denoErrorToNodeError(err, {
                syscall: "stat"
            });
        } else {
            throw err;
        }
    }
}
function lstat(path, optionsOrCallback, maybeCallback) {
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback;
    const options = typeof optionsOrCallback === "object" ? optionsOrCallback : {
        bigint: false
    };
    if (!callback) throw new Error("No callback function supplied");
    Deno.lstat(path).then((stat)=>callback(null, CFISBIS(stat, options.bigint)), (err)=>callback(err));
}
const lstatPromise = promisify(lstat);
"use strict";
const kType = Symbol("type");
const kStats = Symbol("stats");
const { F_OK: F_OK1 = 0 , W_OK: W_OK1 = 0 , R_OK: R_OK1 = 0 , X_OK: X_OK1 = 0 , COPYFILE_EXCL: COPYFILE_EXCL1 , COPYFILE_FICLONE: COPYFILE_FICLONE1 , COPYFILE_FICLONE_FORCE: COPYFILE_FICLONE_FORCE1 , O_APPEND: O_APPEND1 , O_CREAT: O_CREAT1 , O_EXCL: O_EXCL1 , O_RDONLY: O_RDONLY1 , O_RDWR: O_RDWR1 , O_SYNC: O_SYNC1 , O_TRUNC: O_TRUNC1 , O_WRONLY: O_WRONLY1 , S_IFBLK , S_IFCHR , S_IFDIR , S_IFIFO , S_IFLNK , S_IFMT , S_IFREG , S_IFSOCK , UV_FS_SYMLINK_DIR , UV_FS_SYMLINK_JUNCTION , UV_DIRENT_UNKNOWN , UV_DIRENT_FILE , UV_DIRENT_DIR , UV_DIRENT_LINK , UV_DIRENT_FIFO , UV_DIRENT_SOCKET , UV_DIRENT_CHAR , UV_DIRENT_BLOCK  } = fs;
const { errno: { EISDIR  }  } = os;
const kMinimumAccessMode = Math.min(F_OK1, W_OK1, R_OK1, X_OK1);
const kMaximumAccessMode = F_OK1 | W_OK1 | R_OK1 | X_OK1;
const kDefaultCopyMode = 0;
const kMinimumCopyMode = Math.min(0, COPYFILE_EXCL1, COPYFILE_FICLONE1, COPYFILE_FICLONE_FORCE1);
const kMaximumCopyMode = COPYFILE_EXCL1 | COPYFILE_FICLONE1 | COPYFILE_FICLONE_FORCE1;
const kMaxUserId = 2 ** 32 - 1;
function assertEncoding(encoding) {
    if (encoding && !Buffer.isEncoding(encoding)) {
        const reason = "is invalid encoding";
        throw new ERR_INVALID_ARG_VALUE(encoding, "encoding", reason);
    }
}
class Dirent {
    constructor(name, type){
        this.name = name;
        this[kType] = type;
    }
    isDirectory() {
        return this[kType] === UV_DIRENT_DIR;
    }
    isFile() {
        return this[kType] === UV_DIRENT_FILE;
    }
    isBlockDevice() {
        return this[kType] === UV_DIRENT_BLOCK;
    }
    isCharacterDevice() {
        return this[kType] === UV_DIRENT_CHAR;
    }
    isSymbolicLink() {
        return this[kType] === UV_DIRENT_LINK;
    }
    isFIFO() {
        return this[kType] === UV_DIRENT_FIFO;
    }
    isSocket() {
        return this[kType] === UV_DIRENT_SOCKET;
    }
}
class DirentFromStats extends Dirent {
    constructor(name, stats){
        super(name, null);
        this[kStats] = stats;
    }
}
for (const name of Reflect.ownKeys(Dirent.prototype)){
    if (name === "constructor") {
        continue;
    }
    DirentFromStats.prototype[name] = function() {
        return this[kStats][name]();
    };
}
function copyObject(source) {
    const target = {};
    for(const key in source){
        target[key] = source[key];
    }
    return target;
}
Buffer.from(__default11.sep);
function getOptions1(options, defaultOptions) {
    if (options === null || options === undefined || typeof options === "function") {
        return defaultOptions;
    }
    if (typeof options === "string") {
        defaultOptions = {
            ...defaultOptions
        };
        defaultOptions.encoding = options;
        options = defaultOptions;
    } else if (typeof options !== "object") {
        throw new ERR_INVALID_ARG_TYPE("options", [
            "string",
            "Object"
        ], options);
    }
    if (options.encoding !== "buffer") {
        assertEncoding(options.encoding);
    }
    if (options.signal !== undefined) {
        validateAbortSignal(options.signal, "options.signal");
    }
    return options;
}
const nullCheck = hideStackFrames((path, propName, throwError = true)=>{
    const pathIsString = typeof path === "string";
    const pathIsUint8Array = isUint8Array(path);
    if (!pathIsString && !pathIsUint8Array || pathIsString && !path.includes("\u0000") || pathIsUint8Array && !path.includes(0)) {
        return;
    }
    const err = new ERR_INVALID_ARG_VALUE(propName, path, "must be a string or Uint8Array without null bytes");
    if (throwError) {
        throw err;
    }
    return err;
});
function StatsBase(dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks) {
    this.dev = dev;
    this.mode = mode;
    this.nlink = nlink;
    this.uid = uid;
    this.gid = gid;
    this.rdev = rdev;
    this.blksize = blksize;
    this.ino = ino;
    this.size = size;
    this.blocks = blocks;
}
StatsBase.prototype.isDirectory = function() {
    return this._checkModeProperty(S_IFDIR);
};
StatsBase.prototype.isFile = function() {
    return this._checkModeProperty(S_IFREG);
};
StatsBase.prototype.isBlockDevice = function() {
    return this._checkModeProperty(S_IFBLK);
};
StatsBase.prototype.isCharacterDevice = function() {
    return this._checkModeProperty(S_IFCHR);
};
StatsBase.prototype.isSymbolicLink = function() {
    return this._checkModeProperty(S_IFLNK);
};
StatsBase.prototype.isFIFO = function() {
    return this._checkModeProperty(S_IFIFO);
};
StatsBase.prototype.isSocket = function() {
    return this._checkModeProperty(S_IFSOCK);
};
const kNsPerMsBigInt = 10n ** 6n;
function dateFromMs(ms) {
    return new Date(Number(ms) + 0.5);
}
function BigIntStats(dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atimeNs, mtimeNs, ctimeNs, birthtimeNs) {
    Reflect.apply(StatsBase, this, [
        dev,
        mode,
        nlink,
        uid,
        gid,
        rdev,
        blksize,
        ino,
        size,
        blocks
    ]);
    this.atimeMs = atimeNs / kNsPerMsBigInt;
    this.mtimeMs = mtimeNs / kNsPerMsBigInt;
    this.ctimeMs = ctimeNs / kNsPerMsBigInt;
    this.birthtimeMs = birthtimeNs / kNsPerMsBigInt;
    this.atimeNs = atimeNs;
    this.mtimeNs = mtimeNs;
    this.ctimeNs = ctimeNs;
    this.birthtimeNs = birthtimeNs;
    this.atime = dateFromMs(this.atimeMs);
    this.mtime = dateFromMs(this.mtimeMs);
    this.ctime = dateFromMs(this.ctimeMs);
    this.birthtime = dateFromMs(this.birthtimeMs);
}
Object.setPrototypeOf(BigIntStats.prototype, StatsBase.prototype);
Object.setPrototypeOf(BigIntStats, StatsBase);
BigIntStats.prototype._checkModeProperty = function(property) {
    if (isWindows1 && (property === S_IFIFO || property === S_IFBLK || property === S_IFSOCK)) {
        return false;
    }
    return (this.mode & BigInt(S_IFMT)) === BigInt(property);
};
function Stats(dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks, atimeMs, mtimeMs, ctimeMs, birthtimeMs) {
    StatsBase.call(this, dev, mode, nlink, uid, gid, rdev, blksize, ino, size, blocks);
    this.atimeMs = atimeMs;
    this.mtimeMs = mtimeMs;
    this.ctimeMs = ctimeMs;
    this.birthtimeMs = birthtimeMs;
    this.atime = dateFromMs(atimeMs);
    this.mtime = dateFromMs(mtimeMs);
    this.ctime = dateFromMs(ctimeMs);
    this.birthtime = dateFromMs(birthtimeMs);
}
Object.setPrototypeOf(Stats.prototype, StatsBase.prototype);
Object.setPrototypeOf(Stats, StatsBase);
Stats.prototype.isFile = StatsBase.prototype.isFile;
Stats.prototype._checkModeProperty = function(property) {
    if (isWindows1 && (property === S_IFIFO || property === S_IFBLK || property === S_IFSOCK)) {
        return false;
    }
    return (this.mode & S_IFMT) === property;
};
hideStackFrames((type)=>{
    let flags = 0;
    if (typeof type === "string") {
        switch(type){
            case "dir":
                flags |= UV_FS_SYMLINK_DIR;
                break;
            case "junction":
                flags |= UV_FS_SYMLINK_JUNCTION;
                break;
            case "file":
                break;
            default:
                throw new ERR_FS_INVALID_SYMLINK_TYPE(type);
        }
    }
    return flags;
});
const validateOffsetLengthRead = hideStackFrames((offset, length, bufferLength)=>{
    if (offset < 0) {
        throw new ERR_OUT_OF_RANGE("offset", ">= 0", offset);
    }
    if (length < 0) {
        throw new ERR_OUT_OF_RANGE("length", ">= 0", length);
    }
    if (offset + length > bufferLength) {
        throw new ERR_OUT_OF_RANGE("length", `<= ${bufferLength - offset}`, length);
    }
});
const validateOffsetLengthWrite = hideStackFrames((offset, length, byteLength)=>{
    if (offset > byteLength) {
        throw new ERR_OUT_OF_RANGE("offset", `<= ${byteLength}`, offset);
    }
    if (length > byteLength - offset) {
        throw new ERR_OUT_OF_RANGE("length", `<= ${byteLength - offset}`, length);
    }
    if (length < 0) {
        throw new ERR_OUT_OF_RANGE("length", ">= 0", length);
    }
    validateInt32(length, "length", 0);
});
const validatePath = hideStackFrames((path, propName = "path")=>{
    if (typeof path !== "string" && !isUint8Array(path)) {
        throw new ERR_INVALID_ARG_TYPE(propName, [
            "string",
            "Buffer",
            "URL"
        ], path);
    }
    const err = nullCheck(path, propName, false);
    if (err !== undefined) {
        throw err;
    }
});
const getValidatedPath = hideStackFrames((fileURLOrPath, propName = "path")=>{
    const path = toPathIfFileURL(fileURLOrPath);
    validatePath(path, propName);
    return path;
});
const getValidatedFd = hideStackFrames((fd, propName = "fd")=>{
    if (Object.is(fd, -0)) {
        return 0;
    }
    validateInt32(fd, propName, 0);
    return fd;
});
const validateBufferArray = hideStackFrames((buffers, propName = "buffers")=>{
    if (!Array.isArray(buffers)) {
        throw new ERR_INVALID_ARG_TYPE(propName, "ArrayBufferView[]", buffers);
    }
    for(let i = 0; i < buffers.length; i++){
        if (!isArrayBufferView(buffers[i])) {
            throw new ERR_INVALID_ARG_TYPE(propName, "ArrayBufferView[]", buffers);
        }
    }
    return buffers;
});
const defaultCpOptions = {
    dereference: false,
    errorOnExist: false,
    filter: undefined,
    force: true,
    preserveTimestamps: false,
    recursive: false
};
const defaultRmOptions = {
    recursive: false,
    force: false,
    retryDelay: 100,
    maxRetries: 0
};
const defaultRmdirOptions = {
    retryDelay: 100,
    maxRetries: 0,
    recursive: false
};
hideStackFrames((options)=>{
    if (options === undefined) {
        return {
            ...defaultCpOptions
        };
    }
    validateObject(options, "options");
    options = {
        ...defaultCpOptions,
        ...options
    };
    validateBoolean(options.dereference, "options.dereference");
    validateBoolean(options.errorOnExist, "options.errorOnExist");
    validateBoolean(options.force, "options.force");
    validateBoolean(options.preserveTimestamps, "options.preserveTimestamps");
    validateBoolean(options.recursive, "options.recursive");
    if (options.filter !== undefined) {
        validateFunction(options.filter, "options.filter");
    }
    return options;
});
const validateRmOptions = hideStackFrames((path, options, expectDir, cb)=>{
    options = validateRmdirOptions(options, defaultRmOptions);
    validateBoolean(options.force, "options.force");
    stat(path, (err, stats)=>{
        if (err) {
            if (options.force && err.code === "ENOENT") {
                return cb(null, options);
            }
            return cb(err, options);
        }
        if (expectDir && !stats.isDirectory()) {
            return cb(false);
        }
        if (stats.isDirectory() && !options.recursive) {
            return cb(new ERR_FS_EISDIR({
                code: "EISDIR",
                message: "is a directory",
                path,
                syscall: "rm",
                errno: EISDIR
            }));
        }
        return cb(null, options);
    });
});
hideStackFrames((path, options, expectDir)=>{
    options = validateRmdirOptions(options, defaultRmOptions);
    validateBoolean(options.force, "options.force");
    if (!options.force || expectDir || !options.recursive) {
        const isDirectory = statSync(path, {
            throwIfNoEntry: !options.force
        })?.isDirectory();
        if (expectDir && !isDirectory) {
            return false;
        }
        if (isDirectory && !options.recursive) {
            throw new ERR_FS_EISDIR({
                code: "EISDIR",
                message: "is a directory",
                path,
                syscall: "rm",
                errno: EISDIR
            });
        }
    }
    return options;
});
let recursiveRmdirWarned = process2.noDeprecation;
function emitRecursiveRmdirWarning() {
    if (!recursiveRmdirWarned) {
        process2.emitWarning("In future versions of Node.js, fs.rmdir(path, { recursive: true }) " + "will be removed. Use fs.rm(path, { recursive: true }) instead", "DeprecationWarning", "DEP0147");
        recursiveRmdirWarned = true;
    }
}
const validateRmdirOptions = hideStackFrames((options, defaults = defaultRmdirOptions)=>{
    if (options === undefined) {
        return defaults;
    }
    validateObject(options, "options");
    options = {
        ...defaults,
        ...options
    };
    validateBoolean(options.recursive, "options.recursive");
    validateInt32(options.retryDelay, "options.retryDelay", 0);
    validateUint32(options.maxRetries, "options.maxRetries");
    return options;
});
const getValidMode = hideStackFrames((mode, type)=>{
    let min = kMinimumAccessMode;
    let max = kMaximumAccessMode;
    let def = F_OK1;
    if (type === "copyFile") {
        min = kMinimumCopyMode;
        max = kMaximumCopyMode;
        def = mode || kDefaultCopyMode;
    } else {
        assert3(type === "access");
    }
    if (mode == null) {
        return def;
    }
    if (Number.isInteger(mode) && mode >= min && mode <= max) {
        return mode;
    }
    if (typeof mode !== "number") {
        throw new ERR_INVALID_ARG_TYPE("mode", "integer", mode);
    }
    throw new ERR_OUT_OF_RANGE("mode", `an integer >= ${min} && <= ${max}`, mode);
});
const validateStringAfterArrayBufferView = hideStackFrames((buffer, name)=>{
    if (typeof buffer === "string") {
        return;
    }
    if (typeof buffer === "object" && buffer !== null && typeof buffer.toString === "function" && Object.prototype.hasOwnProperty.call(buffer, "toString")) {
        return;
    }
    throw new ERR_INVALID_ARG_TYPE(name, [
        "string",
        "Buffer",
        "TypedArray",
        "DataView"
    ], buffer);
});
const validatePosition = hideStackFrames((position)=>{
    if (typeof position === "number") {
        validateInteger(position, "position");
    } else if (typeof position === "bigint") {
        if (!(position >= -(2n ** 63n) && position <= 2n ** 63n - 1n)) {
            throw new ERR_OUT_OF_RANGE("position", `>= ${-(2n ** 63n)} && <= ${2n ** 63n - 1n}`, position);
        }
    } else {
        throw new ERR_INVALID_ARG_TYPE("position", [
            "integer",
            "bigint"
        ], position);
    }
});
Symbol("realpathCacheKey");
const showStringCoercionDeprecation = deprecate(()=>{}, "Implicit coercion of objects with own toString property is deprecated.", "DEP0162");
function access(path, mode, callback) {
    if (typeof mode === "function") {
        callback = mode;
        mode = fs.F_OK;
    }
    path = getValidatedPath(path).toString();
    mode = getValidMode(mode, "access");
    const cb = makeCallback(callback);
    Deno.lstat(path).then((info)=>{
        if (info.mode === null) {
            cb(null);
            return;
        }
        const m = +mode || 0;
        let fileMode = +info.mode || 0;
        if (Deno.build.os !== "windows" && info.uid === Deno.uid()) {
            fileMode >>= 6;
        }
        if ((m & fileMode) === m) {
            cb(null);
        } else {
            const e = new Error(`EACCES: permission denied, access '${path}'`);
            e.path = path;
            e.syscall = "access";
            e.errno = codeMap.get("EACCES");
            e.code = "EACCES";
            cb(e);
        }
    }, (err)=>{
        if (err instanceof Deno.errors.NotFound) {
            const e = new Error(`ENOENT: no such file or directory, access '${path}'`);
            e.path = path;
            e.syscall = "access";
            e.errno = codeMap.get("ENOENT");
            e.code = "ENOENT";
            cb(e);
        } else {
            cb(err);
        }
    });
}
const accessPromise = promisify(access);
function writeFile(pathOrRid, data, optOrCallback, callback) {
    const callbackFn = optOrCallback instanceof Function ? optOrCallback : callback;
    const options = optOrCallback instanceof Function ? undefined : optOrCallback;
    if (!callbackFn) {
        throw new TypeError("Callback must be a function.");
    }
    pathOrRid = pathOrRid instanceof URL ? fromFileUrl8(pathOrRid) : pathOrRid;
    const flag = isFileOptions(options) ? options.flag : undefined;
    const mode = isFileOptions(options) ? options.mode : undefined;
    const encoding = checkEncoding(getEncoding(options)) || "utf8";
    const openOptions = getOpenOptions(flag || "w");
    if (!ArrayBuffer.isView(data)) {
        validateStringAfterArrayBufferView(data, "data");
        if (typeof data !== "string") {
            showStringCoercionDeprecation();
        }
        data = Buffer.from(String(data), encoding);
    }
    const isRid = typeof pathOrRid === "number";
    let file;
    let error = null;
    (async ()=>{
        try {
            file = isRid ? new Deno.FsFile(pathOrRid) : await Deno.open(pathOrRid, openOptions);
            if (!isRid && mode && !isWindows1) {
                await Deno.chmod(pathOrRid, mode);
            }
            const signal = isFileOptions(options) ? options.signal : undefined;
            await writeAll1(file, data, {
                signal
            });
        } catch (e) {
            error = e instanceof Error ? denoErrorToNodeError(e, {
                syscall: "write"
            }) : new Error("[non-error thrown]");
        } finally{
            if (!isRid && file) file.close();
            callbackFn(error);
        }
    })();
}
const writeFilePromise = promisify(writeFile);
function writeFileSync(pathOrRid, data, options) {
    pathOrRid = pathOrRid instanceof URL ? fromFileUrl8(pathOrRid) : pathOrRid;
    const flag = isFileOptions(options) ? options.flag : undefined;
    const mode = isFileOptions(options) ? options.mode : undefined;
    const encoding = checkEncoding(getEncoding(options)) || "utf8";
    const openOptions = getOpenOptions(flag || "w");
    if (!ArrayBuffer.isView(data)) {
        validateStringAfterArrayBufferView(data, "data");
        if (typeof data !== "string") {
            showStringCoercionDeprecation();
        }
        data = Buffer.from(String(data), encoding);
    }
    const isRid = typeof pathOrRid === "number";
    let file;
    let error = null;
    try {
        file = isRid ? new Deno.FsFile(pathOrRid) : Deno.openSync(pathOrRid, openOptions);
        if (!isRid && mode && !isWindows1) {
            Deno.chmodSync(pathOrRid, mode);
        }
        writeAllSync(file, data);
    } catch (e) {
        error = e instanceof Error ? denoErrorToNodeError(e, {
            syscall: "write"
        }) : new Error("[non-error thrown]");
    } finally{
        if (!isRid && file) file.close();
    }
    if (error) throw error;
}
async function writeAll1(w, arr, options = {}) {
    const { offset =0 , length =arr.byteLength , signal  } = options;
    checkAborted(signal);
    const written = await w.write(arr.subarray(offset, offset + length));
    if (written === length) {
        return;
    }
    await writeAll1(w, arr, {
        offset: offset + written,
        length: length - written,
        signal
    });
}
function checkAborted(signal) {
    if (signal?.aborted) {
        throw new AbortError();
    }
}
function appendFile(path, data, options, callback) {
    callback = maybeCallback(callback || options);
    options = getOptions1(options, {
        encoding: "utf8",
        mode: 0o666,
        flag: "a"
    });
    options = copyObject(options);
    if (!options.flag || isUint32(path)) {
        options.flag = "a";
    }
    writeFile(path, data, options, callback);
}
const appendFilePromise = promisify(appendFile);
function chmod(path, mode, callback) {
    path = getValidatedPath(path).toString();
    mode = parseFileMode(mode, "mode");
    Deno.chmod(toNamespacedPath5(path), mode).catch((error)=>{
        if (!(error instanceof Deno.errors.NotSupported)) {
            throw error;
        }
    }).then(()=>callback(null), callback);
}
const chmodPromise = promisify(chmod);
function chown(path, uid, gid, callback) {
    callback = makeCallback(callback);
    path = getValidatedPath(path).toString();
    validateInteger(uid, "uid", -1, kMaxUserId);
    validateInteger(gid, "gid", -1, kMaxUserId);
    Deno.chown(toNamespacedPath5(path), uid, gid).then(()=>callback(null), callback);
}
const chownPromise = promisify(chown);
function close(fd, callback) {
    fd = getValidatedFd(fd);
    setTimeout(()=>{
        let error = null;
        try {
            Deno.close(fd);
        } catch (err) {
            error = err instanceof Error ? err : new Error("[non-error thrown]");
        }
        callback(error);
    }, 0);
}
function copyFile(src, dest, mode, callback) {
    if (typeof mode === "function") {
        callback = mode;
        mode = 0;
    }
    const srcStr = getValidatedPath(src, "src").toString();
    const destStr = getValidatedPath(dest, "dest").toString();
    const modeNum = getValidMode(mode, "copyFile");
    const cb = makeCallback(callback);
    if ((modeNum & fs.COPYFILE_EXCL) === fs.COPYFILE_EXCL) {
        Deno.lstat(destStr).then(()=>{
            const e = new Error(`EEXIST: file already exists, copyfile '${srcStr}' -> '${destStr}'`);
            e.syscall = "copyfile";
            e.errno = codeMap.get("EEXIST");
            e.code = "EEXIST";
            cb(e);
        }, (e)=>{
            if (e instanceof Deno.errors.NotFound) {
                Deno.copyFile(srcStr, destStr).then(()=>cb(null), cb);
            }
            cb(e);
        });
    } else {
        Deno.copyFile(srcStr, destStr).then(()=>cb(null), cb);
    }
}
const copyFilePromise = promisify(copyFile);
class Dirent1 {
    entry;
    constructor(entry){
        this.entry = entry;
    }
    isBlockDevice() {
        notImplemented("Deno does not yet support identification of block devices");
        return false;
    }
    isCharacterDevice() {
        notImplemented("Deno does not yet support identification of character devices");
        return false;
    }
    isDirectory() {
        return this.entry.isDirectory;
    }
    isFIFO() {
        notImplemented("Deno does not yet support identification of FIFO named pipes");
        return false;
    }
    isFile() {
        return this.entry.isFile;
    }
    isSocket() {
        notImplemented("Deno does not yet support identification of sockets");
        return false;
    }
    isSymbolicLink() {
        return this.entry.isSymlink;
    }
    get name() {
        return this.entry.name;
    }
}
class Dir {
    #dirPath;
    #syncIterator;
    #asyncIterator;
    constructor(path){
        if (!path) {
            throw new ERR_MISSING_ARGS("path");
        }
        this.#dirPath = path;
    }
    get path() {
        if (this.#dirPath instanceof Uint8Array) {
            return new TextDecoder().decode(this.#dirPath);
        }
        return this.#dirPath;
    }
    read(callback) {
        return new Promise((resolve, reject)=>{
            if (!this.#asyncIterator) {
                this.#asyncIterator = Deno.readDir(this.path)[Symbol.asyncIterator]();
            }
            assert1(this.#asyncIterator);
            this.#asyncIterator.next().then((iteratorResult)=>{
                resolve(iteratorResult.done ? null : new Dirent1(iteratorResult.value));
                if (callback) {
                    callback(null, iteratorResult.done ? null : new Dirent1(iteratorResult.value));
                }
            }, (err)=>{
                if (callback) {
                    callback(err);
                }
                reject(err);
            });
        });
    }
    readSync() {
        if (!this.#syncIterator) {
            this.#syncIterator = Deno.readDirSync(this.path)[Symbol.iterator]();
        }
        const iteratorResult = this.#syncIterator.next();
        if (iteratorResult.done) {
            return null;
        } else {
            return new Dirent1(iteratorResult.value);
        }
    }
    close(callback) {
        return new Promise((resolve)=>{
            if (callback) {
                callback(null);
            }
            resolve();
        });
    }
    closeSync() {}
    async *[Symbol.asyncIterator]() {
        try {
            while(true){
                const dirent = await this.read();
                if (dirent === null) {
                    break;
                }
                yield dirent;
            }
        } finally{
            await this.close();
        }
    }
}
function exists(path, callback) {
    path = path instanceof URL ? fromFileUrl8(path) : path;
    Deno.lstat(path).then(()=>callback(true), ()=>callback(false));
}
const kCustomPromisifiedSymbol1 = Symbol.for("nodejs.util.promisify.custom");
Object.defineProperty(exists, kCustomPromisifiedSymbol1, {
    value: (path)=>{
        return new Promise((resolve)=>{
            exists(path, (exists)=>resolve(exists));
        });
    }
});
function existsSync(path) {
    path = path instanceof URL ? fromFileUrl8(path) : path;
    try {
        Deno.lstatSync(path);
        return true;
    } catch (_err) {
        return false;
    }
}
function link(existingPath, newPath, callback) {
    existingPath = existingPath instanceof URL ? fromFileUrl8(existingPath) : existingPath;
    newPath = newPath instanceof URL ? fromFileUrl8(newPath) : newPath;
    Deno.link(existingPath, newPath).then(()=>callback(null), callback);
}
const linkPromise = promisify(link);
function mkdir(path, options, callback) {
    path = getValidatedPath(path);
    let mode = 0o777;
    let recursive = false;
    if (typeof options == "function") {
        callback = options;
    } else if (typeof options === "number") {
        mode = options;
    } else if (typeof options === "boolean") {
        recursive = options;
    } else if (options) {
        if (options.recursive !== undefined) recursive = options.recursive;
        if (options.mode !== undefined) mode = options.mode;
    }
    validateBoolean(recursive, "options.recursive");
    Deno.mkdir(path, {
        recursive,
        mode
    }).then(()=>{
        if (typeof callback === "function") {
            callback(null);
        }
    }, (err)=>{
        if (typeof callback === "function") {
            callback(err);
        }
    });
}
const mkdirPromise = promisify(mkdir);
function mkdtemp(prefix, optionsOrCallback, maybeCallback) {
    const callback = typeof optionsOrCallback == "function" ? optionsOrCallback : maybeCallback;
    if (!callback) {
        throw new ERR_INVALID_ARG_TYPE("callback", "function", callback);
    }
    const encoding = parseEncoding(optionsOrCallback);
    const path = tempDirPath(prefix);
    mkdir(path, {
        recursive: false,
        mode: 0o700
    }, (err)=>{
        if (err) callback(err);
        else callback(null, decode2(path, encoding));
    });
}
const mkdtempPromise = promisify(mkdtemp);
function parseEncoding(optionsOrCallback) {
    let encoding;
    if (typeof optionsOrCallback == "function") encoding = undefined;
    else if (optionsOrCallback instanceof Object) {
        encoding = optionsOrCallback?.encoding;
    } else encoding = optionsOrCallback;
    if (encoding) {
        try {
            new TextDecoder(encoding);
        } catch  {
            throw new ERR_INVALID_OPT_VALUE_ENCODING(encoding);
        }
    }
    return encoding;
}
function decode2(str, encoding) {
    if (!encoding) return str;
    else {
        const decoder = new TextDecoder(encoding);
        const encoder = new TextEncoder();
        return decoder.decode(encoder.encode(str));
    }
}
const CHARS = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function randomName() {
    return [
        ...Array(6)
    ].map(()=>CHARS[Math.floor(Math.random() * CHARS.length)]).join("");
}
function tempDirPath(prefix) {
    let path;
    do {
        path = prefix + randomName();
    }while (existsSync(path))
    return path;
}
function existsSync1(filePath) {
    try {
        Deno.lstatSync(filePath);
        return true;
    } catch (error) {
        if (error instanceof Deno.errors.NotFound) {
            return false;
        }
        throw error;
    }
}
const FLAGS_AX = O_APPEND | O_CREAT | O_WRONLY | O_EXCL;
const FLAGS_AX_PLUS = O_APPEND | O_CREAT | O_RDWR | O_EXCL;
const FLAGS_WX = O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;
const FLAGS_WX_PLUS = O_TRUNC | O_CREAT | O_RDWR | O_EXCL;
function convertFlagAndModeToOptions(flag, mode) {
    if (!flag && !mode) return undefined;
    if (!flag && mode) return {
        mode
    };
    return {
        ...getOpenOptions(flag),
        mode
    };
}
function open(path, flags, mode, callback) {
    if (flags === undefined) {
        throw new ERR_INVALID_ARG_TYPE("flags or callback", [
            "string",
            "function"
        ], flags);
    }
    path = getValidatedPath(path);
    if (arguments.length < 3) {
        callback = flags;
        flags = "r";
        mode = 0o666;
    } else if (typeof mode === "function") {
        callback = mode;
        mode = 0o666;
    } else {
        mode = parseFileMode(mode, "mode", 0o666);
    }
    if (typeof callback !== "function") {
        throw new ERR_INVALID_ARG_TYPE("callback", "function", callback);
    }
    if (flags === undefined) {
        flags = "r";
    }
    if (existenceCheckRequired(flags) && existsSync1(path)) {
        const err = new Error(`EEXIST: file already exists, open '${path}'`);
        callback(err);
    } else {
        if (flags === "as" || flags === "as+") {
            let err = null, res;
            try {
                res = openSync(path, flags, mode);
            } catch (error) {
                err = error instanceof Error ? error : new Error("[non-error thrown]");
            }
            if (err) {
                callback(err);
            } else {
                callback(null, res);
            }
            return;
        }
        Deno.open(path, convertFlagAndModeToOptions(flags, mode)).then((file)=>callback(null, file.rid), (err)=>callback(err));
    }
}
const openPromise = promisify(open);
function openSync(path, flags, maybeMode) {
    const mode = parseFileMode(maybeMode, "mode", 0o666);
    path = getValidatedPath(path);
    if (flags === undefined) {
        flags = "r";
    }
    if (existenceCheckRequired(flags) && existsSync1(path)) {
        throw new Error(`EEXIST: file already exists, open '${path}'`);
    }
    return Deno.openSync(path, convertFlagAndModeToOptions(flags, mode)).rid;
}
function existenceCheckRequired(flags) {
    return typeof flags === "string" && [
        "ax",
        "ax+",
        "wx",
        "wx+"
    ].includes(flags) || typeof flags === "number" && ((flags & FLAGS_AX) === FLAGS_AX || (flags & FLAGS_AX_PLUS) === FLAGS_AX_PLUS || (flags & FLAGS_WX) === FLAGS_WX || (flags & FLAGS_WX_PLUS) === FLAGS_WX_PLUS);
}
function _validateFunction(callback) {
    validateFunction(callback, "callback");
}
function opendir(path, options, callback) {
    callback = typeof options === "function" ? options : callback;
    _validateFunction(callback);
    path = getValidatedPath(path).toString();
    let err, dir;
    try {
        const { bufferSize  } = getOptions1(options, {
            encoding: "utf8",
            bufferSize: 32
        });
        validateInteger(bufferSize, "options.bufferSize", 1, 4294967295);
        Deno.readDirSync(path);
        dir = new Dir(path);
    } catch (error) {
        err = denoErrorToNodeError(error, {
            syscall: "opendir"
        });
    }
    if (err) {
        callback(err);
    } else {
        callback(null, dir);
    }
}
const opendirPromise = promisify(opendir);
function read(fd, optOrBufferOrCb, offsetOrCallback, length, position, callback) {
    let cb;
    let offset = 0, buffer;
    if (typeof fd !== "number") {
        throw new ERR_INVALID_ARG_TYPE("fd", "number", fd);
    }
    if (length == null) {
        length = 0;
    }
    if (typeof offsetOrCallback === "function") {
        cb = offsetOrCallback;
    } else if (typeof optOrBufferOrCb === "function") {
        cb = optOrBufferOrCb;
    } else {
        offset = offsetOrCallback;
        validateInteger(offset, "offset", 0);
        cb = callback;
    }
    if (optOrBufferOrCb instanceof Buffer || optOrBufferOrCb instanceof Uint8Array) {
        buffer = optOrBufferOrCb;
    } else if (typeof optOrBufferOrCb === "function") {
        offset = 0;
        buffer = Buffer.alloc(16384);
        length = buffer.byteLength;
        position = null;
    } else {
        const opt = optOrBufferOrCb;
        if (!(opt.buffer instanceof Buffer) && !(opt.buffer instanceof Uint8Array)) {
            if (opt.buffer === null) {
                length = opt.buffer.byteLength;
            }
            throw new ERR_INVALID_ARG_TYPE("buffer", [
                "Buffer",
                "TypedArray",
                "DataView"
            ], optOrBufferOrCb);
        }
        offset = opt.offset ?? 0;
        buffer = opt.buffer ?? Buffer.alloc(16384);
        length = opt.length ?? buffer.byteLength;
        position = opt.position ?? null;
    }
    if (position == null) {
        position = -1;
    }
    validatePosition(position);
    validateOffsetLengthRead(offset, length, buffer.byteLength);
    if (!cb) throw new ERR_INVALID_ARG_TYPE("cb", "Callback", cb);
    (async ()=>{
        try {
            let nread;
            if (typeof position === "number" && position >= 0) {
                const currentPosition = await Deno.seek(fd, 0, Deno.SeekMode.Current);
                Deno.seekSync(fd, position, Deno.SeekMode.Start);
                nread = Deno.readSync(fd, buffer);
                Deno.seekSync(fd, currentPosition, Deno.SeekMode.Start);
            } else {
                nread = await Deno.read(fd, buffer);
            }
            cb(null, nread ?? 0, Buffer.from(buffer.buffer, offset, length));
        } catch (error) {
            cb(error, null);
        }
    })();
}
const statPromisified = promisify(stat);
const statAsync = async (filename)=>{
    try {
        return await statPromisified(filename);
    } catch  {
        return emptyStats;
    }
};
const emptyStats = new Stats(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, Date.UTC(1970, 0, 1, 0, 0, 0), Date.UTC(1970, 0, 1, 0, 0, 0), Date.UTC(1970, 0, 1, 0, 0, 0), Date.UTC(1970, 0, 1, 0, 0, 0));
function asyncIterableToCallback(iter, callback, errCallback) {
    const iterator = iter[Symbol.asyncIterator]();
    function next() {
        iterator.next().then((obj)=>{
            if (obj.done) {
                callback(obj.value, true);
                return;
            }
            callback(obj.value);
            next();
        }, errCallback);
    }
    next();
}
function watch(filename, optionsOrListener, optionsOrListener2) {
    const listener = typeof optionsOrListener === "function" ? optionsOrListener : typeof optionsOrListener2 === "function" ? optionsOrListener2 : undefined;
    const options = typeof optionsOrListener === "object" ? optionsOrListener : typeof optionsOrListener2 === "object" ? optionsOrListener2 : undefined;
    const watchPath = getValidatedPath(filename).toString();
    let iterator;
    const timer = setTimeout(()=>{
        iterator = Deno.watchFs(watchPath, {
            recursive: options?.recursive || false
        });
        asyncIterableToCallback(iterator, (val, done)=>{
            if (done) return;
            fsWatcher.emit("change", convertDenoFsEventToNodeFsEvent(val.kind), basename8(val.paths[0]));
        }, (e)=>{
            fsWatcher.emit("error", e);
        });
    }, 5);
    const fsWatcher = new FSWatcher(()=>{
        clearTimeout(timer);
        try {
            iterator?.close();
        } catch (e) {
            if (e instanceof Deno.errors.BadResource) {
                return;
            }
            throw e;
        }
    });
    if (listener) {
        fsWatcher.on("change", listener.bind({
            _handle: fsWatcher
        }));
    }
    return fsWatcher;
}
const watchPromise = promisify(watch);
new Map();
const kFSStatWatcherStart = Symbol("kFSStatWatcherStart");
const kFSStatWatcherAddOrCleanRef = Symbol("kFSStatWatcherAddOrCleanRef");
class StatWatcher extends EventEmitter {
    #bigint;
    #refCount = 0;
    #abortController = new AbortController();
    constructor(bigint){
        super();
        this.#bigint = bigint;
    }
    [kFSStatWatcherStart](filename, persistent, interval) {
        if (persistent) {
            this.#refCount++;
        }
        (async ()=>{
            let prev = await statAsync(filename);
            if (prev === emptyStats) {
                this.emit("change", prev, prev);
            }
            try {
                while(true){
                    await delay(interval, {
                        signal: this.#abortController.signal
                    });
                    const curr = await statAsync(filename);
                    if (curr?.mtime !== prev?.mtime) {
                        this.emit("change", curr, prev);
                        prev = curr;
                    }
                }
            } catch (e) {
                if (e instanceof DOMException && e.name === "AbortError") {
                    return;
                }
                this.emit("error", e);
            }
        })();
    }
    [kFSStatWatcherAddOrCleanRef](addOrClean) {
        if (addOrClean === "add") {
            this.#refCount++;
        } else if (addOrClean === "clean") {
            this.#refCount--;
        } else {
            this.#refCount = 0;
        }
    }
    stop() {
        if (this.#abortController.signal.aborted) {
            return;
        }
        this.#abortController.abort();
        this.emit("stop");
    }
    ref() {
        notImplemented("FSWatcher.ref() is not implemented");
    }
    unref() {
        notImplemented("FSWatcher.unref() is not implemented");
    }
}
class FSWatcher extends EventEmitter {
    #closer;
    #closed = false;
    constructor(closer){
        super();
        this.#closer = closer;
    }
    close() {
        if (this.#closed) {
            return;
        }
        this.#closed = true;
        this.emit("close");
        this.#closer();
    }
    ref() {
        notImplemented("FSWatcher.ref() is not implemented");
    }
    unref() {
        notImplemented("FSWatcher.unref() is not implemented");
    }
}
function convertDenoFsEventToNodeFsEvent(kind) {
    if (kind === "create" || kind === "remove") {
        return "rename";
    } else {
        return "change";
    }
}
function toDirent(val) {
    return new Dirent1(val);
}
function readdir(path, optionsOrCallback, maybeCallback) {
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback;
    const options = typeof optionsOrCallback === "object" ? optionsOrCallback : null;
    const result = [];
    path = getValidatedPath(path);
    if (!callback) throw new Error("No callback function supplied");
    if (options?.encoding) {
        try {
            new TextDecoder(options.encoding);
        } catch  {
            throw new Error(`TypeError [ERR_INVALID_OPT_VALUE_ENCODING]: The value "${options.encoding}" is invalid for option "encoding"`);
        }
    }
    try {
        asyncIterableToCallback(Deno.readDir(path.toString()), (val, done)=>{
            if (typeof path !== "string") return;
            if (done) {
                callback(null, result);
                return;
            }
            if (options?.withFileTypes) {
                result.push(toDirent(val));
            } else result.push(decode3(val.name));
        }, (e)=>{
            callback(denoErrorToNodeError(e, {
                syscall: "readdir"
            }));
        });
    } catch (e) {
        callback(denoErrorToNodeError(e, {
            syscall: "readdir"
        }));
    }
}
function decode3(str, encoding) {
    if (!encoding) return str;
    else {
        const decoder = new TextDecoder(encoding);
        const encoder = new TextEncoder();
        return decoder.decode(encoder.encode(str));
    }
}
const readdirPromise = promisify(readdir);
function maybeDecode(data, encoding) {
    const buffer = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
    if (encoding && encoding !== "binary") return buffer.toString(encoding);
    return buffer;
}
function readFile(path, optOrCallback, callback) {
    path = path instanceof URL ? fromFileUrl8(path) : path;
    let cb;
    if (typeof optOrCallback === "function") {
        cb = optOrCallback;
    } else {
        cb = callback;
    }
    const encoding = getEncoding(optOrCallback);
    const p = Deno.readFile(path);
    if (cb) {
        p.then((data)=>{
            if (encoding && encoding !== "binary") {
                const text = maybeDecode(data, encoding);
                return cb(null, text);
            }
            const buffer = maybeDecode(data, encoding);
            cb(null, buffer);
        }, (err)=>cb && cb(err));
    }
}
const readFilePromise = promisify(readFile);
function maybeEncode(data, encoding) {
    if (encoding === "buffer") {
        return new TextEncoder().encode(data);
    }
    return data;
}
function getEncoding1(optOrCallback) {
    if (!optOrCallback || typeof optOrCallback === "function") {
        return null;
    } else {
        if (optOrCallback.encoding) {
            if (optOrCallback.encoding === "utf8" || optOrCallback.encoding === "utf-8") {
                return "utf8";
            } else if (optOrCallback.encoding === "buffer") {
                return "buffer";
            } else {
                notImplemented(`fs.readlink encoding=${optOrCallback.encoding}`);
            }
        }
        return null;
    }
}
function readlink(path, optOrCallback, callback) {
    path = path instanceof URL ? fromFileUrl8(path) : path;
    let cb;
    if (typeof optOrCallback === "function") {
        cb = optOrCallback;
    } else {
        cb = callback;
    }
    const encoding = getEncoding1(optOrCallback);
    intoCallbackAPIWithIntercept(Deno.readLink, (data)=>maybeEncode(data, encoding), cb, path);
}
const readlinkPromise = promisify(readlink);
function realpath(path, options, callback) {
    if (typeof options === "function") {
        callback = options;
    }
    if (!callback) {
        throw new Error("No callback function supplied");
    }
    Deno.realPath(path).then((path)=>callback(null, path), (err)=>callback(err));
}
realpath.native = realpath;
const realpathPromise = promisify(realpath);
function realpathSync(path) {
    return Deno.realPathSync(path);
}
realpathSync.native = realpathSync;
function rename(oldPath, newPath, callback) {
    oldPath = oldPath instanceof URL ? fromFileUrl8(oldPath) : oldPath;
    newPath = newPath instanceof URL ? fromFileUrl8(newPath) : newPath;
    if (!callback) throw new Error("No callback function supplied");
    Deno.rename(oldPath, newPath).then((_)=>callback(), callback);
}
const renamePromise = promisify(rename);
function rmdir(path, optionsOrCallback, maybeCallback) {
    path = toNamespacedPath8(getValidatedPath(path));
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback;
    const options = typeof optionsOrCallback === "object" ? optionsOrCallback : undefined;
    if (!callback) throw new Error("No callback function supplied");
    if (options?.recursive) {
        emitRecursiveRmdirWarning();
        validateRmOptions(path, {
            ...options,
            force: false
        }, true, (err, options)=>{
            if (err === false) {
                return callback(new ERR_FS_RMDIR_ENOTDIR(path.toString()));
            }
            if (err) {
                return callback(err);
            }
            Deno.remove(path, {
                recursive: options?.recursive
            }).then((_)=>callback(), callback);
        });
    } else {
        validateRmdirOptions(options);
        Deno.remove(path, {
            recursive: options?.recursive
        }).then((_)=>callback(), (err)=>{
            callback(err instanceof Error ? denoErrorToNodeError(err, {
                syscall: "rmdir"
            }) : err);
        });
    }
}
const rmdirPromise = promisify(rmdir);
function rm(path, optionsOrCallback, maybeCallback) {
    const callback = typeof optionsOrCallback === "function" ? optionsOrCallback : maybeCallback;
    const options = typeof optionsOrCallback === "object" ? optionsOrCallback : undefined;
    if (!callback) throw new Error("No callback function supplied");
    validateRmOptions(path, options, false, (err, options)=>{
        if (err) {
            return callback(err);
        }
        Deno.remove(path, {
            recursive: options?.recursive
        }).then((_)=>callback(null), (err)=>{
            if (options?.force && err instanceof Deno.errors.NotFound) {
                callback(null);
            } else {
                callback(err instanceof Error ? denoErrorToNodeError(err, {
                    syscall: "rm"
                }) : err);
            }
        });
    });
}
const rmPromise = promisify(rm);
function symlink(target, path, typeOrCallback, maybeCallback) {
    target = target instanceof URL ? fromFileUrl8(target) : target;
    path = path instanceof URL ? fromFileUrl8(path) : path;
    const type = typeof typeOrCallback === "string" ? typeOrCallback : "file";
    const callback = typeof typeOrCallback === "function" ? typeOrCallback : maybeCallback;
    if (!callback) throw new Error("No callback function supplied");
    Deno.symlink(target, path, {
        type
    }).then(()=>callback(null), callback);
}
const symlinkPromise = promisify(symlink);
function truncate(path, lenOrCallback, maybeCallback) {
    path = path instanceof URL ? fromFileUrl8(path) : path;
    const len = typeof lenOrCallback === "number" ? lenOrCallback : undefined;
    const callback = typeof lenOrCallback === "function" ? lenOrCallback : maybeCallback;
    if (!callback) throw new Error("No callback function supplied");
    Deno.truncate(path, len).then(()=>callback(null), callback);
}
const truncatePromise = promisify(truncate);
function unlink(path, callback) {
    if (!callback) throw new Error("No callback function supplied");
    Deno.remove(path).then((_)=>callback(), callback);
}
const unlinkPromise = promisify(unlink);
function getValidTime(time, name) {
    if (typeof time === "string") {
        time = Number(time);
    }
    if (typeof time === "number" && (Number.isNaN(time) || !Number.isFinite(time))) {
        throw new Deno.errors.InvalidData(`invalid ${name}, must not be infinity or NaN`);
    }
    return time;
}
function utimes(path, atime, mtime, callback) {
    path = path instanceof URL ? fromFileUrl8(path) : path;
    if (!callback) {
        throw new Deno.errors.InvalidData("No callback function supplied");
    }
    atime = getValidTime(atime, "atime");
    mtime = getValidTime(mtime, "mtime");
    Deno.utime(path, atime, mtime).then(()=>callback(null), callback);
}
const utimesPromise = promisify(utimes);
function write(fd, buffer, offset, length, position, callback) {
    fd = getValidatedFd(fd);
    const innerWrite = async (fd, buffer, offset, length, position)=>{
        if (buffer instanceof DataView) {
            buffer = new Uint8Array(buffer.buffer);
        }
        if (typeof position === "number") {
            await Deno.seek(fd, position, Deno.SeekMode.Start);
        }
        let currentOffset = offset;
        const end = offset + length;
        while(currentOffset - offset < length){
            currentOffset += await Deno.write(fd, buffer.subarray(currentOffset, end));
        }
        return currentOffset - offset;
    };
    if (isArrayBufferView(buffer)) {
        callback = maybeCallback(callback || position || length || offset);
        if (offset == null || typeof offset === "function") {
            offset = 0;
        } else {
            validateInteger(offset, "offset", 0);
        }
        if (typeof length !== "number") {
            length = buffer.byteLength - offset;
        }
        if (typeof position !== "number") {
            position = null;
        }
        validateOffsetLengthWrite(offset, length, buffer.byteLength);
        innerWrite(fd, buffer, offset, length, position).then((nwritten)=>{
            callback(null, nwritten, buffer);
        }, (err)=>callback(err));
        return;
    }
    validateStringAfterArrayBufferView(buffer, "buffer");
    if (typeof buffer !== "string") {
        showStringCoercionDeprecation();
    }
    if (typeof position !== "function") {
        if (typeof offset === "function") {
            position = offset;
            offset = null;
        } else {
            position = length;
        }
        length = "utf-8";
    }
    const str = String(buffer);
    validateEncoding(str, length);
    callback = maybeCallback(position);
    buffer = Buffer.from(str, length);
    innerWrite(fd, buffer, 0, buffer.length, offset, callback).then((nwritten)=>{
        callback(null, nwritten, buffer);
    }, (err)=>callback(err));
}
function writev(fd, buffers, position, callback) {
    const innerWritev = async (fd, buffers, position)=>{
        const chunks = [];
        for(let i = 0; i < buffers.length; i++){
            if (Buffer.isBuffer(buffers[i])) {
                chunks.push(buffers[i]);
            } else {
                chunks.push(Buffer.from(buffers[i]));
            }
        }
        if (typeof position === "number") {
            await Deno.seekSync(fd, position, Deno.SeekMode.Start);
        }
        const buffer = Buffer.concat(chunks);
        let currentOffset = 0;
        while(currentOffset < buffer.byteLength){
            currentOffset += await Deno.writeSync(fd, buffer.subarray(currentOffset));
        }
        return currentOffset - 0;
    };
    fd = getValidatedFd(fd);
    validateBufferArray(buffers);
    callback = maybeCallback(callback || position);
    if (buffers.length === 0) {
        process.nextTick(callback, null, 0, buffers);
        return;
    }
    if (typeof position !== "number") position = null;
    innerWritev(fd, buffers, position).then((nwritten)=>{
        callback(null, nwritten, buffers);
    }, (err)=>callback(err));
}
const kIoDone = Symbol("kIoDone");
const kIsPerformingIO = Symbol("kIsPerformingIO");
const kFs = Symbol("kFs");
function _construct(callback) {
    const stream = this;
    if (typeof stream.fd === "number") {
        callback();
        return;
    }
    if (stream.open !== openWriteFs && stream.open !== openReadFs) {
        const orgEmit = stream.emit;
        stream.emit = function(...args) {
            if (args[0] === "open") {
                this.emit = orgEmit;
                callback();
                Reflect.apply(orgEmit, this, args);
            } else if (args[0] === "error") {
                this.emit = orgEmit;
                callback(args[1]);
            } else {
                Reflect.apply(orgEmit, this, args);
            }
        };
        stream.open();
    } else {
        stream[kFs].open(stream.path.toString(), stream.flags, stream.mode, (er, fd)=>{
            if (er) {
                callback(er);
            } else {
                stream.fd = fd;
                callback();
                stream.emit("open", stream.fd);
                stream.emit("ready");
            }
        });
    }
}
function close1(stream, err, cb) {
    if (!stream.fd) {
        cb(err);
    } else {
        stream[kFs].close(stream.fd, (er)=>{
            cb(er || err);
        });
        stream.fd = null;
    }
}
function importFd(stream, options) {
    if (typeof options.fd === "number") {
        if (stream instanceof ReadStream) {
            stream[kFs] = options.fs || {
                read: read,
                close: close
            };
        }
        if (stream instanceof WriteStream) {
            stream[kFs] = options.fs || {
                write: write,
                writev: writev,
                close: close
            };
        }
        return options.fd;
    }
    throw new ERR_INVALID_ARG_TYPE("options.fd", [
        "number"
    ], options.fd);
}
function ReadStream(path, options) {
    if (!(this instanceof ReadStream)) {
        return new ReadStream(path, options);
    }
    options = copyObject(getOptions1(options, kEmptyObject));
    if (options.highWaterMark === undefined) {
        options.highWaterMark = 64 * 1024;
    }
    if (options.autoDestroy === undefined) {
        options.autoDestroy = false;
    }
    if (options.fd == null) {
        this.fd = null;
        this[kFs] = options.fs || {
            open: open,
            read: read,
            close: close
        };
        validateFunction(this[kFs].open, "options.fs.open");
        this.path = toPathIfFileURL(path);
        this.flags = options.flags === undefined ? "r" : options.flags;
        this.mode = options.mode === undefined ? 0o666 : options.mode;
        validatePath(this.path);
    } else {
        this.fd = getValidatedFd(importFd(this, options));
    }
    options.autoDestroy = options.autoClose === undefined ? true : options.autoClose;
    validateFunction(this[kFs].read, "options.fs.read");
    if (options.autoDestroy) {
        validateFunction(this[kFs].close, "options.fs.close");
    }
    this.start = options.start;
    this.end = options.end ?? Infinity;
    this.pos = undefined;
    this.bytesRead = 0;
    this[kIsPerformingIO] = false;
    if (this.start !== undefined) {
        validateInteger(this.start, "start", 0);
        this.pos = this.start;
    }
    if (this.end !== Infinity) {
        validateInteger(this.end, "end", 0);
        if (this.start !== undefined && this.start > this.end) {
            throw new ERR_OUT_OF_RANGE("start", `<= "end" (here: ${this.end})`, this.start);
        }
    }
    Reflect.apply(Au, this, [
        options
    ]);
}
Object.setPrototypeOf(ReadStream.prototype, Au.prototype);
Object.setPrototypeOf(ReadStream, Au);
Object.defineProperty(ReadStream.prototype, "autoClose", {
    get () {
        return this._readableState.autoDestroy;
    },
    set (val) {
        this._readableState.autoDestroy = val;
    }
});
const openReadFs = deprecate(function() {}, "ReadStream.prototype.open() is deprecated", "DEP0135");
ReadStream.prototype.open = openReadFs;
ReadStream.prototype._construct = _construct;
ReadStream.prototype._read = async function(n) {
    n = this.pos !== undefined ? Math.min(this.end - this.pos + 1, n) : Math.min(this.end - this.bytesRead + 1, n);
    if (n <= 0) {
        this.push(null);
        return;
    }
    const buf = Buffer.allocUnsafeSlow(n);
    let error = null;
    let bytesRead = null;
    let buffer = undefined;
    this[kIsPerformingIO] = true;
    await new Promise((resolve)=>{
        this[kFs].read(this.fd, buf, 0, n, this.pos ?? null, (_er, _bytesRead, _buf)=>{
            error = _er;
            bytesRead = _bytesRead;
            buffer = _buf;
            return resolve(true);
        });
    });
    this[kIsPerformingIO] = false;
    if (this.destroyed) {
        this.emit(kIoDone, error);
        return;
    }
    if (error) {
        errorOrDestroy(this, error);
    } else if (typeof bytesRead === "number" && bytesRead > 0) {
        if (this.pos !== undefined) {
            this.pos += bytesRead;
        }
        this.bytesRead += bytesRead;
        if (bytesRead !== buffer.length) {
            const dst = Buffer.allocUnsafeSlow(bytesRead);
            buffer.copy(dst, 0, 0, bytesRead);
            buffer = dst;
        }
        this.push(buffer);
    } else {
        this.push(null);
    }
};
ReadStream.prototype._destroy = function(err, cb) {
    if (this[kIsPerformingIO]) {
        this.once(kIoDone, (er)=>close1(this, err || er, cb));
    } else {
        close1(this, err, cb);
    }
};
ReadStream.prototype.close = function(cb) {
    if (typeof cb === "function") Du(this, cb);
    this.destroy();
};
Object.defineProperty(ReadStream.prototype, "pending", {
    get () {
        return this.fd === null;
    },
    configurable: true
});
function WriteStream(path, options) {
    if (!(this instanceof WriteStream)) {
        return new WriteStream(path, options);
    }
    options = copyObject(getOptions1(options, kEmptyObject));
    options.decodeStrings = true;
    if (options.fd == null) {
        this.fd = null;
        this[kFs] = options.fs || {
            open: open,
            write: write,
            writev: writev,
            close: close
        };
        validateFunction(this[kFs].open, "options.fs.open");
        this.path = toPathIfFileURL(path);
        this.flags = options.flags === undefined ? "w" : options.flags;
        this.mode = options.mode === undefined ? 0o666 : options.mode;
        validatePath(this.path);
    } else {
        this.fd = getValidatedFd(importFd(this, options));
    }
    options.autoDestroy = options.autoClose === undefined ? true : options.autoClose;
    if (!this[kFs].write && !this[kFs].writev) {
        throw new ERR_INVALID_ARG_TYPE("options.fs.write", "function", this[kFs].write);
    }
    if (this[kFs].write) {
        validateFunction(this[kFs].write, "options.fs.write");
    }
    if (this[kFs].writev) {
        validateFunction(this[kFs].writev, "options.fs.writev");
    }
    if (options.autoDestroy) {
        validateFunction(this[kFs].close, "options.fs.close");
    }
    if (!this[kFs].write) {
        this._write = null;
    }
    if (!this[kFs].writev) {
        this._writev = null;
    }
    this.start = options.start;
    this.pos = undefined;
    this.bytesWritten = 0;
    this[kIsPerformingIO] = false;
    if (this.start !== undefined) {
        validateInteger(this.start, "start", 0);
        this.pos = this.start;
    }
    Reflect.apply(mu, this, [
        options
    ]);
    if (options.encoding) {
        this.setDefaultEncoding(options.encoding);
    }
}
Object.setPrototypeOf(WriteStream.prototype, mu.prototype);
Object.setPrototypeOf(WriteStream, mu);
Object.defineProperty(WriteStream.prototype, "autoClose", {
    get () {
        return this._writableState.autoDestroy;
    },
    set (val) {
        this._writableState.autoDestroy = val;
    }
});
const openWriteFs = deprecate(function() {}, "WriteStream.prototype.open() is deprecated", "DEP0135");
WriteStream.prototype.open = openWriteFs;
WriteStream.prototype._construct = _construct;
WriteStream.prototype._write = function(data, _encoding, cb) {
    this[kIsPerformingIO] = true;
    this[kFs].write(this.fd, data, 0, data.length, this.pos, (er, bytes)=>{
        this[kIsPerformingIO] = false;
        if (this.destroyed) {
            cb(er);
            return this.emit(kIoDone, er);
        }
        if (er) {
            return cb(er);
        }
        this.bytesWritten += bytes;
        cb();
    });
    if (this.pos !== undefined) {
        this.pos += data.length;
    }
};
WriteStream.prototype._writev = function(data, cb) {
    const len = data.length;
    const chunks = new Array(len);
    let size = 0;
    for(let i = 0; i < len; i++){
        const chunk = data[i].chunk;
        chunks[i] = chunk;
        size += chunk.length;
    }
    this[kIsPerformingIO] = true;
    this[kFs].writev(this.fd, chunks, this.pos ?? null, (er, bytes)=>{
        this[kIsPerformingIO] = false;
        if (this.destroyed) {
            cb(er);
            return this.emit(kIoDone, er);
        }
        if (er) {
            return cb(er);
        }
        this.bytesWritten += bytes;
        cb();
    });
    if (this.pos !== undefined) {
        this.pos += size;
    }
};
WriteStream.prototype._destroy = function(err, cb) {
    if (this[kIsPerformingIO]) {
        this.once(kIoDone, (er)=>close1(this, err || er, cb));
    } else {
        close1(this, err, cb);
    }
};
WriteStream.prototype.close = function(cb) {
    if (cb) {
        if (this.closed) {
            nextTick1(cb);
            return;
        }
        this.on("close", cb);
    }
    if (!this.autoClose) {
        this.on("finish", this.destroy);
    }
    this.end();
};
WriteStream.prototype.destroySoon = WriteStream.prototype.end;
Object.defineProperty(WriteStream.prototype, "pending", {
    get () {
        return this.fd === null;
    },
    configurable: true
});
const { F_OK: F_OK2 , R_OK: R_OK2 , W_OK: W_OK2 , X_OK: X_OK2 , O_RDONLY: O_RDONLY2 , O_WRONLY: O_WRONLY2 , O_RDWR: O_RDWR2 , O_NOCTTY: O_NOCTTY1 , O_TRUNC: O_TRUNC2 , O_APPEND: O_APPEND2 , O_DIRECTORY: O_DIRECTORY1 , O_NOFOLLOW: O_NOFOLLOW1 , O_SYNC: O_SYNC2 , O_DSYNC: O_DSYNC1 , O_SYMLINK: O_SYMLINK1 , O_NONBLOCK: O_NONBLOCK1 , O_CREAT: O_CREAT2 , O_EXCL: O_EXCL2  } = mod18;
const promises = {
    access: accessPromise,
    copyFile: copyFilePromise,
    open: openPromise,
    opendir: opendirPromise,
    rename: renamePromise,
    truncate: truncatePromise,
    rm: rmPromise,
    rmdir: rmdirPromise,
    mkdir: mkdirPromise,
    readdir: readdirPromise,
    readlink: readlinkPromise,
    symlink: symlinkPromise,
    lstat: lstatPromise,
    stat: statPromise,
    link: linkPromise,
    unlink: unlinkPromise,
    chmod: chmodPromise,
    chown: chownPromise,
    utimes: utimesPromise,
    realpath: realpathPromise,
    mkdtemp: mkdtempPromise,
    writeFile: writeFilePromise,
    appendFile: appendFilePromise,
    readFile: readFilePromise,
    watch: watchPromise
};
function h1(t, e, a, r) {
    if (t != null && t.startsWith("/") && (t = t.substr(1)), typeof e == "string" || e instanceof Date) {
        let s = new Date(e), i = s.getUTCFullYear() + String(s.getUTCMonth() + 1).padStart(2, "0") + s.getUTCDate().toString().padStart(2, "0");
        return t && (i = s.getFullYear() + String(s.getMonth() + 1).padStart(2, "0") + s.getDate().toString().padStart(2, "0")), a ? i : t ? (i += "T" + s.getHours().toString().padStart(2, "0") + s.getMinutes().toString().padStart(2, "0") + s.getSeconds().toString().padStart(2, "0"), i) : (i += "T" + s.getUTCHours().toString().padStart(2, "0") + s.getUTCMinutes().toString().padStart(2, "0") + s.getUTCSeconds().toString().padStart(2, "0") + (r ? "" : "Z"), i);
    } else if (E1(e)) {
        let s = t ? Y1(e) && !e.tz() ? e.clone().tz(t) : e : r ? e : e.utc();
        return s.format("YYYYMMDD") + (a ? "" : "T" + s.format("HHmmss") + (r || t ? "" : "Z"));
    } else if (y1(e)) {
        let s = t ? e.setZone(t) : r ? e : e.setZone("utc");
        return s.toFormat("yyyyLLdd") + (a ? "" : "T" + s.toFormat("HHmmss") + (r || t ? "" : "Z"));
    } else {
        let s = e;
        if (t) s = typeof e.tz == "function" ? e.tz(t) : e;
        else if (!r) if (typeof e.utc == "function") s = e.utc();
        else throw new Error("Unable to convert dayjs object to UTC value: UTC plugin is not available!");
        return s.format("YYYYMMDD") + (a ? "" : "T" + s.format("HHmmss") + (r || t ? "" : "Z"));
    }
}
function v2(t, e, a, r) {
    let s = "", i = r?.floating || !1;
    return r != null && r.timezone && (s = ";TZID=" + r.timezone, i = !0), e + s + ":" + h1(t, a, !1, i);
}
function n(t, e) {
    return String(t).replace(e ? /[\\"]/g : /[\\;,]/g, function(a) {
        return "\\" + a;
    }).replace(/(?:\r\n|\r|\n)/g, "\\n");
}
function x1(t) {
    return t.split(`\r
`).map(function(e) {
        let a = "", r = 0;
        for(let s = 0; s < e.length; s++){
            let i = e.charAt(s);
            i >= "\uD800" && i <= "\uDBFF" && (i += e.charAt(++s));
            let o = new TextEncoder().encode(i).length;
            r += o, r > 74 && (a += `\r
 `, r = o), a += i;
        }
        return a;
    }).join(`\r
`);
}
function d1(t, e, a) {
    if (Array.isArray(e)) t.x = e.map((r)=>{
        if (Array.isArray(r)) return r;
        if (typeof r.key != "string" || typeof r.value != "string") throw new Error("Either key or value is not a string!");
        if (r.key.substr(0, 2) !== "X-") throw new Error("Key has to start with `X-`!");
        return [
            r.key,
            r.value
        ];
    });
    else if (typeof e == "object") t.x = Object.entries(e).map(([r, s])=>{
        if (typeof r != "string" || typeof s != "string") throw new Error("Either key or value is not a string!");
        if (r.substr(0, 2) !== "X-") throw new Error("Key has to start with `X-`!");
        return [
            r,
            s
        ];
    });
    else if (typeof e == "string" && typeof a == "string") {
        if (e.substr(0, 2) !== "X-") throw new Error("Key has to start with `X-`!");
        t.x.push([
            e,
            a
        ]);
    } else return t.x.map((r)=>({
            key: r[0],
            value: r[1]
        }));
}
function I1(t) {
    let e = t.x.map(([a, r])=>a.toUpperCase() + ":" + n(r, !1)).join(`\r
`);
    return e.length ? e + `\r
` : "";
}
function f(t, e) {
    let a = null;
    if (typeof e == "string") {
        let r = e.match(/^(.+) ?<([^>]+)>$/);
        r ? a = {
            name: r[1].trim(),
            email: r[2].trim()
        } : e.includes("@") && (a = {
            name: e.trim(),
            email: e.trim()
        });
    } else typeof e == "object" && (a = {
        name: e.name,
        email: e.email,
        mailto: e.mailto,
        sentBy: e.sentBy
    });
    if (!a && typeof e == "string") throw new Error("`" + t + "` isn't formated correctly. See https://sebbo2002.github.io/ical-generator/develop/reference/interfaces/ICalOrganizer.html");
    if (!a) throw new Error("`" + t + "` needs to be a valid formed string or an object. See https://sebbo2002.github.io/ical-generator/develop/reference/interfaces/ICalOrganizer.html");
    if (!a.name) throw new Error("`" + t + ".name` is empty!");
    return a;
}
function l1(t, e) {
    let a = Object.values(t), r = String(e).toUpperCase();
    if (!r || !a.includes(r)) throw new Error(`Input must be one of the following: ${a.join(", ")}`);
    return r;
}
function c1(t, e) {
    if (t instanceof Date && isNaN(t.getTime()) || typeof t == "string" && isNaN(new Date(t).getTime())) throw new Error(`\`${e}\` has to be a valid date!`);
    if (t instanceof Date || typeof t == "string" || y1(t) && t.isValid === !0 || (E1(t) || j1(t)) && t.isValid()) return t;
    throw new Error(`\`${e}\` has to be a valid date!`);
}
function m1(t) {
    return typeof t == "string" || t instanceof Date ? new Date(t) : y1(t) ? t.toJSDate() : t.toDate();
}
function E1(t) {
    return t != null && t._isAMomentObject != null;
}
function Y1(t) {
    return E1(t) && "tz" in t && typeof t.tz == "function";
}
function j1(t) {
    return typeof t == "object" && t !== null && !(t instanceof Date) && !E1(t) && !y1(t);
}
function y1(t) {
    return typeof t == "object" && t !== null && "toJSDate" in t && typeof t.toJSDate == "function";
}
function B1(t) {
    return t !== null && typeof t == "object" && typeof t.asSeconds == "function";
}
function T(t) {
    return t !== null && typeof t == "object" && typeof t.between == "function" && typeof t.toString == "function";
}
function g2(t) {
    return t ? typeof t == "string" ? t : t.toJSON() : null;
}
function p(t) {
    let e = "";
    return t < 0 && (e = "-", t *= -1), e += "P", t >= 86400 && (e += Math.floor(t / 86400) + "D", t %= 86400), !t && e.length > 1 || (e += "T", t >= 3600 && (e += Math.floor(t / 3600) + "H", t %= 3600), t >= 60 && (e += Math.floor(t / 60) + "M", t %= 60), t > 0 ? e += t + "S" : e.length <= 2 && (e += "0S")), e;
}
var R2 = ((t)=>(t.CHAIR = "CHAIR", t.REQ = "REQ-PARTICIPANT", t.OPT = "OPT-PARTICIPANT", t.NON = "NON-PARTICIPANT", t))(R2 || {}), N = ((t)=>(t.ACCEPTED = "ACCEPTED", t.TENTATIVE = "TENTATIVE", t.DECLINED = "DECLINED", t.DELEGATED = "DELEGATED", t.NEEDSACTION = "NEEDS-ACTION", t))(N || {}), w = ((t)=>(t.INDIVIDUAL = "INDIVIDUAL", t.GROUP = "GROUP", t.RESOURCE = "RESOURCE", t.ROOM = "ROOM", t.UNKNOWN = "UNKNOWN", t))(w || {}), u = class {
    constructor(t, e){
        if (this.data = {
            name: null,
            email: null,
            mailto: null,
            sentBy: null,
            status: null,
            role: "REQ-PARTICIPANT",
            rsvp: null,
            type: null,
            delegatedTo: null,
            delegatedFrom: null,
            x: []
        }, this.event = e, !this.event) throw new Error("`event` option required!");
        t.name !== void 0 && this.name(t.name), t.email !== void 0 && this.email(t.email), t.mailto !== void 0 && this.mailto(t.mailto), t.sentBy !== void 0 && this.sentBy(t.sentBy), t.status !== void 0 && this.status(t.status), t.role !== void 0 && this.role(t.role), t.rsvp !== void 0 && this.rsvp(t.rsvp), t.type !== void 0 && this.type(t.type), t.delegatedTo !== void 0 && this.delegatedTo(t.delegatedTo), t.delegatedFrom !== void 0 && this.delegatedFrom(t.delegatedFrom), t.delegatesTo && this.delegatesTo(t.delegatesTo), t.delegatesFrom && this.delegatesFrom(t.delegatesFrom), t.x !== void 0 && this.x(t.x);
    }
    name(t) {
        return t === void 0 ? this.data.name : (this.data.name = t || null, this);
    }
    email(t) {
        return t ? (this.data.email = t, this) : this.data.email;
    }
    mailto(t) {
        return t === void 0 ? this.data.mailto : (this.data.mailto = t || null, this);
    }
    sentBy(t) {
        return t ? (this.data.sentBy = t, this) : this.data.sentBy;
    }
    role(t) {
        return t === void 0 ? this.data.role : (this.data.role = l1(R2, t), this);
    }
    rsvp(t) {
        return t === void 0 ? this.data.rsvp : t === null ? (this.data.rsvp = null, this) : (this.data.rsvp = !!t, this);
    }
    status(t) {
        return t === void 0 ? this.data.status : t ? (this.data.status = l1(N, t), this) : (this.data.status = null, this);
    }
    type(t) {
        return t === void 0 ? this.data.type : t ? (this.data.type = l1(w, t), this) : (this.data.type = null, this);
    }
    delegatedTo(t) {
        return t === void 0 ? this.data.delegatedTo : t ? (typeof t == "string" ? this.data.delegatedTo = new u(f("delegatedTo", t), this.event) : t instanceof u ? this.data.delegatedTo = t : this.data.delegatedTo = new u(t, this.event), this.data.status = "DELEGATED", this) : (this.data.delegatedTo = null, this.data.status === "DELEGATED" && (this.data.status = null), this);
    }
    delegatedFrom(t) {
        return t === void 0 ? this.data.delegatedFrom : (t ? typeof t == "string" ? this.data.delegatedFrom = new u(f("delegatedFrom", t), this.event) : t instanceof u ? this.data.delegatedFrom = t : this.data.delegatedFrom = new u(t, this.event) : this.data.delegatedFrom = null, this);
    }
    delegatesTo(t) {
        let e = t instanceof u ? t : this.event.createAttendee(t);
        return this.delegatedTo(e), e.delegatedFrom(this), e;
    }
    delegatesFrom(t) {
        let e = t instanceof u ? t : this.event.createAttendee(t);
        return this.delegatedFrom(e), e.delegatedTo(this), e;
    }
    x(t, e) {
        if (t === void 0) return d1(this.data);
        if (typeof t == "string" && typeof e == "string") d1(this.data, t, e);
        else if (typeof t == "object") d1(this.data, t);
        else throw new Error("Either key or value is not a string!");
        return this;
    }
    toJSON() {
        var t, e;
        return Object.assign({}, this.data, {
            delegatedTo: ((t = this.data.delegatedTo) == null ? void 0 : t.email()) || null,
            delegatedFrom: ((e = this.data.delegatedFrom) == null ? void 0 : e.email()) || null,
            x: this.x()
        });
    }
    toString() {
        let t = "ATTENDEE";
        if (!this.data.email) throw new Error("No value for `email` in ICalAttendee given!");
        return t += ";ROLE=" + this.data.role, this.data.type && (t += ";CUTYPE=" + this.data.type), this.data.status && (t += ";PARTSTAT=" + this.data.status), this.data.rsvp !== null && (t += ";RSVP=" + this.data.rsvp.toString().toUpperCase()), this.data.sentBy !== null && (t += ';SENT-BY="mailto:' + this.data.sentBy + '"'), this.data.delegatedTo && (t += ';DELEGATED-TO="' + this.data.delegatedTo.email() + '"'), this.data.delegatedFrom && (t += ';DELEGATED-FROM="' + this.data.delegatedFrom.email() + '"'), this.data.name && (t += ';CN="' + n(this.data.name, !0) + '"'), this.data.email && this.data.mailto && (t += ";EMAIL=" + n(this.data.email, !1)), this.data.x.length && (t += ";" + this.data.x.map(([e, a])=>e.toUpperCase() + "=" + n(a, !1)).join(";")), t += ":MAILTO:" + n(this.data.mailto || this.data.email, !1) + `\r
`, t;
    }
}, O1 = ((t)=>(t.display = "display", t.audio = "audio", t))(O1 || {}), H = {
    end: "END",
    start: "START"
}, S = class {
    constructor(t, e){
        if (this.data = {
            type: null,
            trigger: null,
            relatesTo: null,
            repeat: null,
            interval: null,
            attach: null,
            description: null,
            x: []
        }, this.event = e, !e) throw new Error("`event` option required!");
        t.type !== void 0 && this.type(t.type), t.trigger !== void 0 && this.trigger(t.trigger), t.triggerBefore !== void 0 && this.triggerBefore(t.triggerBefore), t.triggerAfter !== void 0 && this.triggerAfter(t.triggerAfter), t.repeat !== void 0 && this.repeat(t.repeat), t.interval !== void 0 && this.interval(t.interval), t.attach !== void 0 && this.attach(t.attach), t.description !== void 0 && this.description(t.description), t.x !== void 0 && this.x(t.x);
    }
    type(t) {
        if (t === void 0) return this.data.type;
        if (!t) return this.data.type = null, this;
        if (!Object.keys(O1).includes(t)) throw new Error("`type` is not correct, must be either `display` or `audio`!");
        return this.data.type = t, this;
    }
    trigger(t) {
        if (t === void 0 && typeof this.data.trigger == "number") return -1 * this.data.trigger;
        if (t === void 0 && this.data.trigger) return this.data.trigger;
        if (t === void 0) return null;
        if (!t) this.data.trigger = null;
        else if (typeof t == "number" && isFinite(t)) this.data.trigger = -1 * t;
        else {
            if (typeof t == "number") throw new Error("`trigger` is not correct, must be a finite number or a supported date!");
            this.data.trigger = c1(t, "trigger");
        }
        return this;
    }
    relatesTo(t) {
        if (t === void 0) return this.data.relatesTo;
        if (!t) return this.data.relatesTo = null, this;
        if (!Object.values(H).includes(t)) throw new Error("`relatesTo` is not correct, must be either `START` or `END`!");
        return this.data.relatesTo = t, this;
    }
    triggerAfter(t) {
        return t === void 0 ? this.data.trigger : this.trigger(typeof t == "number" ? -1 * t : t);
    }
    triggerBefore(t) {
        return t === void 0 ? this.trigger() : this.trigger(t);
    }
    repeat(t) {
        if (t === void 0) return this.data.repeat;
        if (!t) return this.data.repeat = null, this;
        if (typeof t != "number" || !isFinite(t)) throw new Error("`repeat` is not correct, must be numeric!");
        return this.data.repeat = t, this;
    }
    interval(t) {
        if (t === void 0) return this.data.interval || null;
        if (!t) return this.data.interval = null, this;
        if (typeof t != "number" || !isFinite(t)) throw new Error("`interval` is not correct, must be numeric!");
        return this.data.interval = t, this;
    }
    attach(t) {
        if (t === void 0) return this.data.attach;
        if (!t) return this.data.attach = null, this;
        let e = null;
        if (typeof t == "string") e = {
            uri: t,
            mime: null
        };
        else if (typeof t == "object") e = {
            uri: t.uri,
            mime: t.mime || null
        };
        else throw new Error("`attachment` needs to be a valid formed string or an object. See https://sebbo2002.github.io/ical-generator/develop/reference/classes/ICalAlarm.html#attach");
        if (!e.uri) throw new Error("`attach.uri` is empty!");
        return this.data.attach = {
            uri: e.uri,
            mime: e.mime
        }, this;
    }
    description(t) {
        return t === void 0 ? this.data.description : t ? (this.data.description = t, this) : (this.data.description = null, this);
    }
    x(t, e) {
        if (t === void 0) return d1(this.data);
        if (typeof t == "string" && typeof e == "string") d1(this.data, t, e);
        else if (typeof t == "object") d1(this.data, t);
        else throw new Error("Either key or value is not a string!");
        return this;
    }
    toJSON() {
        let t = this.trigger();
        return Object.assign({}, this.data, {
            trigger: typeof t == "number" ? t : g2(t),
            x: this.x()
        });
    }
    toString() {
        let t = `BEGIN:VALARM\r
`;
        if (!this.data.type) throw new Error("No value for `type` in ICalAlarm given!");
        if (!this.data.trigger) throw new Error("No value for `trigger` in ICalAlarm given!");
        if (t += "ACTION:" + this.data.type.toUpperCase() + `\r
`, typeof this.data.trigger == "number" && this.data.relatesTo === null ? this.data.trigger > 0 ? t += "TRIGGER;RELATED=END:" + p(this.data.trigger) + `\r
` : t += "TRIGGER:" + p(this.data.trigger) + `\r
` : typeof this.data.trigger == "number" ? t += "TRIGGER;RELATED=" + this.data.relatesTo.toUpperCase() + ":" + p(this.data.trigger) + `\r
` : t += "TRIGGER;VALUE=DATE-TIME:" + h1(this.event.timezone(), this.data.trigger) + `\r
`, this.data.repeat && !this.data.interval) throw new Error("No value for `interval` in ICalAlarm given, but required for `repeat`!");
        if (this.data.repeat && (t += "REPEAT:" + this.data.repeat + `\r
`), this.data.interval && !this.data.repeat) throw new Error("No value for `repeat` in ICalAlarm given, but required for `interval`!");
        return this.data.interval && (t += "DURATION:" + p(this.data.interval) + `\r
`), this.data.type === "audio" && this.data.attach && this.data.attach.mime ? t += "ATTACH;FMTTYPE=" + n(this.data.attach.mime, !1) + ":" + n(this.data.attach.uri, !1) + `\r
` : this.data.type === "audio" && this.data.attach ? t += "ATTACH;VALUE=URI:" + n(this.data.attach.uri, !1) + `\r
` : this.data.type === "audio" && (t += `ATTACH;VALUE=URI:Basso\r
`), this.data.type === "display" && this.data.description ? t += "DESCRIPTION:" + n(this.data.description, !1) + `\r
` : this.data.type === "display" && (t += "DESCRIPTION:" + n(this.event.summary(), !1) + `\r
`), t += I1(this.data), t += `END:VALARM\r
`, t;
    }
}, b = class {
    constructor(t){
        this.data = {
            name: null
        }, t.name !== void 0 && this.name(t.name);
    }
    name(t) {
        return t === void 0 ? this.data.name : (this.data.name = t || null, this);
    }
    toJSON() {
        return Object.assign({}, this.data);
    }
    toString() {
        if (!this.data.name) throw new Error("No value for `name` in ICalCategory given!");
        return n(this.data.name, !1);
    }
}, U1 = ((t)=>(t.SECONDLY = "SECONDLY", t.MINUTELY = "MINUTELY", t.HOURLY = "HOURLY", t.DAILY = "DAILY", t.WEEKLY = "WEEKLY", t.MONTHLY = "MONTHLY", t.YEARLY = "YEARLY", t))(U1 || {}), A1 = ((t)=>(t.SU = "SU", t.MO = "MO", t.TU = "TU", t.WE = "WE", t.TH = "TH", t.FR = "FR", t.SA = "SA", t))(A1 || {}), L = ((t)=>(t.CONFIRMED = "CONFIRMED", t.TENTATIVE = "TENTATIVE", t.CANCELLED = "CANCELLED", t))(L || {}), M = ((t)=>(t.FREE = "FREE", t.TENTATIVE = "TENTATIVE", t.BUSY = "BUSY", t.OOF = "OOF", t))(M || {}), z = ((t)=>(t.TRANSPARENT = "TRANSPARENT", t.OPAQUE = "OPAQUE", t))(z || {}), F2 = ((t)=>(t.PUBLIC = "PUBLIC", t.PRIVATE = "PRIVATE", t.CONFIDENTIAL = "CONFIDENTIAL", t))(F2 || {}), C = class {
    constructor(t, e){
        if (this.data = {
            id: I(),
            sequence: 0,
            start: null,
            end: null,
            recurrenceId: null,
            timezone: null,
            stamp: new Date,
            allDay: !1,
            floating: !1,
            repeating: null,
            summary: "",
            location: null,
            description: null,
            organizer: null,
            attendees: [],
            alarms: [],
            categories: [],
            status: null,
            busystatus: null,
            priority: null,
            url: null,
            attachments: [],
            transparency: null,
            created: null,
            lastModified: null,
            class: null,
            x: []
        }, this.calendar = e, !e) throw new Error("`calendar` option required!");
        t.id && this.id(t.id), t.sequence !== void 0 && this.sequence(t.sequence), t.start && this.start(t.start), t.end !== void 0 && this.end(t.end), t.recurrenceId !== void 0 && this.recurrenceId(t.recurrenceId), t.timezone !== void 0 && this.timezone(t.timezone), t.stamp !== void 0 && this.stamp(t.stamp), t.allDay !== void 0 && this.allDay(t.allDay), t.floating !== void 0 && this.floating(t.floating), t.repeating !== void 0 && this.repeating(t.repeating), t.summary !== void 0 && this.summary(t.summary), t.location !== void 0 && this.location(t.location), t.description !== void 0 && this.description(t.description), t.organizer !== void 0 && this.organizer(t.organizer), t.attendees !== void 0 && this.attendees(t.attendees), t.alarms !== void 0 && this.alarms(t.alarms), t.categories !== void 0 && this.categories(t.categories), t.status !== void 0 && this.status(t.status), t.busystatus !== void 0 && this.busystatus(t.busystatus), t.priority !== void 0 && this.priority(t.priority), t.url !== void 0 && this.url(t.url), t.attachments !== void 0 && this.attachments(t.attachments), t.transparency !== void 0 && this.transparency(t.transparency), t.created !== void 0 && this.created(t.created), t.lastModified !== void 0 && this.lastModified(t.lastModified), t.class !== void 0 && this.class(t.class), t.x !== void 0 && this.x(t.x);
    }
    id(t) {
        return t === void 0 ? this.data.id : (this.data.id = String(t), this);
    }
    uid(t) {
        return t === void 0 ? this.id() : this.id(t);
    }
    sequence(t) {
        if (t === void 0) return this.data.sequence;
        let e = parseInt(String(t), 10);
        if (isNaN(e)) throw new Error("`sequence` must be a number!");
        return this.data.sequence = t, this;
    }
    start(t) {
        if (t === void 0) return this.data.start;
        if (this.data.start = c1(t, "start"), this.data.start && this.data.end && m1(this.data.start).getTime() > m1(this.data.end).getTime()) {
            let e = this.data.start;
            this.data.start = this.data.end, this.data.end = e;
        }
        return this;
    }
    end(t) {
        if (t === void 0) return this.data.end;
        if (t === null) return this.data.end = null, this;
        if (this.data.end = c1(t, "end"), this.data.start && this.data.end && m1(this.data.start).getTime() > m1(this.data.end).getTime()) {
            let e = this.data.start;
            this.data.start = this.data.end, this.data.end = e;
        }
        return this;
    }
    recurrenceId(t) {
        return t === void 0 ? this.data.recurrenceId : t === null ? (this.data.recurrenceId = null, this) : (this.data.recurrenceId = c1(t, "recurrenceId"), this);
    }
    timezone(t) {
        return t === void 0 && this.data.timezone !== null ? this.data.timezone : t === void 0 ? this.calendar.timezone() : (this.data.timezone = t && t !== "UTC" ? t.toString() : null, this.data.timezone && (this.data.floating = !1), this);
    }
    stamp(t) {
        return t === void 0 ? this.data.stamp : (this.data.stamp = c1(t, "stamp"), this);
    }
    timestamp(t) {
        return t === void 0 ? this.stamp() : this.stamp(t);
    }
    allDay(t) {
        return t === void 0 ? this.data.allDay : (this.data.allDay = !!t, this);
    }
    floating(t) {
        return t === void 0 ? this.data.floating : (this.data.floating = !!t, this.data.floating && (this.data.timezone = null), this);
    }
    repeating(t) {
        if (t === void 0) return this.data.repeating;
        if (!t) return this.data.repeating = null, this;
        if (T(t) || typeof t == "string") return this.data.repeating = t, this;
        if (this.data.repeating = {
            freq: l1(U1, t.freq)
        }, t.count) {
            if (!isFinite(t.count)) throw new Error("`repeating.count` must be a finite number!");
            this.data.repeating.count = t.count;
        }
        if (t.interval) {
            if (!isFinite(t.interval)) throw new Error("`repeating.interval` must be a finite number!");
            this.data.repeating.interval = t.interval;
        }
        if (t.until !== void 0 && (this.data.repeating.until = c1(t.until, "repeating.until")), t.byDay) {
            let e = Array.isArray(t.byDay) ? t.byDay : [
                t.byDay
            ];
            this.data.repeating.byDay = e.map((a)=>l1(A1, a));
        }
        if (t.byMonth) {
            let e = Array.isArray(t.byMonth) ? t.byMonth : [
                t.byMonth
            ];
            this.data.repeating.byMonth = e.map((a)=>{
                if (typeof a != "number" || a < 1 || a > 12) throw new Error("`repeating.byMonth` contains invalid value `" + a + "`!");
                return a;
            });
        }
        if (t.byMonthDay) {
            let e = Array.isArray(t.byMonthDay) ? t.byMonthDay : [
                t.byMonthDay
            ];
            this.data.repeating.byMonthDay = e.map((a)=>{
                if (typeof a != "number" || a < -31 || a > 31 || a === 0) throw new Error("`repeating.byMonthDay` contains invalid value `" + a + "`!");
                return a;
            });
        }
        if (t.bySetPos) {
            if (!this.data.repeating.byDay) throw "`repeating.bySetPos` must be used along with `repeating.byDay`!";
            let e = Array.isArray(t.bySetPos) ? t.bySetPos : [
                t.bySetPos
            ];
            this.data.repeating.bySetPos = e.map((a)=>{
                if (typeof a != "number" || a < -366 || a > 366 || a === 0) throw "`repeating.bySetPos` contains invalid value `" + a + "`!";
                return a;
            });
        }
        if (t.exclude) {
            let e = Array.isArray(t.exclude) ? t.exclude : [
                t.exclude
            ];
            this.data.repeating.exclude = e.map((a, r)=>c1(a, `repeating.exclude[${r}]`));
        }
        return t.startOfWeek && (this.data.repeating.startOfWeek = l1(A1, t.startOfWeek)), this;
    }
    summary(t) {
        return t === void 0 ? this.data.summary : (this.data.summary = t ? String(t) : "", this);
    }
    location(t) {
        if (t === void 0) return this.data.location;
        if (typeof t == "string") return this.data.location = {
            title: t
        }, this;
        if (t && !t.title || t != null && t.geo && (!isFinite(t.geo.lat) || !isFinite(t.geo.lon))) throw new Error("`location` isn't formatted correctly. See https://sebbo2002.github.io/ical-generator/develop/reference/classes/ICalEvent.html#location");
        return this.data.location = t || null, this;
    }
    description(t) {
        return t === void 0 ? this.data.description : t === null ? (this.data.description = null, this) : (typeof t == "string" ? this.data.description = {
            plain: t
        } : this.data.description = t, this);
    }
    organizer(t) {
        return t === void 0 ? this.data.organizer : t === null ? (this.data.organizer = null, this) : (this.data.organizer = f("organizer", t), this);
    }
    createAttendee(t = {}) {
        if (t instanceof u) return this.data.attendees.push(t), t;
        typeof t == "string" && (t = f("data", t));
        let e = new u(t, this);
        return this.data.attendees.push(e), e;
    }
    attendees(t) {
        return t ? (t.forEach((e)=>this.createAttendee(e)), this) : this.data.attendees;
    }
    createAlarm(t = {}) {
        let e = t instanceof S ? t : new S(t, this);
        return this.data.alarms.push(e), e;
    }
    alarms(t) {
        return t ? (t.forEach((e)=>this.createAlarm(e)), this) : this.data.alarms;
    }
    createCategory(t = {}) {
        let e = t instanceof b ? t : new b(t);
        return this.data.categories.push(e), e;
    }
    categories(t) {
        return t ? (t.forEach((e)=>this.createCategory(e)), this) : this.data.categories;
    }
    status(t) {
        return t === void 0 ? this.data.status : t === null ? (this.data.status = null, this) : (this.data.status = l1(L, t), this);
    }
    busystatus(t) {
        return t === void 0 ? this.data.busystatus : t === null ? (this.data.busystatus = null, this) : (this.data.busystatus = l1(M, t), this);
    }
    priority(t) {
        if (t === void 0) return this.data.priority;
        if (t === null) return this.data.priority = null, this;
        if (t < 0 || t > 9) throw new Error("`priority` is invalid, musst be 0 \u2264 priority \u2264 9.");
        return this.data.priority = Math.round(t), this;
    }
    url(t) {
        return t === void 0 ? this.data.url : (this.data.url = t ? String(t) : null, this);
    }
    createAttachment(t) {
        return this.data.attachments.push(t), this;
    }
    attachments(t) {
        return t ? (t.forEach((e)=>this.createAttachment(e)), this) : this.data.attachments;
    }
    transparency(t) {
        return t === void 0 ? this.data.transparency : t ? (this.data.transparency = l1(z, t), this) : (this.data.transparency = null, this);
    }
    created(t) {
        return t === void 0 ? this.data.created : t === null ? (this.data.created = null, this) : (this.data.created = c1(t, "created"), this);
    }
    lastModified(t) {
        return t === void 0 ? this.data.lastModified : t === null ? (this.data.lastModified = null, this) : (this.data.lastModified = c1(t, "lastModified"), this);
    }
    class(t) {
        return t === void 0 ? this.data.class : t === null ? (this.data.class = null, this) : (this.data.class = l1(F2, t), this);
    }
    x(t, e) {
        return t === void 0 ? d1(this.data) : (typeof t == "string" && typeof e == "string" && d1(this.data, t, e), typeof t == "object" && d1(this.data, t), this);
    }
    toJSON() {
        var t;
        let e = null;
        return T(this.data.repeating) || typeof this.data.repeating == "string" ? e = this.data.repeating.toString() : this.data.repeating && (e = Object.assign({}, this.data.repeating, {
            until: g2(this.data.repeating.until) || void 0,
            exclude: (t = this.data.repeating.exclude) == null ? void 0 : t.map((a)=>g2(a))
        })), Object.assign({}, this.data, {
            start: g2(this.data.start) || null,
            end: g2(this.data.end) || null,
            recurrenceId: g2(this.data.recurrenceId) || null,
            stamp: g2(this.data.stamp) || null,
            created: g2(this.data.created) || null,
            lastModified: g2(this.data.lastModified) || null,
            repeating: e,
            x: this.x()
        });
    }
    toString() {
        var t, e, a, r, s;
        let i = "";
        if (!this.data.start) throw new Error("No value for `start` in ICalEvent #" + this.data.id + " given!");
        if (i += `BEGIN:VEVENT\r
`, i += "UID:" + this.data.id + `\r
`, i += "SEQUENCE:" + this.data.sequence + `\r
`, i += "DTSTAMP:" + h1(this.calendar.timezone(), this.data.stamp) + `\r
`, this.data.allDay ? (i += "DTSTART;VALUE=DATE:" + h1(this.calendar.timezone(), this.data.start, !0) + `\r
`, this.data.end && (i += "DTEND;VALUE=DATE:" + h1(this.calendar.timezone(), this.data.end, !0) + `\r
`), i += `X-MICROSOFT-CDO-ALLDAYEVENT:TRUE\r
`, i += `X-MICROSOFT-MSNCALENDAR-ALLDAYEVENT:TRUE\r
`) : (i += v2(this.timezone(), "DTSTART", this.data.start, this.data) + `\r
`, this.data.end && (i += v2(this.timezone(), "DTEND", this.data.end, this.data) + `\r
`)), T(this.data.repeating) || typeof this.data.repeating == "string") {
            let o = this.data.repeating.toString().replace(/\r\n/g, `
`).split(`
`).filter((D)=>D && !D.startsWith("DTSTART:")).join(`\r
`);
            !o.includes(`\r
`) && !o.startsWith("RRULE:") && (o = "RRULE:" + o), i += o.trim() + `\r
`;
        } else this.data.repeating && (i += "RRULE:FREQ=" + this.data.repeating.freq, this.data.repeating.count && (i += ";COUNT=" + this.data.repeating.count), this.data.repeating.interval && (i += ";INTERVAL=" + this.data.repeating.interval), this.data.repeating.until && (i += ";UNTIL=" + h1(this.calendar.timezone(), this.data.repeating.until, !1, this.floating())), this.data.repeating.byDay && (i += ";BYDAY=" + this.data.repeating.byDay.join(",")), this.data.repeating.byMonth && (i += ";BYMONTH=" + this.data.repeating.byMonth.join(",")), this.data.repeating.byMonthDay && (i += ";BYMONTHDAY=" + this.data.repeating.byMonthDay.join(",")), this.data.repeating.bySetPos && (i += ";BYSETPOS=" + this.data.repeating.bySetPos.join(",")), this.data.repeating.startOfWeek && (i += ";WKST=" + this.data.repeating.startOfWeek), i += `\r
`, this.data.repeating.exclude && (this.data.allDay ? i += "EXDATE;VALUE=DATE:" + this.data.repeating.exclude.map((o)=>h1(this.calendar.timezone(), o, !0)).join(",") + `\r
` : (i += "EXDATE", this.timezone() ? i += ";TZID=" + this.timezone() + ":" + this.data.repeating.exclude.map((o)=>h1(this.timezone(), o, !1, !0)).join(",") + `\r
` : i += ":" + this.data.repeating.exclude.map((o)=>h1(this.timezone(), o, !1, this.floating())).join(",") + `\r
`)));
        return this.data.recurrenceId && (i += v2(this.timezone(), "RECURRENCE-ID", this.data.recurrenceId, this.data) + `\r
`), i += "SUMMARY:" + n(this.data.summary, !1) + `\r
`, this.data.transparency && (i += "TRANSP:" + n(this.data.transparency, !1) + `\r
`), (t = this.data.location) != null && t.title && (i += "LOCATION:" + n(this.data.location.title + (this.data.location.address ? `
` + this.data.location.address : ""), !1) + `\r
`, this.data.location.radius && this.data.location.geo && (i += "X-APPLE-STRUCTURED-LOCATION;VALUE=URI;" + (this.data.location.address ? "X-ADDRESS=" + n(this.data.location.address, !1) + ";" : "") + "X-APPLE-RADIUS=" + n(this.data.location.radius, !1) + ";X-TITLE=" + n(this.data.location.title, !1) + ":geo:" + n((e = this.data.location.geo) == null ? void 0 : e.lat, !1) + "," + n((a = this.data.location.geo) == null ? void 0 : a.lon, !1) + `\r
`), this.data.location.geo && (i += "GEO:" + n((r = this.data.location.geo) == null ? void 0 : r.lat, !1) + ";" + n((s = this.data.location.geo) == null ? void 0 : s.lon, !1) + `\r
`)), this.data.description && (i += "DESCRIPTION:" + n(this.data.description.plain, !1) + `\r
`, this.data.description.html && (i += "X-ALT-DESC;FMTTYPE=text/html:" + n(this.data.description.html, !1) + `\r
`)), this.data.organizer && (i += 'ORGANIZER;CN="' + n(this.data.organizer.name, !0) + '"', this.data.organizer.sentBy && (i += ';SENT-BY="mailto:' + n(this.data.organizer.sentBy, !0) + '"'), this.data.organizer.email && this.data.organizer.mailto && (i += ";EMAIL=" + n(this.data.organizer.email, !1)), this.data.organizer.email && (i += ":mailto:" + n(this.data.organizer.mailto || this.data.organizer.email, !1)), i += `\r
`), this.data.attendees.forEach(function(o) {
            i += o.toString();
        }), this.data.alarms.forEach(function(o) {
            i += o.toString();
        }), this.data.categories.length > 0 && (i += "CATEGORIES:" + this.data.categories.map(function(o) {
            return o.toString();
        }).join() + `\r
`), this.data.url && (i += "URL;VALUE=URI:" + n(this.data.url, !1) + `\r
`), this.data.attachments.length > 0 && this.data.attachments.forEach((o)=>{
            i += "ATTACH:" + n(o, !1) + `\r
`;
        }), this.data.status && (i += "STATUS:" + this.data.status.toUpperCase() + `\r
`), this.data.busystatus && (i += "X-MICROSOFT-CDO-BUSYSTATUS:" + this.data.busystatus.toUpperCase() + `\r
`), this.data.priority !== null && (i += "PRIORITY:" + this.data.priority + `\r
`), i += I1(this.data), this.data.created && (i += "CREATED:" + h1(this.calendar.timezone(), this.data.created) + `\r
`), this.data.lastModified && (i += "LAST-MODIFIED:" + h1(this.calendar.timezone(), this.data.lastModified) + `\r
`), this.data.class && (i += "CLASS:" + this.data.class.toUpperCase() + `\r
`), i += `END:VEVENT\r
`, i;
    }
}, P = ((t)=>(t.PUBLISH = "PUBLISH", t.REQUEST = "REQUEST", t.REPLY = "REPLY", t.ADD = "ADD", t.CANCEL = "CANCEL", t.REFRESH = "REFRESH", t.COUNTER = "COUNTER", t.DECLINECOUNTER = "DECLINECOUNTER", t))(P || {}), q = class {
    constructor(t = {}){
        this.data = {
            prodId: "//sebbo.net//ical-generator//EN",
            method: null,
            name: null,
            description: null,
            timezone: null,
            source: null,
            url: null,
            scale: null,
            ttl: null,
            events: [],
            x: []
        }, t.prodId !== void 0 && this.prodId(t.prodId), t.method !== void 0 && this.method(t.method), t.name !== void 0 && this.name(t.name), t.description !== void 0 && this.description(t.description), t.timezone !== void 0 && this.timezone(t.timezone), t.source !== void 0 && this.source(t.source), t.url !== void 0 && this.url(t.url), t.scale !== void 0 && this.scale(t.scale), t.ttl !== void 0 && this.ttl(t.ttl), t.events !== void 0 && this.events(t.events), t.x !== void 0 && this.x(t.x);
    }
    prodId(t) {
        if (!t) return this.data.prodId;
        if (typeof t == "string" && /^\/\/(.+)\/\/(.+)\/\/([A-Z]{1,4})$/.test(t)) return this.data.prodId = t, this;
        if (typeof t == "string") throw new Error("`prodId` isn't formated correctly. See https://sebbo2002.github.io/ical-generator/develop/reference/classes/ICalCalendar.html#prodId");
        if (typeof t != "object") throw new Error("`prodid` needs to be a valid formed string or an object!");
        if (!t.company) throw new Error("`prodid.company` is a mandatory item!");
        if (!t.product) throw new Error("`prodid.product` is a mandatory item!");
        let e = (t.language || "EN").toUpperCase();
        return this.data.prodId = "//" + t.company + "//" + t.product + "//" + e, this;
    }
    method(t) {
        return t === void 0 ? this.data.method : t ? (this.data.method = l1(P, t), this) : (this.data.method = null, this);
    }
    name(t) {
        return t === void 0 ? this.data.name : (this.data.name = t ? String(t) : null, this);
    }
    description(t) {
        return t === void 0 ? this.data.description : (this.data.description = t ? String(t) : null, this);
    }
    timezone(t) {
        var e;
        return t === void 0 ? ((e = this.data.timezone) == null ? void 0 : e.name) || null : (t === "UTC" ? this.data.timezone = null : typeof t == "string" ? this.data.timezone = {
            name: t
        } : t === null ? this.data.timezone = null : this.data.timezone = t, this);
    }
    source(t) {
        return t === void 0 ? this.data.source : (this.data.source = t || null, this);
    }
    url(t) {
        return t === void 0 ? this.data.url : (this.data.url = t || null, this);
    }
    scale(t) {
        return t === void 0 ? this.data.scale : (t === null ? this.data.scale = null : this.data.scale = t.toUpperCase(), this);
    }
    ttl(t) {
        return t === void 0 ? this.data.ttl : (B1(t) ? this.data.ttl = t.asSeconds() : t && t > 0 ? this.data.ttl = t : this.data.ttl = null, this);
    }
    createEvent(t) {
        let e = t instanceof C ? t : new C(t, this);
        return this.data.events.push(e), e;
    }
    events(t) {
        return t ? (t.forEach((e)=>this.createEvent(e)), this) : this.data.events;
    }
    clear() {
        return this.data.events = [], this;
    }
    save(t, e) {
        return e ? (writeFile(t, this.toString(), e), this) : promises.writeFile(t, this.toString());
    }
    saveSync(t) {
        return writeFileSync(t, this.toString()), this;
    }
    serve(t, e = "calendar.ics") {
        return t.writeHead(200, {
            "Content-Type": "text/calendar; charset=utf-8",
            "Content-Disposition": `attachment; filename="${e}"`
        }), t.end(this.toString()), this;
    }
    toBlob() {
        return new Blob([
            this.toString()
        ], {
            type: "text/calendar"
        });
    }
    toURL() {
        return URL.createObjectURL(this.toBlob());
    }
    x(t, e) {
        if (t === void 0) return d1(this.data);
        if (typeof t == "string" && typeof e == "string") d1(this.data, t, e);
        else if (typeof t == "object") d1(this.data, t);
        else throw new Error("Either key or value is not a string!");
        return this;
    }
    toJSON() {
        return Object.assign({}, this.data, {
            timezone: this.timezone(),
            events: this.data.events.map((t)=>t.toJSON()),
            x: this.x()
        });
    }
    length() {
        return this.data.events.length;
    }
    toString() {
        var t, e;
        let a = "";
        return a = `BEGIN:VCALENDAR\r
VERSION:2.0\r
`, a += "PRODID:-" + this.data.prodId + `\r
`, this.data.url && (a += "URL:" + this.data.url + `\r
`), this.data.source && (a += "SOURCE;VALUE=URI:" + this.data.source + `\r
`), this.data.scale && (a += "CALSCALE:" + this.data.scale + `\r
`), this.data.method && (a += "METHOD:" + this.data.method + `\r
`), this.data.name && (a += "NAME:" + this.data.name + `\r
`, a += "X-WR-CALNAME:" + this.data.name + `\r
`), this.data.description && (a += "X-WR-CALDESC:" + this.data.description + `\r
`), (t = this.data.timezone) != null && t.generator && [
            ...new Set([
                this.timezone(),
                ...this.data.events.map((r)=>r.timezone())
            ])
        ].filter((r)=>r !== null && !r.startsWith("/")).forEach((r)=>{
            var s;
            if (!((s = this.data.timezone) != null && s.generator)) return;
            let i = this.data.timezone.generator(r);
            i && (a += i.replace(/\r\n/g, `
`).replace(/\n/g, `\r
`).trim() + `\r
`);
        }), (e = this.data.timezone) != null && e.name && (a += "TIMEZONE-ID:" + this.data.timezone.name + `\r
`, a += "X-WR-TIMEZONE:" + this.data.timezone.name + `\r
`), this.data.ttl && (a += "REFRESH-INTERVAL;VALUE=DURATION:" + p(this.data.ttl) + `\r
`, a += "X-PUBLISHED-TTL:" + p(this.data.ttl) + `\r
`), this.data.events.forEach((r)=>a += r.toString()), a += I1(this.data), a += "END:VCALENDAR", x1(a);
    }
};
function k(t) {
    return new q(t);
}
var Q = k;
function toInteger1(dirtyNumber) {
    if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
        return NaN;
    }
    var number = Number(dirtyNumber);
    if (isNaN(number)) {
        return number;
    }
    return number < 0 ? Math.ceil(number) : Math.floor(number);
}
function requiredArgs(required, args) {
    if (args.length < required) {
        throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
    }
}
function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof(obj);
}
function toDate(argument) {
    requiredArgs(1, arguments);
    var argStr = Object.prototype.toString.call(argument);
    if (argument instanceof Date || _typeof(argument) === 'object' && argStr === '[object Date]') {
        return new Date(argument.getTime());
    } else if (typeof argument === 'number' || argStr === '[object Number]') {
        return new Date(argument);
    } else {
        if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
            console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
            console.warn(new Error().stack);
        }
        return new Date(NaN);
    }
}
function addDays(dirtyDate, dirtyAmount) {
    requiredArgs(2, arguments);
    var date = toDate(dirtyDate);
    var amount = toInteger1(dirtyAmount);
    if (isNaN(amount)) {
        return new Date(NaN);
    }
    if (!amount) {
        return date;
    }
    date.setDate(date.getDate() + amount);
    return date;
}
var defaultOptions = {};
function getDefaultOptions() {
    return defaultOptions;
}
var millisecondsInMinute = 60000;
var millisecondsInHour = 3600000;
var millisecondsInSecond = 1000;
function startOfUTCISOWeek(dirtyDate) {
    requiredArgs(1, arguments);
    var weekStartsOn = 1;
    var date = toDate(dirtyDate);
    var day = date.getUTCDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    date.setUTCDate(date.getUTCDate() - diff);
    date.setUTCHours(0, 0, 0, 0);
    return date;
}
function getUTCISOWeekYear(dirtyDate) {
    requiredArgs(1, arguments);
    var date = toDate(dirtyDate);
    var year = date.getUTCFullYear();
    var fourthOfJanuaryOfNextYear = new Date(0);
    fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
    var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
    var fourthOfJanuaryOfThisYear = new Date(0);
    fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
    fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
    var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
    if (date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
    } else if (date.getTime() >= startOfThisYear.getTime()) {
        return year;
    } else {
        return year - 1;
    }
}
function startOfUTCISOWeekYear(dirtyDate) {
    requiredArgs(1, arguments);
    var year = getUTCISOWeekYear(dirtyDate);
    var fourthOfJanuary = new Date(0);
    fourthOfJanuary.setUTCFullYear(year, 0, 4);
    fourthOfJanuary.setUTCHours(0, 0, 0, 0);
    var date = startOfUTCISOWeek(fourthOfJanuary);
    return date;
}
var MILLISECONDS_IN_WEEK = 604800000;
function getUTCISOWeek(dirtyDate) {
    requiredArgs(1, arguments);
    var date = toDate(dirtyDate);
    var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
    return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}
function startOfUTCWeek(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    requiredArgs(1, arguments);
    var defaultOptions = getDefaultOptions();
    var weekStartsOn = toInteger1((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
    }
    var date = toDate(dirtyDate);
    var day = date.getUTCDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    date.setUTCDate(date.getUTCDate() - diff);
    date.setUTCHours(0, 0, 0, 0);
    return date;
}
function getUTCWeekYear(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    requiredArgs(1, arguments);
    var date = toDate(dirtyDate);
    var year = date.getUTCFullYear();
    var defaultOptions = getDefaultOptions();
    var firstWeekContainsDate = toInteger1((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
    }
    var firstWeekOfNextYear = new Date(0);
    firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
    firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
    var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
    var firstWeekOfThisYear = new Date(0);
    firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
    firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
    var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
    if (date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
    } else if (date.getTime() >= startOfThisYear.getTime()) {
        return year;
    } else {
        return year - 1;
    }
}
function startOfUTCWeekYear(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    requiredArgs(1, arguments);
    var defaultOptions = getDefaultOptions();
    var firstWeekContainsDate = toInteger1((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
    var year = getUTCWeekYear(dirtyDate, options);
    var firstWeek = new Date(0);
    firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
    firstWeek.setUTCHours(0, 0, 0, 0);
    var date = startOfUTCWeek(firstWeek, options);
    return date;
}
var MILLISECONDS_IN_WEEK1 = 604800000;
function getUTCWeek(dirtyDate, options) {
    requiredArgs(1, arguments);
    var date = toDate(dirtyDate);
    var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
    return Math.round(diff / MILLISECONDS_IN_WEEK1) + 1;
}
function buildFormatLongFn(args) {
    return function() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var width = options.width ? String(options.width) : args.defaultWidth;
        var format = args.formats[width] || args.formats[args.defaultWidth];
        return format;
    };
}
var dateFormats = {
    full: 'EEEE, MMMM do, y',
    long: 'MMMM do, y',
    medium: 'MMM d, y',
    short: 'MM/dd/yyyy'
};
var timeFormats = {
    full: 'h:mm:ss a zzzz',
    long: 'h:mm:ss a z',
    medium: 'h:mm:ss a',
    short: 'h:mm a'
};
var dateTimeFormats = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: '{{date}}, {{time}}',
    short: '{{date}}, {{time}}'
};
({
    date: buildFormatLongFn({
        formats: dateFormats,
        defaultWidth: 'full'
    }),
    time: buildFormatLongFn({
        formats: timeFormats,
        defaultWidth: 'full'
    }),
    dateTime: buildFormatLongFn({
        formats: dateTimeFormats,
        defaultWidth: 'full'
    })
});
function buildLocalizeFn(args) {
    return function(dirtyIndex, options) {
        var context = options !== null && options !== void 0 && options.context ? String(options.context) : 'standalone';
        var valuesArray;
        if (context === 'formatting' && args.formattingValues) {
            var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
            var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
            valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
        } else {
            var _defaultWidth = args.defaultWidth;
            var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
            valuesArray = args.values[_width] || args.values[_defaultWidth];
        }
        var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
        return valuesArray[index];
    };
}
var eraValues = {
    narrow: [
        'B',
        'A'
    ],
    abbreviated: [
        'BC',
        'AD'
    ],
    wide: [
        'Before Christ',
        'Anno Domini'
    ]
};
var quarterValues = {
    narrow: [
        '1',
        '2',
        '3',
        '4'
    ],
    abbreviated: [
        'Q1',
        'Q2',
        'Q3',
        'Q4'
    ],
    wide: [
        '1st quarter',
        '2nd quarter',
        '3rd quarter',
        '4th quarter'
    ]
};
var monthValues = {
    narrow: [
        'J',
        'F',
        'M',
        'A',
        'M',
        'J',
        'J',
        'A',
        'S',
        'O',
        'N',
        'D'
    ],
    abbreviated: [
        'Jan',
        'Feb',
        'Mar',
        'Apr',
        'May',
        'Jun',
        'Jul',
        'Aug',
        'Sep',
        'Oct',
        'Nov',
        'Dec'
    ],
    wide: [
        'January',
        'February',
        'March',
        'April',
        'May',
        'June',
        'July',
        'August',
        'September',
        'October',
        'November',
        'December'
    ]
};
var dayValues = {
    narrow: [
        'S',
        'M',
        'T',
        'W',
        'T',
        'F',
        'S'
    ],
    short: [
        'Su',
        'Mo',
        'Tu',
        'We',
        'Th',
        'Fr',
        'Sa'
    ],
    abbreviated: [
        'Sun',
        'Mon',
        'Tue',
        'Wed',
        'Thu',
        'Fri',
        'Sat'
    ],
    wide: [
        'Sunday',
        'Monday',
        'Tuesday',
        'Wednesday',
        'Thursday',
        'Friday',
        'Saturday'
    ]
};
var dayPeriodValues = {
    narrow: {
        am: 'a',
        pm: 'p',
        midnight: 'mi',
        noon: 'n',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
    },
    abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
    },
    wide: {
        am: 'a.m.',
        pm: 'p.m.',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
    }
};
var formattingDayPeriodValues = {
    narrow: {
        am: 'a',
        pm: 'p',
        midnight: 'mi',
        noon: 'n',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
    },
    abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
    },
    wide: {
        am: 'a.m.',
        pm: 'p.m.',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
    }
};
var ordinalNumber = function ordinalNumber(dirtyNumber, _options) {
    var number = Number(dirtyNumber);
    var rem100 = number % 100;
    if (rem100 > 20 || rem100 < 10) {
        switch(rem100 % 10){
            case 1:
                return number + 'st';
            case 2:
                return number + 'nd';
            case 3:
                return number + 'rd';
        }
    }
    return number + 'th';
};
({
    ordinalNumber: ordinalNumber,
    era: buildLocalizeFn({
        values: eraValues,
        defaultWidth: 'wide'
    }),
    quarter: buildLocalizeFn({
        values: quarterValues,
        defaultWidth: 'wide',
        argumentCallback: function argumentCallback(quarter) {
            return quarter - 1;
        }
    }),
    month: buildLocalizeFn({
        values: monthValues,
        defaultWidth: 'wide'
    }),
    day: buildLocalizeFn({
        values: dayValues,
        defaultWidth: 'wide'
    }),
    dayPeriod: buildLocalizeFn({
        values: dayPeriodValues,
        defaultWidth: 'wide',
        formattingValues: formattingDayPeriodValues,
        defaultFormattingWidth: 'wide'
    })
});
function buildMatchFn(args) {
    return function(string) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var width = options.width;
        var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
        var matchResult = string.match(matchPattern);
        if (!matchResult) {
            return null;
        }
        var matchedString = matchResult[0];
        var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
        var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
            return pattern.test(matchedString);
        }) : findKey(parsePatterns, function(pattern) {
            return pattern.test(matchedString);
        });
        var value;
        value = args.valueCallback ? args.valueCallback(key) : key;
        value = options.valueCallback ? options.valueCallback(value) : value;
        var rest = string.slice(matchedString.length);
        return {
            value: value,
            rest: rest
        };
    };
}
function findKey(object, predicate) {
    for(var key in object){
        if (object.hasOwnProperty(key) && predicate(object[key])) {
            return key;
        }
    }
    return undefined;
}
function findIndex(array, predicate) {
    for(var key = 0; key < array.length; key++){
        if (predicate(array[key])) {
            return key;
        }
    }
    return undefined;
}
function buildMatchPatternFn(args) {
    return function(string) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var matchResult = string.match(args.matchPattern);
        if (!matchResult) return null;
        var matchedString = matchResult[0];
        var parseResult = string.match(args.parsePattern);
        if (!parseResult) return null;
        var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
        value = options.valueCallback ? options.valueCallback(value) : value;
        var rest = string.slice(matchedString.length);
        return {
            value: value,
            rest: rest
        };
    };
}
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
    any: [
        /^b/i,
        /^(a|c)/i
    ]
};
var matchQuarterPatterns = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
    any: [
        /1/i,
        /2/i,
        /3/i,
        /4/i
    ]
};
var matchMonthPatterns = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
    narrow: [
        /^j/i,
        /^f/i,
        /^m/i,
        /^a/i,
        /^m/i,
        /^j/i,
        /^j/i,
        /^a/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ],
    any: [
        /^ja/i,
        /^f/i,
        /^mar/i,
        /^ap/i,
        /^may/i,
        /^jun/i,
        /^jul/i,
        /^au/i,
        /^s/i,
        /^o/i,
        /^n/i,
        /^d/i
    ]
};
var matchDayPatterns = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
    narrow: [
        /^s/i,
        /^m/i,
        /^t/i,
        /^w/i,
        /^t/i,
        /^f/i,
        /^s/i
    ],
    any: [
        /^su/i,
        /^m/i,
        /^tu/i,
        /^w/i,
        /^th/i,
        /^f/i,
        /^sa/i
    ]
};
var matchDayPeriodPatterns = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
    any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
    }
};
({
    ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern,
        parsePattern: parseOrdinalNumberPattern,
        valueCallback: function valueCallback(value) {
            return parseInt(value, 10);
        }
    }),
    era: buildMatchFn({
        matchPatterns: matchEraPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns,
        defaultParseWidth: 'any'
    }),
    quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns,
        defaultParseWidth: 'any',
        valueCallback: function valueCallback(index) {
            return index + 1;
        }
    }),
    month: buildMatchFn({
        matchPatterns: matchMonthPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns,
        defaultParseWidth: 'any'
    }),
    day: buildMatchFn({
        matchPatterns: matchDayPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns,
        defaultParseWidth: 'any'
    }),
    dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns,
        defaultParseWidth: 'any'
    })
});
function _typeof1(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof1 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof1 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof1(obj);
}
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
    };
}
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof1(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized(self);
}
function _assertThisInitialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}
function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
}
function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var TIMEZONE_UNIT_PRIORITY = 10;
var Setter = function() {
    function Setter() {
        _classCallCheck(this, Setter);
        _defineProperty(this, "subPriority", 0);
    }
    _createClass(Setter, [
        {
            key: "validate",
            value: function validate(_utcDate, _options) {
                return true;
            }
        }
    ]);
    return Setter;
}();
var ValueSetter = function(_Setter) {
    _inherits(ValueSetter, _Setter);
    var _super = _createSuper(ValueSetter);
    function ValueSetter(value, validateValue, setValue, priority, subPriority) {
        var _this;
        _classCallCheck(this, ValueSetter);
        _this = _super.call(this);
        _this.value = value;
        _this.validateValue = validateValue;
        _this.setValue = setValue;
        _this.priority = priority;
        if (subPriority) {
            _this.subPriority = subPriority;
        }
        return _this;
    }
    _createClass(ValueSetter, [
        {
            key: "validate",
            value: function validate(utcDate, options) {
                return this.validateValue(utcDate, this.value, options);
            }
        },
        {
            key: "set",
            value: function set(utcDate, flags, options) {
                return this.setValue(utcDate, flags, this.value, options);
            }
        }
    ]);
    return ValueSetter;
}(Setter);
(function(_Setter2) {
    _inherits(DateToSystemTimezoneSetter, _Setter2);
    var _super2 = _createSuper(DateToSystemTimezoneSetter);
    function DateToSystemTimezoneSetter() {
        var _this2;
        _classCallCheck(this, DateToSystemTimezoneSetter);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this2 = _super2.call.apply(_super2, [
            this
        ].concat(args));
        _defineProperty(_assertThisInitialized(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
        _defineProperty(_assertThisInitialized(_this2), "subPriority", -1);
        return _this2;
    }
    _createClass(DateToSystemTimezoneSetter, [
        {
            key: "set",
            value: function set(date, flags) {
                if (flags.timestampIsSet) {
                    return date;
                }
                var convertedDate = new Date(0);
                convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
                convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
                return convertedDate;
            }
        }
    ]);
    return DateToSystemTimezoneSetter;
})(Setter);
function _classCallCheck1(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties1(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass1(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties1(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties1(Constructor, staticProps);
    return Constructor;
}
var Parser = function() {
    function Parser() {
        _classCallCheck1(this, Parser);
    }
    _createClass1(Parser, [
        {
            key: "run",
            value: function run(dateString, token, match, options) {
                var result = this.parse(dateString, token, match, options);
                if (!result) {
                    return null;
                }
                return {
                    setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
                    rest: result.rest
                };
            }
        },
        {
            key: "validate",
            value: function validate(_utcDate, _value, _options) {
                return true;
            }
        }
    ]);
    return Parser;
}();
function _typeof2(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof2 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof2 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof2(obj);
}
function _classCallCheck2(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties2(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass2(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties2(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties2(Constructor, staticProps);
    return Constructor;
}
function _inherits1(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf1(subClass, superClass);
}
function _setPrototypeOf1(o, p) {
    _setPrototypeOf1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf1(o, p);
}
function _createSuper1(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct1();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf1(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf1(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn1(this, result);
    };
}
function _possibleConstructorReturn1(self, call) {
    if (call && (_typeof2(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized1(self);
}
function _assertThisInitialized1(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct1() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf1(o) {
    _getPrototypeOf1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf1(o);
}
function _defineProperty1(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var EraParser = function(_Parser) {
    _inherits1(EraParser, _Parser);
    var _super = _createSuper1(EraParser);
    function EraParser() {
        var _this;
        _classCallCheck2(this, EraParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty1(_assertThisInitialized1(_this), "priority", 140);
        _defineProperty1(_assertThisInitialized1(_this), "incompatibleTokens", [
            'R',
            'u',
            't',
            'T'
        ]);
        return _this;
    }
    _createClass2(EraParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case 'G':
                    case 'GG':
                    case 'GGG':
                        return match.era(dateString, {
                            width: 'abbreviated'
                        }) || match.era(dateString, {
                            width: 'narrow'
                        });
                    case 'GGGGG':
                        return match.era(dateString, {
                            width: 'narrow'
                        });
                    case 'GGGG':
                    default:
                        return match.era(dateString, {
                            width: 'wide'
                        }) || match.era(dateString, {
                            width: 'abbreviated'
                        }) || match.era(dateString, {
                            width: 'narrow'
                        });
                }
            }
        },
        {
            key: "set",
            value: function set(date, flags, value) {
                flags.era = value;
                date.setUTCFullYear(value, 0, 1);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
        }
    ]);
    return EraParser;
}(Parser);
var numericPatterns = {
    month: /^(1[0-2]|0?\d)/,
    date: /^(3[0-1]|[0-2]?\d)/,
    dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
    week: /^(5[0-3]|[0-4]?\d)/,
    hour23h: /^(2[0-3]|[0-1]?\d)/,
    hour24h: /^(2[0-4]|[0-1]?\d)/,
    hour11h: /^(1[0-1]|0?\d)/,
    hour12h: /^(1[0-2]|0?\d)/,
    minute: /^[0-5]?\d/,
    second: /^[0-5]?\d/,
    singleDigit: /^\d/,
    twoDigits: /^\d{1,2}/,
    threeDigits: /^\d{1,3}/,
    fourDigits: /^\d{1,4}/,
    anyDigitsSigned: /^-?\d+/,
    singleDigitSigned: /^-?\d/,
    twoDigitsSigned: /^-?\d{1,2}/,
    threeDigitsSigned: /^-?\d{1,3}/,
    fourDigitsSigned: /^-?\d{1,4}/
};
var timezonePatterns = {
    basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
    basic: /^([+-])(\d{2})(\d{2})|Z/,
    basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
    extended: /^([+-])(\d{2}):(\d{2})|Z/,
    extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function mapValue(parseFnResult, mapFn) {
    if (!parseFnResult) {
        return parseFnResult;
    }
    return {
        value: mapFn(parseFnResult.value),
        rest: parseFnResult.rest
    };
}
function parseNumericPattern(pattern, dateString) {
    var matchResult = dateString.match(pattern);
    if (!matchResult) {
        return null;
    }
    return {
        value: parseInt(matchResult[0], 10),
        rest: dateString.slice(matchResult[0].length)
    };
}
function parseTimezonePattern(pattern, dateString) {
    var matchResult = dateString.match(pattern);
    if (!matchResult) {
        return null;
    }
    if (matchResult[0] === 'Z') {
        return {
            value: 0,
            rest: dateString.slice(1)
        };
    }
    var sign = matchResult[1] === '+' ? 1 : -1;
    var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
    var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
    var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
    return {
        value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
        rest: dateString.slice(matchResult[0].length)
    };
}
function parseAnyDigitsSigned(dateString) {
    return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
    switch(n){
        case 1:
            return parseNumericPattern(numericPatterns.singleDigit, dateString);
        case 2:
            return parseNumericPattern(numericPatterns.twoDigits, dateString);
        case 3:
            return parseNumericPattern(numericPatterns.threeDigits, dateString);
        case 4:
            return parseNumericPattern(numericPatterns.fourDigits, dateString);
        default:
            return parseNumericPattern(new RegExp('^\\d{1,' + n + '}'), dateString);
    }
}
function parseNDigitsSigned(n, dateString) {
    switch(n){
        case 1:
            return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
        case 2:
            return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
        case 3:
            return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
        case 4:
            return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
        default:
            return parseNumericPattern(new RegExp('^-?\\d{1,' + n + '}'), dateString);
    }
}
function dayPeriodEnumToHours(dayPeriod) {
    switch(dayPeriod){
        case 'morning':
            return 4;
        case 'evening':
            return 17;
        case 'pm':
        case 'noon':
        case 'afternoon':
            return 12;
        case 'am':
        case 'midnight':
        case 'night':
        default:
            return 0;
    }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
    var isCommonEra = currentYear > 0;
    var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
    var result;
    if (absCurrentYear <= 50) {
        result = twoDigitYear || 100;
    } else {
        var rangeEnd = absCurrentYear + 50;
        var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
        var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
        result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
    }
    return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function _typeof3(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof3 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof3 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof3(obj);
}
function _classCallCheck3(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties3(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass3(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties3(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties3(Constructor, staticProps);
    return Constructor;
}
function _inherits2(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf2(subClass, superClass);
}
function _setPrototypeOf2(o, p) {
    _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf2(o, p);
}
function _createSuper2(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct2();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf2(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf2(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn2(this, result);
    };
}
function _possibleConstructorReturn2(self, call) {
    if (call && (_typeof3(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized2(self);
}
function _assertThisInitialized2(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct2() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf2(o) {
    _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf2(o);
}
function _defineProperty2(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var YearParser = function(_Parser) {
    _inherits2(YearParser, _Parser);
    var _super = _createSuper2(YearParser);
    function YearParser() {
        var _this;
        _classCallCheck3(this, YearParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty2(_assertThisInitialized2(_this), "priority", 130);
        _defineProperty2(_assertThisInitialized2(_this), "incompatibleTokens", [
            'Y',
            'R',
            'u',
            'w',
            'I',
            'i',
            'e',
            'c',
            't',
            'T'
        ]);
        return _this;
    }
    _createClass3(YearParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                var valueCallback = function valueCallback(year) {
                    return {
                        year: year,
                        isTwoDigitYear: token === 'yy'
                    };
                };
                switch(token){
                    case 'y':
                        return mapValue(parseNDigits(4, dateString), valueCallback);
                    case 'yo':
                        return mapValue(match.ordinalNumber(dateString, {
                            unit: 'year'
                        }), valueCallback);
                    default:
                        return mapValue(parseNDigits(token.length, dateString), valueCallback);
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value.isTwoDigitYear || value.year > 0;
            }
        },
        {
            key: "set",
            value: function set(date, flags, value) {
                var currentYear = date.getUTCFullYear();
                if (value.isTwoDigitYear) {
                    var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
                    date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
                    date.setUTCHours(0, 0, 0, 0);
                    return date;
                }
                var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
                date.setUTCFullYear(year, 0, 1);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
        }
    ]);
    return YearParser;
}(Parser);
function _typeof4(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof4 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof4 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof4(obj);
}
function _classCallCheck4(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties4(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass4(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties4(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties4(Constructor, staticProps);
    return Constructor;
}
function _inherits3(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf3(subClass, superClass);
}
function _setPrototypeOf3(o, p) {
    _setPrototypeOf3 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf3(o, p);
}
function _createSuper3(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct3();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf3(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf3(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn3(this, result);
    };
}
function _possibleConstructorReturn3(self, call) {
    if (call && (_typeof4(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized3(self);
}
function _assertThisInitialized3(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct3() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf3(o) {
    _getPrototypeOf3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf3(o);
}
function _defineProperty3(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var LocalWeekYearParser = function(_Parser) {
    _inherits3(LocalWeekYearParser, _Parser);
    var _super = _createSuper3(LocalWeekYearParser);
    function LocalWeekYearParser() {
        var _this;
        _classCallCheck4(this, LocalWeekYearParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty3(_assertThisInitialized3(_this), "priority", 130);
        _defineProperty3(_assertThisInitialized3(_this), "incompatibleTokens", [
            'y',
            'R',
            'u',
            'Q',
            'q',
            'M',
            'L',
            'I',
            'd',
            'D',
            'i',
            't',
            'T'
        ]);
        return _this;
    }
    _createClass4(LocalWeekYearParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                var valueCallback = function valueCallback(year) {
                    return {
                        year: year,
                        isTwoDigitYear: token === 'YY'
                    };
                };
                switch(token){
                    case 'Y':
                        return mapValue(parseNDigits(4, dateString), valueCallback);
                    case 'Yo':
                        return mapValue(match.ordinalNumber(dateString, {
                            unit: 'year'
                        }), valueCallback);
                    default:
                        return mapValue(parseNDigits(token.length, dateString), valueCallback);
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value.isTwoDigitYear || value.year > 0;
            }
        },
        {
            key: "set",
            value: function set(date, flags, value, options) {
                var currentYear = getUTCWeekYear(date, options);
                if (value.isTwoDigitYear) {
                    var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
                    date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
                    date.setUTCHours(0, 0, 0, 0);
                    return startOfUTCWeek(date, options);
                }
                var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
                date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
                date.setUTCHours(0, 0, 0, 0);
                return startOfUTCWeek(date, options);
            }
        }
    ]);
    return LocalWeekYearParser;
}(Parser);
function _typeof5(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof5 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof5 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof5(obj);
}
function _classCallCheck5(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties5(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass5(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties5(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties5(Constructor, staticProps);
    return Constructor;
}
function _inherits4(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf4(subClass, superClass);
}
function _setPrototypeOf4(o, p) {
    _setPrototypeOf4 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf4(o, p);
}
function _createSuper4(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct4();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf4(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf4(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn4(this, result);
    };
}
function _possibleConstructorReturn4(self, call) {
    if (call && (_typeof5(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized4(self);
}
function _assertThisInitialized4(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct4() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf4(o) {
    _getPrototypeOf4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf4(o);
}
function _defineProperty4(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var ISOWeekYearParser = function(_Parser) {
    _inherits4(ISOWeekYearParser, _Parser);
    var _super = _createSuper4(ISOWeekYearParser);
    function ISOWeekYearParser() {
        var _this;
        _classCallCheck5(this, ISOWeekYearParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty4(_assertThisInitialized4(_this), "priority", 130);
        _defineProperty4(_assertThisInitialized4(_this), "incompatibleTokens", [
            'G',
            'y',
            'Y',
            'u',
            'Q',
            'q',
            'M',
            'L',
            'w',
            'd',
            'D',
            'e',
            'c',
            't',
            'T'
        ]);
        return _this;
    }
    _createClass5(ISOWeekYearParser, [
        {
            key: "parse",
            value: function parse(dateString, token) {
                if (token === 'R') {
                    return parseNDigitsSigned(4, dateString);
                }
                return parseNDigitsSigned(token.length, dateString);
            }
        },
        {
            key: "set",
            value: function set(_date, _flags, value) {
                var firstWeekOfYear = new Date(0);
                firstWeekOfYear.setUTCFullYear(value, 0, 4);
                firstWeekOfYear.setUTCHours(0, 0, 0, 0);
                return startOfUTCISOWeek(firstWeekOfYear);
            }
        }
    ]);
    return ISOWeekYearParser;
}(Parser);
function _typeof6(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof6 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof6 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof6(obj);
}
function _classCallCheck6(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties6(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass6(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties6(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties6(Constructor, staticProps);
    return Constructor;
}
function _inherits5(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf5(subClass, superClass);
}
function _setPrototypeOf5(o, p) {
    _setPrototypeOf5 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf5(o, p);
}
function _createSuper5(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct5();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf5(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf5(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn5(this, result);
    };
}
function _possibleConstructorReturn5(self, call) {
    if (call && (_typeof6(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized5(self);
}
function _assertThisInitialized5(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct5() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf5(o) {
    _getPrototypeOf5 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf5(o);
}
function _defineProperty5(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var ExtendedYearParser = function(_Parser) {
    _inherits5(ExtendedYearParser, _Parser);
    var _super = _createSuper5(ExtendedYearParser);
    function ExtendedYearParser() {
        var _this;
        _classCallCheck6(this, ExtendedYearParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty5(_assertThisInitialized5(_this), "priority", 130);
        _defineProperty5(_assertThisInitialized5(_this), "incompatibleTokens", [
            'G',
            'y',
            'Y',
            'R',
            'w',
            'I',
            'i',
            'e',
            'c',
            't',
            'T'
        ]);
        return _this;
    }
    _createClass6(ExtendedYearParser, [
        {
            key: "parse",
            value: function parse(dateString, token) {
                if (token === 'u') {
                    return parseNDigitsSigned(4, dateString);
                }
                return parseNDigitsSigned(token.length, dateString);
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCFullYear(value, 0, 1);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
        }
    ]);
    return ExtendedYearParser;
}(Parser);
function _typeof7(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof7 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof7 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof7(obj);
}
function _classCallCheck7(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties7(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass7(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties7(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties7(Constructor, staticProps);
    return Constructor;
}
function _inherits6(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf6(subClass, superClass);
}
function _setPrototypeOf6(o, p) {
    _setPrototypeOf6 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf6(o, p);
}
function _createSuper6(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct6();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf6(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf6(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn6(this, result);
    };
}
function _possibleConstructorReturn6(self, call) {
    if (call && (_typeof7(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized6(self);
}
function _assertThisInitialized6(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct6() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf6(o) {
    _getPrototypeOf6 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf6(o);
}
function _defineProperty6(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var QuarterParser = function(_Parser) {
    _inherits6(QuarterParser, _Parser);
    var _super = _createSuper6(QuarterParser);
    function QuarterParser() {
        var _this;
        _classCallCheck7(this, QuarterParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty6(_assertThisInitialized6(_this), "priority", 120);
        _defineProperty6(_assertThisInitialized6(_this), "incompatibleTokens", [
            'Y',
            'R',
            'q',
            'M',
            'L',
            'w',
            'I',
            'd',
            'D',
            'i',
            'e',
            'c',
            't',
            'T'
        ]);
        return _this;
    }
    _createClass7(QuarterParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case 'Q':
                    case 'QQ':
                        return parseNDigits(token.length, dateString);
                    case 'Qo':
                        return match.ordinalNumber(dateString, {
                            unit: 'quarter'
                        });
                    case 'QQQ':
                        return match.quarter(dateString, {
                            width: 'abbreviated',
                            context: 'formatting'
                        }) || match.quarter(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        });
                    case 'QQQQQ':
                        return match.quarter(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        });
                    case 'QQQQ':
                    default:
                        return match.quarter(dateString, {
                            width: 'wide',
                            context: 'formatting'
                        }) || match.quarter(dateString, {
                            width: 'abbreviated',
                            context: 'formatting'
                        }) || match.quarter(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        });
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 1 && value <= 4;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCMonth((value - 1) * 3, 1);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
        }
    ]);
    return QuarterParser;
}(Parser);
function _typeof8(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof8 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof8 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof8(obj);
}
function _classCallCheck8(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties8(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass8(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties8(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties8(Constructor, staticProps);
    return Constructor;
}
function _inherits7(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf7(subClass, superClass);
}
function _setPrototypeOf7(o, p) {
    _setPrototypeOf7 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf7(o, p);
}
function _createSuper7(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct7();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf7(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf7(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn7(this, result);
    };
}
function _possibleConstructorReturn7(self, call) {
    if (call && (_typeof8(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized7(self);
}
function _assertThisInitialized7(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct7() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf7(o) {
    _getPrototypeOf7 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf7(o);
}
function _defineProperty7(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var StandAloneQuarterParser = function(_Parser) {
    _inherits7(StandAloneQuarterParser, _Parser);
    var _super = _createSuper7(StandAloneQuarterParser);
    function StandAloneQuarterParser() {
        var _this;
        _classCallCheck8(this, StandAloneQuarterParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty7(_assertThisInitialized7(_this), "priority", 120);
        _defineProperty7(_assertThisInitialized7(_this), "incompatibleTokens", [
            'Y',
            'R',
            'Q',
            'M',
            'L',
            'w',
            'I',
            'd',
            'D',
            'i',
            'e',
            'c',
            't',
            'T'
        ]);
        return _this;
    }
    _createClass8(StandAloneQuarterParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case 'q':
                    case 'qq':
                        return parseNDigits(token.length, dateString);
                    case 'qo':
                        return match.ordinalNumber(dateString, {
                            unit: 'quarter'
                        });
                    case 'qqq':
                        return match.quarter(dateString, {
                            width: 'abbreviated',
                            context: 'standalone'
                        }) || match.quarter(dateString, {
                            width: 'narrow',
                            context: 'standalone'
                        });
                    case 'qqqqq':
                        return match.quarter(dateString, {
                            width: 'narrow',
                            context: 'standalone'
                        });
                    case 'qqqq':
                    default:
                        return match.quarter(dateString, {
                            width: 'wide',
                            context: 'standalone'
                        }) || match.quarter(dateString, {
                            width: 'abbreviated',
                            context: 'standalone'
                        }) || match.quarter(dateString, {
                            width: 'narrow',
                            context: 'standalone'
                        });
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 1 && value <= 4;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCMonth((value - 1) * 3, 1);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
        }
    ]);
    return StandAloneQuarterParser;
}(Parser);
function _typeof9(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof9 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof9 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof9(obj);
}
function _classCallCheck9(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties9(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass9(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties9(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties9(Constructor, staticProps);
    return Constructor;
}
function _inherits8(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf8(subClass, superClass);
}
function _setPrototypeOf8(o, p) {
    _setPrototypeOf8 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf8(o, p);
}
function _createSuper8(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct8();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf8(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf8(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn8(this, result);
    };
}
function _possibleConstructorReturn8(self, call) {
    if (call && (_typeof9(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized8(self);
}
function _assertThisInitialized8(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct8() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf8(o) {
    _getPrototypeOf8 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf8(o);
}
function _defineProperty8(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var MonthParser = function(_Parser) {
    _inherits8(MonthParser, _Parser);
    var _super = _createSuper8(MonthParser);
    function MonthParser() {
        var _this;
        _classCallCheck9(this, MonthParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty8(_assertThisInitialized8(_this), "incompatibleTokens", [
            'Y',
            'R',
            'q',
            'Q',
            'L',
            'w',
            'I',
            'D',
            'i',
            'e',
            'c',
            't',
            'T'
        ]);
        _defineProperty8(_assertThisInitialized8(_this), "priority", 110);
        return _this;
    }
    _createClass9(MonthParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                var valueCallback = function valueCallback(value) {
                    return value - 1;
                };
                switch(token){
                    case 'M':
                        return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
                    case 'MM':
                        return mapValue(parseNDigits(2, dateString), valueCallback);
                    case 'Mo':
                        return mapValue(match.ordinalNumber(dateString, {
                            unit: 'month'
                        }), valueCallback);
                    case 'MMM':
                        return match.month(dateString, {
                            width: 'abbreviated',
                            context: 'formatting'
                        }) || match.month(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        });
                    case 'MMMMM':
                        return match.month(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        });
                    case 'MMMM':
                    default:
                        return match.month(dateString, {
                            width: 'wide',
                            context: 'formatting'
                        }) || match.month(dateString, {
                            width: 'abbreviated',
                            context: 'formatting'
                        }) || match.month(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        });
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 0 && value <= 11;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCMonth(value, 1);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
        }
    ]);
    return MonthParser;
}(Parser);
function _typeof10(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof10 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof10 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof10(obj);
}
function _classCallCheck10(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties10(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass10(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties10(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties10(Constructor, staticProps);
    return Constructor;
}
function _inherits9(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf9(subClass, superClass);
}
function _setPrototypeOf9(o, p) {
    _setPrototypeOf9 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf9(o, p);
}
function _createSuper9(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct9();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf9(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf9(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn9(this, result);
    };
}
function _possibleConstructorReturn9(self, call) {
    if (call && (_typeof10(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized9(self);
}
function _assertThisInitialized9(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct9() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf9(o) {
    _getPrototypeOf9 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf9(o);
}
function _defineProperty9(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var StandAloneMonthParser = function(_Parser) {
    _inherits9(StandAloneMonthParser, _Parser);
    var _super = _createSuper9(StandAloneMonthParser);
    function StandAloneMonthParser() {
        var _this;
        _classCallCheck10(this, StandAloneMonthParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty9(_assertThisInitialized9(_this), "priority", 110);
        _defineProperty9(_assertThisInitialized9(_this), "incompatibleTokens", [
            'Y',
            'R',
            'q',
            'Q',
            'M',
            'w',
            'I',
            'D',
            'i',
            'e',
            'c',
            't',
            'T'
        ]);
        return _this;
    }
    _createClass10(StandAloneMonthParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                var valueCallback = function valueCallback(value) {
                    return value - 1;
                };
                switch(token){
                    case 'L':
                        return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
                    case 'LL':
                        return mapValue(parseNDigits(2, dateString), valueCallback);
                    case 'Lo':
                        return mapValue(match.ordinalNumber(dateString, {
                            unit: 'month'
                        }), valueCallback);
                    case 'LLL':
                        return match.month(dateString, {
                            width: 'abbreviated',
                            context: 'standalone'
                        }) || match.month(dateString, {
                            width: 'narrow',
                            context: 'standalone'
                        });
                    case 'LLLLL':
                        return match.month(dateString, {
                            width: 'narrow',
                            context: 'standalone'
                        });
                    case 'LLLL':
                    default:
                        return match.month(dateString, {
                            width: 'wide',
                            context: 'standalone'
                        }) || match.month(dateString, {
                            width: 'abbreviated',
                            context: 'standalone'
                        }) || match.month(dateString, {
                            width: 'narrow',
                            context: 'standalone'
                        });
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 0 && value <= 11;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCMonth(value, 1);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
        }
    ]);
    return StandAloneMonthParser;
}(Parser);
function setUTCWeek(dirtyDate, dirtyWeek, options) {
    requiredArgs(2, arguments);
    var date = toDate(dirtyDate);
    var week = toInteger1(dirtyWeek);
    var diff = getUTCWeek(date, options) - week;
    date.setUTCDate(date.getUTCDate() - diff * 7);
    return date;
}
function _typeof11(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof11 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof11 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof11(obj);
}
function _classCallCheck11(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties11(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass11(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties11(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties11(Constructor, staticProps);
    return Constructor;
}
function _inherits10(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf10(subClass, superClass);
}
function _setPrototypeOf10(o, p) {
    _setPrototypeOf10 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf10(o, p);
}
function _createSuper10(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct10();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf10(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf10(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn10(this, result);
    };
}
function _possibleConstructorReturn10(self, call) {
    if (call && (_typeof11(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized10(self);
}
function _assertThisInitialized10(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct10() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf10(o) {
    _getPrototypeOf10 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf10(o);
}
function _defineProperty10(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var LocalWeekParser = function(_Parser) {
    _inherits10(LocalWeekParser, _Parser);
    var _super = _createSuper10(LocalWeekParser);
    function LocalWeekParser() {
        var _this;
        _classCallCheck11(this, LocalWeekParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty10(_assertThisInitialized10(_this), "priority", 100);
        _defineProperty10(_assertThisInitialized10(_this), "incompatibleTokens", [
            'y',
            'R',
            'u',
            'q',
            'Q',
            'M',
            'L',
            'I',
            'd',
            'D',
            'i',
            't',
            'T'
        ]);
        return _this;
    }
    _createClass11(LocalWeekParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case 'w':
                        return parseNumericPattern(numericPatterns.week, dateString);
                    case 'wo':
                        return match.ordinalNumber(dateString, {
                            unit: 'week'
                        });
                    default:
                        return parseNDigits(token.length, dateString);
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 1 && value <= 53;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value, options) {
                return startOfUTCWeek(setUTCWeek(date, value, options), options);
            }
        }
    ]);
    return LocalWeekParser;
}(Parser);
function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
    requiredArgs(2, arguments);
    var date = toDate(dirtyDate);
    var isoWeek = toInteger1(dirtyISOWeek);
    var diff = getUTCISOWeek(date) - isoWeek;
    date.setUTCDate(date.getUTCDate() - diff * 7);
    return date;
}
function _typeof12(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof12 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof12 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof12(obj);
}
function _classCallCheck12(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties12(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass12(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties12(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties12(Constructor, staticProps);
    return Constructor;
}
function _inherits11(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf11(subClass, superClass);
}
function _setPrototypeOf11(o, p) {
    _setPrototypeOf11 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf11(o, p);
}
function _createSuper11(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct11();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf11(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf11(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn11(this, result);
    };
}
function _possibleConstructorReturn11(self, call) {
    if (call && (_typeof12(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized11(self);
}
function _assertThisInitialized11(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct11() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf11(o) {
    _getPrototypeOf11 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf11(o);
}
function _defineProperty11(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var ISOWeekParser = function(_Parser) {
    _inherits11(ISOWeekParser, _Parser);
    var _super = _createSuper11(ISOWeekParser);
    function ISOWeekParser() {
        var _this;
        _classCallCheck12(this, ISOWeekParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty11(_assertThisInitialized11(_this), "priority", 100);
        _defineProperty11(_assertThisInitialized11(_this), "incompatibleTokens", [
            'y',
            'Y',
            'u',
            'q',
            'Q',
            'M',
            'L',
            'w',
            'd',
            'D',
            'e',
            'c',
            't',
            'T'
        ]);
        return _this;
    }
    _createClass12(ISOWeekParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case 'I':
                        return parseNumericPattern(numericPatterns.week, dateString);
                    case 'Io':
                        return match.ordinalNumber(dateString, {
                            unit: 'week'
                        });
                    default:
                        return parseNDigits(token.length, dateString);
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 1 && value <= 53;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                return startOfUTCISOWeek(setUTCISOWeek(date, value));
            }
        }
    ]);
    return ISOWeekParser;
}(Parser);
function _typeof13(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof13 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof13 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof13(obj);
}
function _classCallCheck13(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties13(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass13(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties13(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties13(Constructor, staticProps);
    return Constructor;
}
function _inherits12(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf12(subClass, superClass);
}
function _setPrototypeOf12(o, p) {
    _setPrototypeOf12 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf12(o, p);
}
function _createSuper12(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct12();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf12(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf12(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn12(this, result);
    };
}
function _possibleConstructorReturn12(self, call) {
    if (call && (_typeof13(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized12(self);
}
function _assertThisInitialized12(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct12() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf12(o) {
    _getPrototypeOf12 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf12(o);
}
function _defineProperty12(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var DAYS_IN_MONTH = [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
];
var DAYS_IN_MONTH_LEAP_YEAR = [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
];
var DateParser = function(_Parser) {
    _inherits12(DateParser, _Parser);
    var _super = _createSuper12(DateParser);
    function DateParser() {
        var _this;
        _classCallCheck13(this, DateParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty12(_assertThisInitialized12(_this), "priority", 90);
        _defineProperty12(_assertThisInitialized12(_this), "subPriority", 1);
        _defineProperty12(_assertThisInitialized12(_this), "incompatibleTokens", [
            'Y',
            'R',
            'q',
            'Q',
            'w',
            'I',
            'D',
            'i',
            'e',
            'c',
            't',
            'T'
        ]);
        return _this;
    }
    _createClass13(DateParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case 'd':
                        return parseNumericPattern(numericPatterns.date, dateString);
                    case 'do':
                        return match.ordinalNumber(dateString, {
                            unit: 'date'
                        });
                    default:
                        return parseNDigits(token.length, dateString);
                }
            }
        },
        {
            key: "validate",
            value: function validate(date, value) {
                var year = date.getUTCFullYear();
                var isLeapYear = isLeapYearIndex(year);
                var month = date.getUTCMonth();
                if (isLeapYear) {
                    return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
                } else {
                    return value >= 1 && value <= DAYS_IN_MONTH[month];
                }
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCDate(value);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
        }
    ]);
    return DateParser;
}(Parser);
function _typeof14(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof14 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof14 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof14(obj);
}
function _classCallCheck14(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties14(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass14(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties14(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties14(Constructor, staticProps);
    return Constructor;
}
function _inherits13(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf13(subClass, superClass);
}
function _setPrototypeOf13(o, p) {
    _setPrototypeOf13 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf13(o, p);
}
function _createSuper13(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct13();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf13(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf13(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn13(this, result);
    };
}
function _possibleConstructorReturn13(self, call) {
    if (call && (_typeof14(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized13(self);
}
function _assertThisInitialized13(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct13() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf13(o) {
    _getPrototypeOf13 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf13(o);
}
function _defineProperty13(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var DayOfYearParser = function(_Parser) {
    _inherits13(DayOfYearParser, _Parser);
    var _super = _createSuper13(DayOfYearParser);
    function DayOfYearParser() {
        var _this;
        _classCallCheck14(this, DayOfYearParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty13(_assertThisInitialized13(_this), "priority", 90);
        _defineProperty13(_assertThisInitialized13(_this), "subpriority", 1);
        _defineProperty13(_assertThisInitialized13(_this), "incompatibleTokens", [
            'Y',
            'R',
            'q',
            'Q',
            'M',
            'L',
            'w',
            'I',
            'd',
            'E',
            'i',
            'e',
            'c',
            't',
            'T'
        ]);
        return _this;
    }
    _createClass14(DayOfYearParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case 'D':
                    case 'DD':
                        return parseNumericPattern(numericPatterns.dayOfYear, dateString);
                    case 'Do':
                        return match.ordinalNumber(dateString, {
                            unit: 'date'
                        });
                    default:
                        return parseNDigits(token.length, dateString);
                }
            }
        },
        {
            key: "validate",
            value: function validate(date, value) {
                var year = date.getUTCFullYear();
                var isLeapYear = isLeapYearIndex(year);
                if (isLeapYear) {
                    return value >= 1 && value <= 366;
                } else {
                    return value >= 1 && value <= 365;
                }
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCMonth(0, value);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
        }
    ]);
    return DayOfYearParser;
}(Parser);
function setUTCDay(dirtyDate, dirtyDay, options) {
    var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    requiredArgs(2, arguments);
    var defaultOptions = getDefaultOptions();
    var weekStartsOn = toInteger1((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
    }
    var date = toDate(dirtyDate);
    var day = toInteger1(dirtyDay);
    var currentDay = date.getUTCDay();
    var remainder = day % 7;
    var dayIndex = (remainder + 7) % 7;
    var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
}
function _typeof15(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof15 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof15 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof15(obj);
}
function _classCallCheck15(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties15(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass15(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties15(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties15(Constructor, staticProps);
    return Constructor;
}
function _inherits14(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf14(subClass, superClass);
}
function _setPrototypeOf14(o, p) {
    _setPrototypeOf14 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf14(o, p);
}
function _createSuper14(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct14();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf14(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf14(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn14(this, result);
    };
}
function _possibleConstructorReturn14(self, call) {
    if (call && (_typeof15(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized14(self);
}
function _assertThisInitialized14(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct14() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf14(o) {
    _getPrototypeOf14 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf14(o);
}
function _defineProperty14(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var DayParser = function(_Parser) {
    _inherits14(DayParser, _Parser);
    var _super = _createSuper14(DayParser);
    function DayParser() {
        var _this;
        _classCallCheck15(this, DayParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty14(_assertThisInitialized14(_this), "priority", 90);
        _defineProperty14(_assertThisInitialized14(_this), "incompatibleTokens", [
            'D',
            'i',
            'e',
            'c',
            't',
            'T'
        ]);
        return _this;
    }
    _createClass15(DayParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case 'E':
                    case 'EE':
                    case 'EEE':
                        return match.day(dateString, {
                            width: 'abbreviated',
                            context: 'formatting'
                        }) || match.day(dateString, {
                            width: 'short',
                            context: 'formatting'
                        }) || match.day(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        });
                    case 'EEEEE':
                        return match.day(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        });
                    case 'EEEEEE':
                        return match.day(dateString, {
                            width: 'short',
                            context: 'formatting'
                        }) || match.day(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        });
                    case 'EEEE':
                    default:
                        return match.day(dateString, {
                            width: 'wide',
                            context: 'formatting'
                        }) || match.day(dateString, {
                            width: 'abbreviated',
                            context: 'formatting'
                        }) || match.day(dateString, {
                            width: 'short',
                            context: 'formatting'
                        }) || match.day(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        });
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 0 && value <= 6;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value, options) {
                date = setUTCDay(date, value, options);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
        }
    ]);
    return DayParser;
}(Parser);
function _typeof16(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof16 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof16 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof16(obj);
}
function _classCallCheck16(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties16(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass16(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties16(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties16(Constructor, staticProps);
    return Constructor;
}
function _inherits15(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf15(subClass, superClass);
}
function _setPrototypeOf15(o, p) {
    _setPrototypeOf15 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf15(o, p);
}
function _createSuper15(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct15();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf15(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf15(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn15(this, result);
    };
}
function _possibleConstructorReturn15(self, call) {
    if (call && (_typeof16(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized15(self);
}
function _assertThisInitialized15(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct15() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf15(o) {
    _getPrototypeOf15 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf15(o);
}
function _defineProperty15(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var LocalDayParser = function(_Parser) {
    _inherits15(LocalDayParser, _Parser);
    var _super = _createSuper15(LocalDayParser);
    function LocalDayParser() {
        var _this;
        _classCallCheck16(this, LocalDayParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty15(_assertThisInitialized15(_this), "priority", 90);
        _defineProperty15(_assertThisInitialized15(_this), "incompatibleTokens", [
            'y',
            'R',
            'u',
            'q',
            'Q',
            'M',
            'L',
            'I',
            'd',
            'D',
            'E',
            'i',
            'c',
            't',
            'T'
        ]);
        return _this;
    }
    _createClass16(LocalDayParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match, options) {
                var valueCallback = function valueCallback(value) {
                    var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
                    return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
                };
                switch(token){
                    case 'e':
                    case 'ee':
                        return mapValue(parseNDigits(token.length, dateString), valueCallback);
                    case 'eo':
                        return mapValue(match.ordinalNumber(dateString, {
                            unit: 'day'
                        }), valueCallback);
                    case 'eee':
                        return match.day(dateString, {
                            width: 'abbreviated',
                            context: 'formatting'
                        }) || match.day(dateString, {
                            width: 'short',
                            context: 'formatting'
                        }) || match.day(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        });
                    case 'eeeee':
                        return match.day(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        });
                    case 'eeeeee':
                        return match.day(dateString, {
                            width: 'short',
                            context: 'formatting'
                        }) || match.day(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        });
                    case 'eeee':
                    default:
                        return match.day(dateString, {
                            width: 'wide',
                            context: 'formatting'
                        }) || match.day(dateString, {
                            width: 'abbreviated',
                            context: 'formatting'
                        }) || match.day(dateString, {
                            width: 'short',
                            context: 'formatting'
                        }) || match.day(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        });
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 0 && value <= 6;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value, options) {
                date = setUTCDay(date, value, options);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
        }
    ]);
    return LocalDayParser;
}(Parser);
function _typeof17(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof17 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof17 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof17(obj);
}
function _classCallCheck17(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties17(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass17(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties17(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties17(Constructor, staticProps);
    return Constructor;
}
function _inherits16(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf16(subClass, superClass);
}
function _setPrototypeOf16(o, p) {
    _setPrototypeOf16 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf16(o, p);
}
function _createSuper16(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct16();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf16(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf16(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn16(this, result);
    };
}
function _possibleConstructorReturn16(self, call) {
    if (call && (_typeof17(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized16(self);
}
function _assertThisInitialized16(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct16() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf16(o) {
    _getPrototypeOf16 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf16(o);
}
function _defineProperty16(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var StandAloneLocalDayParser = function(_Parser) {
    _inherits16(StandAloneLocalDayParser, _Parser);
    var _super = _createSuper16(StandAloneLocalDayParser);
    function StandAloneLocalDayParser() {
        var _this;
        _classCallCheck17(this, StandAloneLocalDayParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty16(_assertThisInitialized16(_this), "priority", 90);
        _defineProperty16(_assertThisInitialized16(_this), "incompatibleTokens", [
            'y',
            'R',
            'u',
            'q',
            'Q',
            'M',
            'L',
            'I',
            'd',
            'D',
            'E',
            'i',
            'e',
            't',
            'T'
        ]);
        return _this;
    }
    _createClass17(StandAloneLocalDayParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match, options) {
                var valueCallback = function valueCallback(value) {
                    var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
                    return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
                };
                switch(token){
                    case 'c':
                    case 'cc':
                        return mapValue(parseNDigits(token.length, dateString), valueCallback);
                    case 'co':
                        return mapValue(match.ordinalNumber(dateString, {
                            unit: 'day'
                        }), valueCallback);
                    case 'ccc':
                        return match.day(dateString, {
                            width: 'abbreviated',
                            context: 'standalone'
                        }) || match.day(dateString, {
                            width: 'short',
                            context: 'standalone'
                        }) || match.day(dateString, {
                            width: 'narrow',
                            context: 'standalone'
                        });
                    case 'ccccc':
                        return match.day(dateString, {
                            width: 'narrow',
                            context: 'standalone'
                        });
                    case 'cccccc':
                        return match.day(dateString, {
                            width: 'short',
                            context: 'standalone'
                        }) || match.day(dateString, {
                            width: 'narrow',
                            context: 'standalone'
                        });
                    case 'cccc':
                    default:
                        return match.day(dateString, {
                            width: 'wide',
                            context: 'standalone'
                        }) || match.day(dateString, {
                            width: 'abbreviated',
                            context: 'standalone'
                        }) || match.day(dateString, {
                            width: 'short',
                            context: 'standalone'
                        }) || match.day(dateString, {
                            width: 'narrow',
                            context: 'standalone'
                        });
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 0 && value <= 6;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value, options) {
                date = setUTCDay(date, value, options);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
        }
    ]);
    return StandAloneLocalDayParser;
}(Parser);
function setUTCISODay(dirtyDate, dirtyDay) {
    requiredArgs(2, arguments);
    var day = toInteger1(dirtyDay);
    if (day % 7 === 0) {
        day = day - 7;
    }
    var weekStartsOn = 1;
    var date = toDate(dirtyDate);
    var currentDay = date.getUTCDay();
    var remainder = day % 7;
    var dayIndex = (remainder + 7) % 7;
    var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
}
function _typeof18(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof18 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof18 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof18(obj);
}
function _classCallCheck18(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties18(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass18(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties18(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties18(Constructor, staticProps);
    return Constructor;
}
function _inherits17(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf17(subClass, superClass);
}
function _setPrototypeOf17(o, p) {
    _setPrototypeOf17 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf17(o, p);
}
function _createSuper17(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct17();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf17(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf17(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn17(this, result);
    };
}
function _possibleConstructorReturn17(self, call) {
    if (call && (_typeof18(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized17(self);
}
function _assertThisInitialized17(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct17() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf17(o) {
    _getPrototypeOf17 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf17(o);
}
function _defineProperty17(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var ISODayParser = function(_Parser) {
    _inherits17(ISODayParser, _Parser);
    var _super = _createSuper17(ISODayParser);
    function ISODayParser() {
        var _this;
        _classCallCheck18(this, ISODayParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty17(_assertThisInitialized17(_this), "priority", 90);
        _defineProperty17(_assertThisInitialized17(_this), "incompatibleTokens", [
            'y',
            'Y',
            'u',
            'q',
            'Q',
            'M',
            'L',
            'w',
            'd',
            'D',
            'E',
            'e',
            'c',
            't',
            'T'
        ]);
        return _this;
    }
    _createClass18(ISODayParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                var valueCallback = function valueCallback(value) {
                    if (value === 0) {
                        return 7;
                    }
                    return value;
                };
                switch(token){
                    case 'i':
                    case 'ii':
                        return parseNDigits(token.length, dateString);
                    case 'io':
                        return match.ordinalNumber(dateString, {
                            unit: 'day'
                        });
                    case 'iii':
                        return mapValue(match.day(dateString, {
                            width: 'abbreviated',
                            context: 'formatting'
                        }) || match.day(dateString, {
                            width: 'short',
                            context: 'formatting'
                        }) || match.day(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        }), valueCallback);
                    case 'iiiii':
                        return mapValue(match.day(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        }), valueCallback);
                    case 'iiiiii':
                        return mapValue(match.day(dateString, {
                            width: 'short',
                            context: 'formatting'
                        }) || match.day(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        }), valueCallback);
                    case 'iiii':
                    default:
                        return mapValue(match.day(dateString, {
                            width: 'wide',
                            context: 'formatting'
                        }) || match.day(dateString, {
                            width: 'abbreviated',
                            context: 'formatting'
                        }) || match.day(dateString, {
                            width: 'short',
                            context: 'formatting'
                        }) || match.day(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        }), valueCallback);
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 1 && value <= 7;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date = setUTCISODay(date, value);
                date.setUTCHours(0, 0, 0, 0);
                return date;
            }
        }
    ]);
    return ISODayParser;
}(Parser);
function _typeof19(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof19 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof19 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof19(obj);
}
function _classCallCheck19(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties19(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass19(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties19(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties19(Constructor, staticProps);
    return Constructor;
}
function _inherits18(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf18(subClass, superClass);
}
function _setPrototypeOf18(o, p) {
    _setPrototypeOf18 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf18(o, p);
}
function _createSuper18(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct18();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf18(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf18(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn18(this, result);
    };
}
function _possibleConstructorReturn18(self, call) {
    if (call && (_typeof19(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized18(self);
}
function _assertThisInitialized18(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct18() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf18(o) {
    _getPrototypeOf18 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf18(o);
}
function _defineProperty18(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var AMPMParser = function(_Parser) {
    _inherits18(AMPMParser, _Parser);
    var _super = _createSuper18(AMPMParser);
    function AMPMParser() {
        var _this;
        _classCallCheck19(this, AMPMParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty18(_assertThisInitialized18(_this), "priority", 80);
        _defineProperty18(_assertThisInitialized18(_this), "incompatibleTokens", [
            'b',
            'B',
            'H',
            'k',
            't',
            'T'
        ]);
        return _this;
    }
    _createClass19(AMPMParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case 'a':
                    case 'aa':
                    case 'aaa':
                        return match.dayPeriod(dateString, {
                            width: 'abbreviated',
                            context: 'formatting'
                        }) || match.dayPeriod(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        });
                    case 'aaaaa':
                        return match.dayPeriod(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        });
                    case 'aaaa':
                    default:
                        return match.dayPeriod(dateString, {
                            width: 'wide',
                            context: 'formatting'
                        }) || match.dayPeriod(dateString, {
                            width: 'abbreviated',
                            context: 'formatting'
                        }) || match.dayPeriod(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        });
                }
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
                return date;
            }
        }
    ]);
    return AMPMParser;
}(Parser);
function _typeof20(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof20 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof20 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof20(obj);
}
function _classCallCheck20(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties20(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass20(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties20(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties20(Constructor, staticProps);
    return Constructor;
}
function _inherits19(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf19(subClass, superClass);
}
function _setPrototypeOf19(o, p) {
    _setPrototypeOf19 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf19(o, p);
}
function _createSuper19(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct19();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf19(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf19(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn19(this, result);
    };
}
function _possibleConstructorReturn19(self, call) {
    if (call && (_typeof20(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized19(self);
}
function _assertThisInitialized19(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct19() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf19(o) {
    _getPrototypeOf19 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf19(o);
}
function _defineProperty19(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var AMPMMidnightParser = function(_Parser) {
    _inherits19(AMPMMidnightParser, _Parser);
    var _super = _createSuper19(AMPMMidnightParser);
    function AMPMMidnightParser() {
        var _this;
        _classCallCheck20(this, AMPMMidnightParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty19(_assertThisInitialized19(_this), "priority", 80);
        _defineProperty19(_assertThisInitialized19(_this), "incompatibleTokens", [
            'a',
            'B',
            'H',
            'k',
            't',
            'T'
        ]);
        return _this;
    }
    _createClass20(AMPMMidnightParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case 'b':
                    case 'bb':
                    case 'bbb':
                        return match.dayPeriod(dateString, {
                            width: 'abbreviated',
                            context: 'formatting'
                        }) || match.dayPeriod(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        });
                    case 'bbbbb':
                        return match.dayPeriod(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        });
                    case 'bbbb':
                    default:
                        return match.dayPeriod(dateString, {
                            width: 'wide',
                            context: 'formatting'
                        }) || match.dayPeriod(dateString, {
                            width: 'abbreviated',
                            context: 'formatting'
                        }) || match.dayPeriod(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        });
                }
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
                return date;
            }
        }
    ]);
    return AMPMMidnightParser;
}(Parser);
function _typeof21(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof21 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof21 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof21(obj);
}
function _classCallCheck21(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties21(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass21(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties21(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties21(Constructor, staticProps);
    return Constructor;
}
function _inherits20(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf20(subClass, superClass);
}
function _setPrototypeOf20(o, p) {
    _setPrototypeOf20 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf20(o, p);
}
function _createSuper20(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct20();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf20(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf20(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn20(this, result);
    };
}
function _possibleConstructorReturn20(self, call) {
    if (call && (_typeof21(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized20(self);
}
function _assertThisInitialized20(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct20() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf20(o) {
    _getPrototypeOf20 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf20(o);
}
function _defineProperty20(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var DayPeriodParser = function(_Parser) {
    _inherits20(DayPeriodParser, _Parser);
    var _super = _createSuper20(DayPeriodParser);
    function DayPeriodParser() {
        var _this;
        _classCallCheck21(this, DayPeriodParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty20(_assertThisInitialized20(_this), "priority", 80);
        _defineProperty20(_assertThisInitialized20(_this), "incompatibleTokens", [
            'a',
            'b',
            't',
            'T'
        ]);
        return _this;
    }
    _createClass21(DayPeriodParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case 'B':
                    case 'BB':
                    case 'BBB':
                        return match.dayPeriod(dateString, {
                            width: 'abbreviated',
                            context: 'formatting'
                        }) || match.dayPeriod(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        });
                    case 'BBBBB':
                        return match.dayPeriod(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        });
                    case 'BBBB':
                    default:
                        return match.dayPeriod(dateString, {
                            width: 'wide',
                            context: 'formatting'
                        }) || match.dayPeriod(dateString, {
                            width: 'abbreviated',
                            context: 'formatting'
                        }) || match.dayPeriod(dateString, {
                            width: 'narrow',
                            context: 'formatting'
                        });
                }
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
                return date;
            }
        }
    ]);
    return DayPeriodParser;
}(Parser);
function _typeof22(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof22 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof22 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof22(obj);
}
function _classCallCheck22(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties22(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass22(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties22(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties22(Constructor, staticProps);
    return Constructor;
}
function _inherits21(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf21(subClass, superClass);
}
function _setPrototypeOf21(o, p) {
    _setPrototypeOf21 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf21(o, p);
}
function _createSuper21(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct21();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf21(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf21(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn21(this, result);
    };
}
function _possibleConstructorReturn21(self, call) {
    if (call && (_typeof22(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized21(self);
}
function _assertThisInitialized21(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct21() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf21(o) {
    _getPrototypeOf21 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf21(o);
}
function _defineProperty21(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var Hour1to12Parser = function(_Parser) {
    _inherits21(Hour1to12Parser, _Parser);
    var _super = _createSuper21(Hour1to12Parser);
    function Hour1to12Parser() {
        var _this;
        _classCallCheck22(this, Hour1to12Parser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty21(_assertThisInitialized21(_this), "priority", 70);
        _defineProperty21(_assertThisInitialized21(_this), "incompatibleTokens", [
            'H',
            'K',
            'k',
            't',
            'T'
        ]);
        return _this;
    }
    _createClass22(Hour1to12Parser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case 'h':
                        return parseNumericPattern(numericPatterns.hour12h, dateString);
                    case 'ho':
                        return match.ordinalNumber(dateString, {
                            unit: 'hour'
                        });
                    default:
                        return parseNDigits(token.length, dateString);
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 1 && value <= 12;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                var isPM = date.getUTCHours() >= 12;
                if (isPM && value < 12) {
                    date.setUTCHours(value + 12, 0, 0, 0);
                } else if (!isPM && value === 12) {
                    date.setUTCHours(0, 0, 0, 0);
                } else {
                    date.setUTCHours(value, 0, 0, 0);
                }
                return date;
            }
        }
    ]);
    return Hour1to12Parser;
}(Parser);
function _typeof23(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof23 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof23 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof23(obj);
}
function _classCallCheck23(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties23(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass23(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties23(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties23(Constructor, staticProps);
    return Constructor;
}
function _inherits22(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf22(subClass, superClass);
}
function _setPrototypeOf22(o, p) {
    _setPrototypeOf22 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf22(o, p);
}
function _createSuper22(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct22();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf22(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf22(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn22(this, result);
    };
}
function _possibleConstructorReturn22(self, call) {
    if (call && (_typeof23(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized22(self);
}
function _assertThisInitialized22(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct22() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf22(o) {
    _getPrototypeOf22 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf22(o);
}
function _defineProperty22(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var Hour0to23Parser = function(_Parser) {
    _inherits22(Hour0to23Parser, _Parser);
    var _super = _createSuper22(Hour0to23Parser);
    function Hour0to23Parser() {
        var _this;
        _classCallCheck23(this, Hour0to23Parser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty22(_assertThisInitialized22(_this), "priority", 70);
        _defineProperty22(_assertThisInitialized22(_this), "incompatibleTokens", [
            'a',
            'b',
            'h',
            'K',
            'k',
            't',
            'T'
        ]);
        return _this;
    }
    _createClass23(Hour0to23Parser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case 'H':
                        return parseNumericPattern(numericPatterns.hour23h, dateString);
                    case 'Ho':
                        return match.ordinalNumber(dateString, {
                            unit: 'hour'
                        });
                    default:
                        return parseNDigits(token.length, dateString);
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 0 && value <= 23;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCHours(value, 0, 0, 0);
                return date;
            }
        }
    ]);
    return Hour0to23Parser;
}(Parser);
function _typeof24(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof24 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof24 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof24(obj);
}
function _classCallCheck24(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties24(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass24(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties24(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties24(Constructor, staticProps);
    return Constructor;
}
function _inherits23(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf23(subClass, superClass);
}
function _setPrototypeOf23(o, p) {
    _setPrototypeOf23 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf23(o, p);
}
function _createSuper23(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct23();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf23(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf23(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn23(this, result);
    };
}
function _possibleConstructorReturn23(self, call) {
    if (call && (_typeof24(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized23(self);
}
function _assertThisInitialized23(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct23() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf23(o) {
    _getPrototypeOf23 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf23(o);
}
function _defineProperty23(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var Hour0To11Parser = function(_Parser) {
    _inherits23(Hour0To11Parser, _Parser);
    var _super = _createSuper23(Hour0To11Parser);
    function Hour0To11Parser() {
        var _this;
        _classCallCheck24(this, Hour0To11Parser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty23(_assertThisInitialized23(_this), "priority", 70);
        _defineProperty23(_assertThisInitialized23(_this), "incompatibleTokens", [
            'h',
            'H',
            'k',
            't',
            'T'
        ]);
        return _this;
    }
    _createClass24(Hour0To11Parser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case 'K':
                        return parseNumericPattern(numericPatterns.hour11h, dateString);
                    case 'Ko':
                        return match.ordinalNumber(dateString, {
                            unit: 'hour'
                        });
                    default:
                        return parseNDigits(token.length, dateString);
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 0 && value <= 11;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                var isPM = date.getUTCHours() >= 12;
                if (isPM && value < 12) {
                    date.setUTCHours(value + 12, 0, 0, 0);
                } else {
                    date.setUTCHours(value, 0, 0, 0);
                }
                return date;
            }
        }
    ]);
    return Hour0To11Parser;
}(Parser);
function _typeof25(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof25 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof25 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof25(obj);
}
function _classCallCheck25(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties25(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass25(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties25(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties25(Constructor, staticProps);
    return Constructor;
}
function _inherits24(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf24(subClass, superClass);
}
function _setPrototypeOf24(o, p) {
    _setPrototypeOf24 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf24(o, p);
}
function _createSuper24(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct24();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf24(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf24(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn24(this, result);
    };
}
function _possibleConstructorReturn24(self, call) {
    if (call && (_typeof25(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized24(self);
}
function _assertThisInitialized24(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct24() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf24(o) {
    _getPrototypeOf24 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf24(o);
}
function _defineProperty24(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var Hour1To24Parser = function(_Parser) {
    _inherits24(Hour1To24Parser, _Parser);
    var _super = _createSuper24(Hour1To24Parser);
    function Hour1To24Parser() {
        var _this;
        _classCallCheck25(this, Hour1To24Parser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty24(_assertThisInitialized24(_this), "priority", 70);
        _defineProperty24(_assertThisInitialized24(_this), "incompatibleTokens", [
            'a',
            'b',
            'h',
            'H',
            'K',
            't',
            'T'
        ]);
        return _this;
    }
    _createClass25(Hour1To24Parser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case 'k':
                        return parseNumericPattern(numericPatterns.hour24h, dateString);
                    case 'ko':
                        return match.ordinalNumber(dateString, {
                            unit: 'hour'
                        });
                    default:
                        return parseNDigits(token.length, dateString);
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 1 && value <= 24;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                var hours = value <= 24 ? value % 24 : value;
                date.setUTCHours(hours, 0, 0, 0);
                return date;
            }
        }
    ]);
    return Hour1To24Parser;
}(Parser);
function _typeof26(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof26 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof26 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof26(obj);
}
function _classCallCheck26(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties26(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass26(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties26(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties26(Constructor, staticProps);
    return Constructor;
}
function _inherits25(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf25(subClass, superClass);
}
function _setPrototypeOf25(o, p) {
    _setPrototypeOf25 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf25(o, p);
}
function _createSuper25(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct25();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf25(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf25(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn25(this, result);
    };
}
function _possibleConstructorReturn25(self, call) {
    if (call && (_typeof26(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized25(self);
}
function _assertThisInitialized25(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct25() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf25(o) {
    _getPrototypeOf25 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf25(o);
}
function _defineProperty25(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var MinuteParser = function(_Parser) {
    _inherits25(MinuteParser, _Parser);
    var _super = _createSuper25(MinuteParser);
    function MinuteParser() {
        var _this;
        _classCallCheck26(this, MinuteParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty25(_assertThisInitialized25(_this), "priority", 60);
        _defineProperty25(_assertThisInitialized25(_this), "incompatibleTokens", [
            't',
            'T'
        ]);
        return _this;
    }
    _createClass26(MinuteParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case 'm':
                        return parseNumericPattern(numericPatterns.minute, dateString);
                    case 'mo':
                        return match.ordinalNumber(dateString, {
                            unit: 'minute'
                        });
                    default:
                        return parseNDigits(token.length, dateString);
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 0 && value <= 59;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCMinutes(value, 0, 0);
                return date;
            }
        }
    ]);
    return MinuteParser;
}(Parser);
function _typeof27(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof27 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof27 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof27(obj);
}
function _classCallCheck27(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties27(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass27(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties27(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties27(Constructor, staticProps);
    return Constructor;
}
function _inherits26(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf26(subClass, superClass);
}
function _setPrototypeOf26(o, p) {
    _setPrototypeOf26 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf26(o, p);
}
function _createSuper26(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct26();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf26(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf26(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn26(this, result);
    };
}
function _possibleConstructorReturn26(self, call) {
    if (call && (_typeof27(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized26(self);
}
function _assertThisInitialized26(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct26() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf26(o) {
    _getPrototypeOf26 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf26(o);
}
function _defineProperty26(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var SecondParser = function(_Parser) {
    _inherits26(SecondParser, _Parser);
    var _super = _createSuper26(SecondParser);
    function SecondParser() {
        var _this;
        _classCallCheck27(this, SecondParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty26(_assertThisInitialized26(_this), "priority", 50);
        _defineProperty26(_assertThisInitialized26(_this), "incompatibleTokens", [
            't',
            'T'
        ]);
        return _this;
    }
    _createClass27(SecondParser, [
        {
            key: "parse",
            value: function parse(dateString, token, match) {
                switch(token){
                    case 's':
                        return parseNumericPattern(numericPatterns.second, dateString);
                    case 'so':
                        return match.ordinalNumber(dateString, {
                            unit: 'second'
                        });
                    default:
                        return parseNDigits(token.length, dateString);
                }
            }
        },
        {
            key: "validate",
            value: function validate(_date, value) {
                return value >= 0 && value <= 59;
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCSeconds(value, 0);
                return date;
            }
        }
    ]);
    return SecondParser;
}(Parser);
function _typeof28(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof28 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof28 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof28(obj);
}
function _classCallCheck28(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties28(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass28(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties28(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties28(Constructor, staticProps);
    return Constructor;
}
function _inherits27(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf27(subClass, superClass);
}
function _setPrototypeOf27(o, p) {
    _setPrototypeOf27 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf27(o, p);
}
function _createSuper27(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct27();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf27(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf27(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn27(this, result);
    };
}
function _possibleConstructorReturn27(self, call) {
    if (call && (_typeof28(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized27(self);
}
function _assertThisInitialized27(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct27() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf27(o) {
    _getPrototypeOf27 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf27(o);
}
function _defineProperty27(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var FractionOfSecondParser = function(_Parser) {
    _inherits27(FractionOfSecondParser, _Parser);
    var _super = _createSuper27(FractionOfSecondParser);
    function FractionOfSecondParser() {
        var _this;
        _classCallCheck28(this, FractionOfSecondParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty27(_assertThisInitialized27(_this), "priority", 30);
        _defineProperty27(_assertThisInitialized27(_this), "incompatibleTokens", [
            't',
            'T'
        ]);
        return _this;
    }
    _createClass28(FractionOfSecondParser, [
        {
            key: "parse",
            value: function parse(dateString, token) {
                var valueCallback = function valueCallback(value) {
                    return Math.floor(value * Math.pow(10, -token.length + 3));
                };
                return mapValue(parseNDigits(token.length, dateString), valueCallback);
            }
        },
        {
            key: "set",
            value: function set(date, _flags, value) {
                date.setUTCMilliseconds(value);
                return date;
            }
        }
    ]);
    return FractionOfSecondParser;
}(Parser);
function _typeof29(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof29 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof29 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof29(obj);
}
function _classCallCheck29(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties29(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass29(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties29(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties29(Constructor, staticProps);
    return Constructor;
}
function _inherits28(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf28(subClass, superClass);
}
function _setPrototypeOf28(o, p) {
    _setPrototypeOf28 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf28(o, p);
}
function _createSuper28(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct28();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf28(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf28(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn28(this, result);
    };
}
function _possibleConstructorReturn28(self, call) {
    if (call && (_typeof29(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized28(self);
}
function _assertThisInitialized28(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct28() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf28(o) {
    _getPrototypeOf28 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf28(o);
}
function _defineProperty28(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var ISOTimezoneWithZParser = function(_Parser) {
    _inherits28(ISOTimezoneWithZParser, _Parser);
    var _super = _createSuper28(ISOTimezoneWithZParser);
    function ISOTimezoneWithZParser() {
        var _this;
        _classCallCheck29(this, ISOTimezoneWithZParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty28(_assertThisInitialized28(_this), "priority", 10);
        _defineProperty28(_assertThisInitialized28(_this), "incompatibleTokens", [
            't',
            'T',
            'x'
        ]);
        return _this;
    }
    _createClass29(ISOTimezoneWithZParser, [
        {
            key: "parse",
            value: function parse(dateString, token) {
                switch(token){
                    case 'X':
                        return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
                    case 'XX':
                        return parseTimezonePattern(timezonePatterns.basic, dateString);
                    case 'XXXX':
                        return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
                    case 'XXXXX':
                        return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
                    case 'XXX':
                    default:
                        return parseTimezonePattern(timezonePatterns.extended, dateString);
                }
            }
        },
        {
            key: "set",
            value: function set(date, flags, value) {
                if (flags.timestampIsSet) {
                    return date;
                }
                return new Date(date.getTime() - value);
            }
        }
    ]);
    return ISOTimezoneWithZParser;
}(Parser);
function _typeof30(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof30 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof30 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof30(obj);
}
function _classCallCheck30(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties30(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass30(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties30(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties30(Constructor, staticProps);
    return Constructor;
}
function _inherits29(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf29(subClass, superClass);
}
function _setPrototypeOf29(o, p) {
    _setPrototypeOf29 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf29(o, p);
}
function _createSuper29(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct29();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf29(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf29(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn29(this, result);
    };
}
function _possibleConstructorReturn29(self, call) {
    if (call && (_typeof30(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized29(self);
}
function _assertThisInitialized29(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct29() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf29(o) {
    _getPrototypeOf29 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf29(o);
}
function _defineProperty29(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var ISOTimezoneParser = function(_Parser) {
    _inherits29(ISOTimezoneParser, _Parser);
    var _super = _createSuper29(ISOTimezoneParser);
    function ISOTimezoneParser() {
        var _this;
        _classCallCheck30(this, ISOTimezoneParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty29(_assertThisInitialized29(_this), "priority", 10);
        _defineProperty29(_assertThisInitialized29(_this), "incompatibleTokens", [
            't',
            'T',
            'X'
        ]);
        return _this;
    }
    _createClass30(ISOTimezoneParser, [
        {
            key: "parse",
            value: function parse(dateString, token) {
                switch(token){
                    case 'x':
                        return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
                    case 'xx':
                        return parseTimezonePattern(timezonePatterns.basic, dateString);
                    case 'xxxx':
                        return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
                    case 'xxxxx':
                        return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
                    case 'xxx':
                    default:
                        return parseTimezonePattern(timezonePatterns.extended, dateString);
                }
            }
        },
        {
            key: "set",
            value: function set(date, flags, value) {
                if (flags.timestampIsSet) {
                    return date;
                }
                return new Date(date.getTime() - value);
            }
        }
    ]);
    return ISOTimezoneParser;
}(Parser);
function _typeof31(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof31 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof31 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof31(obj);
}
function _classCallCheck31(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties31(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass31(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties31(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties31(Constructor, staticProps);
    return Constructor;
}
function _inherits30(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf30(subClass, superClass);
}
function _setPrototypeOf30(o, p) {
    _setPrototypeOf30 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf30(o, p);
}
function _createSuper30(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct30();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf30(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf30(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn30(this, result);
    };
}
function _possibleConstructorReturn30(self, call) {
    if (call && (_typeof31(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized30(self);
}
function _assertThisInitialized30(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct30() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf30(o) {
    _getPrototypeOf30 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf30(o);
}
function _defineProperty30(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var TimestampSecondsParser = function(_Parser) {
    _inherits30(TimestampSecondsParser, _Parser);
    var _super = _createSuper30(TimestampSecondsParser);
    function TimestampSecondsParser() {
        var _this;
        _classCallCheck31(this, TimestampSecondsParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty30(_assertThisInitialized30(_this), "priority", 40);
        _defineProperty30(_assertThisInitialized30(_this), "incompatibleTokens", '*');
        return _this;
    }
    _createClass31(TimestampSecondsParser, [
        {
            key: "parse",
            value: function parse(dateString) {
                return parseAnyDigitsSigned(dateString);
            }
        },
        {
            key: "set",
            value: function set(_date, _flags, value) {
                return [
                    new Date(value * 1000),
                    {
                        timestampIsSet: true
                    }
                ];
            }
        }
    ]);
    return TimestampSecondsParser;
}(Parser);
function _typeof32(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof32 = function _typeof(obj) {
            return typeof obj;
        };
    } else {
        _typeof32 = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
    }
    return _typeof32(obj);
}
function _classCallCheck32(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
function _defineProperties32(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
    }
}
function _createClass32(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties32(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties32(Constructor, staticProps);
    return Constructor;
}
function _inherits31(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    if (superClass) _setPrototypeOf31(subClass, superClass);
}
function _setPrototypeOf31(o, p) {
    _setPrototypeOf31 = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    };
    return _setPrototypeOf31(o, p);
}
function _createSuper31(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct31();
    return function _createSuperInternal() {
        var Super = _getPrototypeOf31(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = _getPrototypeOf31(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn31(this, result);
    };
}
function _possibleConstructorReturn31(self, call) {
    if (call && (_typeof32(call) === "object" || typeof call === "function")) {
        return call;
    }
    return _assertThisInitialized31(self);
}
function _assertThisInitialized31(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
function _isNativeReflectConstruct31() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
function _getPrototypeOf31(o) {
    _getPrototypeOf31 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf31(o);
}
function _defineProperty31(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var TimestampMillisecondsParser = function(_Parser) {
    _inherits31(TimestampMillisecondsParser, _Parser);
    var _super = _createSuper31(TimestampMillisecondsParser);
    function TimestampMillisecondsParser() {
        var _this;
        _classCallCheck32(this, TimestampMillisecondsParser);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [
            this
        ].concat(args));
        _defineProperty31(_assertThisInitialized31(_this), "priority", 20);
        _defineProperty31(_assertThisInitialized31(_this), "incompatibleTokens", '*');
        return _this;
    }
    _createClass32(TimestampMillisecondsParser, [
        {
            key: "parse",
            value: function parse(dateString) {
                return parseAnyDigitsSigned(dateString);
            }
        },
        {
            key: "set",
            value: function set(_date, _flags, value) {
                return [
                    new Date(value),
                    {
                        timestampIsSet: true
                    }
                ];
            }
        }
    ]);
    return TimestampMillisecondsParser;
}(Parser);
({
    G: new EraParser(),
    y: new YearParser(),
    Y: new LocalWeekYearParser(),
    R: new ISOWeekYearParser(),
    u: new ExtendedYearParser(),
    Q: new QuarterParser(),
    q: new StandAloneQuarterParser(),
    M: new MonthParser(),
    L: new StandAloneMonthParser(),
    w: new LocalWeekParser(),
    I: new ISOWeekParser(),
    d: new DateParser(),
    D: new DayOfYearParser(),
    E: new DayParser(),
    e: new LocalDayParser(),
    c: new StandAloneLocalDayParser(),
    i: new ISODayParser(),
    a: new AMPMParser(),
    b: new AMPMMidnightParser(),
    B: new DayPeriodParser(),
    h: new Hour1to12Parser(),
    H: new Hour0to23Parser(),
    K: new Hour0To11Parser(),
    k: new Hour1To24Parser(),
    m: new MinuteParser(),
    s: new SecondParser(),
    S: new FractionOfSecondParser(),
    X: new ISOTimezoneWithZParser(),
    x: new ISOTimezoneParser(),
    t: new TimestampSecondsParser(),
    T: new TimestampMillisecondsParser()
});
function subDays(dirtyDate, dirtyAmount) {
    requiredArgs(2, arguments);
    var amount = toInteger1(dirtyAmount);
    return addDays(dirtyDate, -amount);
}
const x2 = {
    "X-APPLE-TRAVEL-ADVISORY-BEHAVIOR": "AUTOMATIC"
};
function getIcal(items) {
    const timezone = "Europe/Amsterdam";
    const cal = Q({
        name: "Afval Kalender",
        description: "Klaterbos",
        ttl: 3600 * 24,
        prodId: {
            company: "Sander Spilleman",
            product: "Afval Kalender Klaterbos",
            language: "NL"
        },
        timezone: {
            name: timezone,
            generator: getVtimezoneComponent
        }
    });
    for (const item of items){
        for (const date of item.pickupDates){
            const description = {
                plain: item.description
            };
            const current = new Date();
            const start = subDays(new Date(date), 1);
            start.setHours(18);
            const end = subDays(new Date(date), 1);
            end.setHours(19);
            const data = {
                allDay: false,
                start: start,
                end: end,
                summary: map[item._pickupTypeText],
                description,
                created: current,
                lastModified: current,
                transparency: z.OPAQUE,
                x: x2,
                floating: false,
                timezone
            };
            const e = cal.createEvent(data);
            const display = e.createAlarm();
            display.trigger(3600);
            display.type(O1.display);
            const audio = e.createAlarm();
            audio.trigger(3600);
            audio.type(O1.audio);
        }
    }
    return cal.toString();
}
function deferred1() {
    let methods;
    let state = "pending";
    const promise = new Promise((resolve, reject)=>{
        methods = {
            async resolve (value) {
                await value;
                state = "fulfilled";
                resolve(value);
            },
            reject (reason) {
                state = "rejected";
                reject(reason);
            }
        };
    });
    Object.defineProperty(promise, "state", {
        get: ()=>state
    });
    return Object.assign(promise, methods);
}
function delay1(ms, options = {}) {
    const { signal , persistent  } = options;
    if (signal?.aborted) {
        return Promise.reject(new DOMException("Delay was aborted.", "AbortError"));
    }
    return new Promise((resolve, reject)=>{
        const abort = ()=>{
            clearTimeout(i);
            reject(new DOMException("Delay was aborted.", "AbortError"));
        };
        const done = ()=>{
            signal?.removeEventListener("abort", abort);
            resolve();
        };
        const i = setTimeout(done, ms);
        signal?.addEventListener("abort", abort, {
            once: true
        });
        if (persistent === false) {
            try {
                Deno.unrefTimer(i);
            } catch (error) {
                if (!(error instanceof ReferenceError)) {
                    throw error;
                }
                console.error("`persistent` option is only available in Deno");
            }
        }
    });
}
class MuxAsyncIterator1 {
    #iteratorCount = 0;
    #yields = [];
    #throws = [];
    #signal = deferred1();
    add(iterable) {
        ++this.#iteratorCount;
        this.#callIteratorNext(iterable[Symbol.asyncIterator]());
    }
    async #callIteratorNext(iterator) {
        try {
            const { value , done  } = await iterator.next();
            if (done) {
                --this.#iteratorCount;
            } else {
                this.#yields.push({
                    iterator,
                    value
                });
            }
        } catch (e) {
            this.#throws.push(e);
        }
        this.#signal.resolve();
    }
    async *iterate() {
        while(this.#iteratorCount > 0){
            await this.#signal;
            for(let i = 0; i < this.#yields.length; i++){
                const { iterator , value  } = this.#yields[i];
                yield value;
                this.#callIteratorNext(iterator);
            }
            if (this.#throws.length) {
                for (const e of this.#throws){
                    throw e;
                }
                this.#throws.length = 0;
            }
            this.#yields.length = 0;
            this.#signal = deferred1();
        }
    }
    [Symbol.asyncIterator]() {
        return this.iterate();
    }
}
const ERROR_SERVER_CLOSED = "Server closed";
const INITIAL_ACCEPT_BACKOFF_DELAY1 = 5;
const MAX_ACCEPT_BACKOFF_DELAY1 = 1000;
class Server {
    #port;
    #host;
    #handler;
    #closed = false;
    #listeners = new Set();
    #acceptBackoffDelayAbortController = new AbortController();
    #httpConnections = new Set();
    #onError;
    constructor(serverInit){
        this.#port = serverInit.port;
        this.#host = serverInit.hostname;
        this.#handler = serverInit.handler;
        this.#onError = serverInit.onError ?? function(error) {
            console.error(error);
            return new Response("Internal Server Error", {
                status: 500
            });
        };
    }
    async serve(listener) {
        if (this.#closed) {
            throw new Deno.errors.Http(ERROR_SERVER_CLOSED);
        }
        this.#trackListener(listener);
        try {
            return await this.#accept(listener);
        } finally{
            this.#untrackListener(listener);
            try {
                listener.close();
            } catch  {}
        }
    }
    async listenAndServe() {
        if (this.#closed) {
            throw new Deno.errors.Http(ERROR_SERVER_CLOSED);
        }
        const listener = Deno.listen({
            port: this.#port ?? 80,
            hostname: this.#host ?? "0.0.0.0",
            transport: "tcp"
        });
        return await this.serve(listener);
    }
    async listenAndServeTls(certFile, keyFile) {
        if (this.#closed) {
            throw new Deno.errors.Http(ERROR_SERVER_CLOSED);
        }
        const listener = Deno.listenTls({
            port: this.#port ?? 443,
            hostname: this.#host ?? "0.0.0.0",
            certFile,
            keyFile,
            transport: "tcp"
        });
        return await this.serve(listener);
    }
    close() {
        if (this.#closed) {
            throw new Deno.errors.Http(ERROR_SERVER_CLOSED);
        }
        this.#closed = true;
        for (const listener of this.#listeners){
            try {
                listener.close();
            } catch  {}
        }
        this.#listeners.clear();
        this.#acceptBackoffDelayAbortController.abort();
        for (const httpConn of this.#httpConnections){
            this.#closeHttpConn(httpConn);
        }
        this.#httpConnections.clear();
    }
    get closed() {
        return this.#closed;
    }
    get addrs() {
        return Array.from(this.#listeners).map((listener)=>listener.addr);
    }
    async #respond(requestEvent, connInfo) {
        let response;
        try {
            response = await this.#handler(requestEvent.request, connInfo);
            if (response.bodyUsed && response.body !== null) {
                throw new TypeError("Response body already consumed.");
            }
        } catch (error) {
            response = await this.#onError(error);
        }
        try {
            await requestEvent.respondWith(response);
        } catch  {}
    }
    async #serveHttp(httpConn, connInfo) {
        while(!this.#closed){
            let requestEvent;
            try {
                requestEvent = await httpConn.nextRequest();
            } catch  {
                break;
            }
            if (requestEvent === null) {
                break;
            }
            this.#respond(requestEvent, connInfo);
        }
        this.#closeHttpConn(httpConn);
    }
    async #accept(listener) {
        let acceptBackoffDelay;
        while(!this.#closed){
            let conn;
            try {
                conn = await listener.accept();
            } catch (error) {
                if (error instanceof Deno.errors.BadResource || error instanceof Deno.errors.InvalidData || error instanceof Deno.errors.UnexpectedEof || error instanceof Deno.errors.ConnectionReset || error instanceof Deno.errors.NotConnected) {
                    if (!acceptBackoffDelay) {
                        acceptBackoffDelay = INITIAL_ACCEPT_BACKOFF_DELAY1;
                    } else {
                        acceptBackoffDelay *= 2;
                    }
                    if (acceptBackoffDelay >= 1000) {
                        acceptBackoffDelay = MAX_ACCEPT_BACKOFF_DELAY1;
                    }
                    try {
                        await delay1(acceptBackoffDelay, {
                            signal: this.#acceptBackoffDelayAbortController.signal
                        });
                    } catch (err) {
                        if (!(err instanceof DOMException && err.name === "AbortError")) {
                            throw err;
                        }
                    }
                    continue;
                }
                throw error;
            }
            acceptBackoffDelay = undefined;
            let httpConn;
            try {
                httpConn = Deno.serveHttp(conn);
            } catch  {
                continue;
            }
            this.#trackHttpConnection(httpConn);
            const connInfo = {
                localAddr: conn.localAddr,
                remoteAddr: conn.remoteAddr
            };
            this.#serveHttp(httpConn, connInfo);
        }
    }
    #closeHttpConn(httpConn) {
        this.#untrackHttpConnection(httpConn);
        try {
            httpConn.close();
        } catch  {}
    }
    #trackListener(listener) {
        this.#listeners.add(listener);
    }
    #untrackListener(listener) {
        this.#listeners.delete(listener);
    }
    #trackHttpConnection(httpConn) {
        this.#httpConnections.add(httpConn);
    }
    #untrackHttpConnection(httpConn) {
        this.#httpConnections.delete(httpConn);
    }
}
function hostnameForDisplay(hostname) {
    return hostname === "0.0.0.0" ? "localhost" : hostname;
}
async function serve(handler, options = {}) {
    let port = options.port ?? 8000;
    const hostname = options.hostname ?? "0.0.0.0";
    const server = new Server({
        port,
        hostname,
        handler,
        onError: options.onError
    });
    options?.signal?.addEventListener("abort", ()=>server.close(), {
        once: true
    });
    const listener = Deno.listen({
        port,
        hostname,
        transport: "tcp"
    });
    const s = server.serve(listener);
    port = server.addrs[0].port;
    if ("onListen" in options) {
        options.onListen?.({
            port,
            hostname
        });
    } else {
        console.log(`Listening on http://${hostnameForDisplay(hostname)}:${port}/`);
    }
    return await s;
}
const methods1 = [
    "GET",
    "POST",
    "PUT",
    "DELETE"
];
class Router {
    notFound = new Response(null, {
        status: 404
    });
    routes = methods1.reduce((prev, cur)=>{
        prev[cur] = [];
        return prev;
    }, {});
    add(method, pathname, handlers) {
        const pattern = new URLPattern({
            pathname
        });
        this.routes[method].push({
            pattern,
            handlers
        });
    }
    get = (pathname, handlers)=>this.add("GET", pathname, handlers);
    post = (pathname, handlers)=>this.add("POST", pathname, handlers);
    put = (pathname, handlers)=>this.add("PUT", pathname, handlers);
    delete = (pathname, handlers)=>this.add("DELETE", pathname, handlers);
    findRoute(method, url) {
        return this.routes[method].find((r)=>r.pattern.test(url));
    }
    async route(req, headers) {
        if (!this.routes[req.method]) return this.notFound;
        const route = this.findRoute(req.method, req.url);
        if (!route) return this.notFound;
        const params = route.pattern.exec(req.url)?.pathname.groups;
        if (!params) return this.notFound;
        for (const fn of route.handlers){
            const result = await fn(req, params, headers);
            if (result.constructor === Headers) headers = result;
            if (result.constructor === Response) return result;
        }
        throw new Error(`${route.pattern.pathname} is not handled`);
    }
}
const getCal = async (_request, _params, headers)=>{
    const json = await getCalendar();
    if (!json) return new Response("error", {
        status: 400,
        headers
    });
    const ical = getIcal(json.dataList);
    headers.set("content-type", "text/calendar; charset=utf-8");
    return new Response(ical, {
        status: 200,
        headers
    });
};
const router = new Router();
router.get("/", [
    getCal
]);
const getDefaultHeaders = (request)=>{
    const headers = new Headers();
    const authorization = request.headers.get("Authorization");
    if (authorization) headers.set("Authorization", authorization);
    const origin = request.headers.get("origin") || request.headers.get("host");
    headers.set("Access-Control-Allow-Origin", origin);
    headers.set("Access-Control-Allow-Credentials", "true");
    headers.set("Access-Control-Expose-Headers", "*");
    headers.set("access-control-expose-headers", "*");
    return headers;
};
const hostname = "0.0.0.0";
const options = {
    hostname,
    port: 4000
};
await serve(async (request)=>{
    const headers = getDefaultHeaders(request);
    try {
        if (request.method === "OPTIONS") {
            headers.set("Access-Control-Allow-Headers", "Content-Type, Access-Control-Allow-Headers, Authorization, X-Requested-With, X-Forwarded-For");
            return new Response(null, {
                status: 204,
                headers
            });
        } else {
            return await router.route(request, headers);
        }
    } catch (error) {
        console.log("catch", error);
        return new Response("Internal Server Error", {
            status: 500,
            headers
        });
    }
}, options).catch((err)=>console.log(err));
